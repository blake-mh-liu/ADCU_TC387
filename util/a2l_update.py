#!/usr/bin/env python
from argparse import ArgumentParser
import re
import subprocess


class A2lUpdater():
    """An A2L file updater"""

    trenner = [' ', '[', ']', '(', ')', ',', ';', '=', '\r', '\n']

    def __init__(self, elf_file):
        self._symbol_table = self._parse_symbol_table(elf_file)
        self._a2l_input = ""

    def _find_address(self, name):
        """Returns the address of the given name."""

        if name in self._symbol_table:
            address = self._symbol_table[name]
            return f"{int(address, 16):#X}"

        print("name: " + name + " not found ")
        return "0"

    def _parse_symbol_table(self, elf_file):
        """Extract the symbol table from the given ELF file"""

        symbols = {}
        with subprocess.Popen("objdump -t " + elf_file,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT,
                              shell=True) as process:
            sym_table_stream = process.communicate()[0]

        # Load symbols out of symfile generated by objdump
        for line in sym_table_stream.decode("utf-8").split('\n'):
            match = re.match(r'(.*?)\ .*\t(.*?)\ (.*)', line)
            if hasattr(match, 'group'):
                symbols[match.group(3).strip()] = match.group(1)

        return symbols

    def _next_token(self, pos, length):
        """Returns the next token."""

        while pos < length:
            if self._a2l_input[pos:pos+2] == "/*":
                pos = pos + 2
                start_pos = pos
                while pos < length and not self._a2l_input[pos:pos+2] == '*/':
                    pos = pos + 1
                pos = pos+2
            elif self._a2l_input[pos] == '"':
                pos = pos + 1
                start_pos = pos
                while pos < length and not self._a2l_input[pos] == '"':
                    pos = pos + 1
                return [pos+1, "STRING", self._a2l_input[start_pos:pos]]
            elif self._a2l_input[pos:pos+6] == "/begin":
                return [pos+6, "BEGIN", ""]
            elif self._a2l_input[pos:pos+4] == "/end":
                return [pos+4, "END", ""]
            elif self._a2l_input[pos].isspace() or self._a2l_input[pos] in A2lUpdater.trenner:
                pos = pos + 1
            else:
                start_pos = pos
                while pos < length and not self._a2l_input[pos] in A2lUpdater.trenner:
                    pos = pos + 1
                return [pos, "OUTLINE", self._a2l_input[start_pos:pos]]
        return [pos, "END", ""]

    def _update_a2l(self):
        """Update the given A2L file with addresses."""

        length = len(self._a2l_input)
        output_strings = []

        pos = 0
        last_pos = 0
        while pos < length:
            [pos, token, _] = self._next_token(pos, length)
            if pos < length:
                self._next_token(pos, length)

            if token == "BEGIN":
                [pos, _, block_name] = self._next_token(pos, length)

                if block_name == "CHARACTERISTIC":
                    output_strings.append(self._a2l_input[last_pos:pos])

                    [pos, _, name] = self._next_token(pos, length)
                    [pos, _, long_identifier] = self._next_token(pos, length)
                    [pos, _, a2l_type] = self._next_token(pos, length)
                    [pos, _, _] = self._next_token(pos, length)
                    last_pos = pos

                    output_strings.append("\n" + name + "\n\"" +
                                          long_identifier + "\"\n" + a2l_type +
                                          "\n " + self._find_address(name) + "\n")
                elif block_name == "MEASUREMENT":
                    output_strings.append(self._a2l_input[last_pos:pos])

                    [pos, _, name] = self._next_token(pos, length)
                    [pos, _, long_identifier] = self._next_token(pos, length)
                    [pos, _, data_type] = self._next_token(pos, length)
                    output_strings.append(
                        "\n" + name + "\n\"" + long_identifier + "\"\n" + data_type + "\n")
                    last_pos = pos

                    while block_name != "ECU_ADDRESS":
                        [pos, _, block_name] = self._next_token(pos, length)
                        output_strings.append(self._a2l_input[last_pos:pos])
                        last_pos = pos

                    [pos, _, block_name] = self._next_token(pos, length)
                    last_pos = pos
                    output_strings.append(
                        "\t " + self._find_address(name) + "\n")
                elif block_name == "AXIS_PTS":
                    output_strings.append(self._a2l_input[last_pos:pos])

                    [pos, _, name] = self._next_token(pos, length)
                    [pos, _, long_identifier] = self._next_token(pos, length)
                    [pos, _, _] = self._next_token(pos, length)
                    last_pos = pos

                    output_strings.append("\n" + name + "\n\"" +
                                          long_identifier + "\"\n" +
                                          self._find_address(name) + "\n")

            output_strings.append(self._a2l_input[last_pos:pos])
            last_pos = pos

        return "".join(output_strings)

    def update(self, input_file, output_file):
        """Updates the input file"""

        with open(input_file, "r", encoding="utf-8") as a2l_input_file:
            self._a2l_input = a2l_input_file.read()

        with open(output_file, "w", encoding="utf-8") as new_a2l_file:
            new_a2l = self._update_a2l()
            new_a2l_file.write(new_a2l)


def main():
    """Main entry point"""

    parser = ArgumentParser(
        description="Update an A2L file with addresses from the given ELF file")
    parser.add_argument("elf_file", metavar="elf-file")
    parser.add_argument("input", metavar="a2l-input")
    parser.add_argument("output", metavar="a2l-output")
    args = parser.parse_args()

    updater = A2lUpdater(args.elf_file)
    updater.update(args.input, args.output)


if __name__ == '__main__':
    main()
