<?xml version='1.0'?>
<datamodel version="8.0" 
           xmlns="http://www.tresos.de/_projects/DataModel2/18/root.xsd" 
           xmlns:a="http://www.tresos.de/_projects/DataModel2/18/attribute.xsd" 
           xmlns:v="http://www.tresos.de/_projects/DataModel2/06/schema.xsd" 
           xmlns:d="http://www.tresos.de/_projects/DataModel2/06/data.xsd">

  <d:ctr type="AUTOSAR" factory="autosar" 
         xmlns:ad="http://www.tresos.de/_projects/DataModel2/08/admindata.xsd" 
         xmlns:ce="http://www.tresos.de/_projects/DataModel2/18/childenable.xsd" 
         xmlns:cd="http://www.tresos.de/_projects/DataModel2/08/customdata.xsd" 
         xmlns:f="http://www.tresos.de/_projects/DataModel2/14/formulaexpr.xsd" 
         xmlns:icc="http://www.tresos.de/_projects/DataModel2/08/implconfigclass.xsd" 
         xmlns:mt="http://www.tresos.de/_projects/DataModel2/11/multitest.xsd"  
         xmlns:variant="http://www.tresos.de/_projects/DataModel2/11/variant.xsd">
    <d:lst type="TOP-LEVEL-PACKAGES">
      <d:ctr name="TS_TxDxM2I74R0" type="AR-PACKAGE">
        <d:lst type="ELEMENTS">
          <d:chc name="Prog" type="AR-ELEMENT" value="MODULE-DEF">
            <v:ctr type="MODULE-DEF">
              <a:a name="ADMIN-DATA" type="ADMIN-DATA">
                <ad:ADMIN-DATA>
                  <ad:LANGUAGE>EN</ad:LANGUAGE>
                  <ad:DOC-REVISIONS>
                    <ad:DOC-REVISION>
                      <ad:REVISION-LABEL>4.0.3</ad:REVISION-LABEL>
                      <ad:ISSUED-BY>AUTOSAR</ad:ISSUED-BY>
                    </ad:DOC-REVISION>
                    <ad:DOC-REVISION>
                      <ad:REVISION-LABEL>2.74.0</ad:REVISION-LABEL>
                      <ad:ISSUED-BY>Elektrobit Automotive GmbH</ad:ISSUED-BY>
                      <ad:DATE>2024-05-02T23:59:59Z</ad:DATE>
                    </ad:DOC-REVISION>
                  </ad:DOC-REVISIONS>
                </ad:ADMIN-DATA>
              </a:a>
              <a:a name="DESC">
                <a:v>EN:&lt;html&gt;
                            Configuration of the Prog module.
                        &lt;/html&gt;</a:v>
              </a:a>
              <a:a name="LOWER-MULTIPLICITY" value="1"/>
              <a:a name="RELEASE" value="asc:4.0"/>
              <a:a name="UPPER-MULTIPLICITY" value="1"/>
              <a:a name="UUID" value="3d92ddc5-303e-4648-927e-0d2f27850c98"/>
              <v:ctr name="PublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>EN:
                    &lt;html&gt;
                      Additional published parameters not covered by CommonPublishedInformation container.
                  &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="LABEL" value="EB Published Information"/>
                <a:a name="TAB" value="EB Published Information"/>
                <a:a name="UUID" 
                     value="ECUC:cb4128ed-26c1-4ddd-906e-854bed917e07"/>
                <v:var name="PbcfgMSupport" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Specifies whether or not the Prog can use the PbcfgM module for post-build support.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="PbcfgM support"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:eb61002e-69c0-4f16-a910-c27adb75f6ee"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
              </v:ctr>
              <v:ctr name="CommonPublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>EN:
                    &lt;html&gt;
                      Common container, aggregated by all modules. It contains published information about vendor and versions.
                  &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="LABEL" value="Common Published Information"/>
                <a:a name="UUID" 
                     value="ECUC:a00be3e0-8783-9123-2d52-1eb616737ca6"/>
                <v:var name="ArMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Major version number of AUTOSAR specification on which the appropriate implementation is based on.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="AUTOSAR Major Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:948f3f2e-f129-4bc5-b4e1-7a7bdb8599e1"/>
                  <a:da name="DEFAULT" value="4"/>
                </v:var>
                <v:var name="ArMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Minor version number of AUTOSAR specification on which the appropriate implementation is based on.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="AUTOSAR Minor Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:2893b920-59d5-4ac2-b2c1-e23742e66d70"/>
                  <a:da name="DEFAULT" value="0"/>
                </v:var>
                <v:var name="ArPatchVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Patch level version number of AUTOSAR specification on which the appropriate implementation is based on.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="AUTOSAR Patch Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:6428eb9b-8790-488a-b9a3-0fba52d0f59e"/>
                  <a:da name="DEFAULT" value="3"/>
                </v:var>
                <v:var name="SwMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Major version number of the vendor specific implementation of the module.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Software Major Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:605b18ae-3f9a-41d4-9225-67c9c5f6fc34"/>
                  <a:da name="DEFAULT" value="2"/>
                </v:var>
                <v:var name="SwMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Minor version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Software Minor Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="a7fe44dc-ea25-4b8d-8fad-9fbcae86d56f"/>
                  <a:da name="DEFAULT" value="74"/>
                </v:var>
                <v:var name="SwPatchVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Patch level version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Software Patch Version"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="a318d2d9-0e75-49da-ac43-e7e4e682e2f9"/>
                  <a:da name="DEFAULT" value="0"/>
                </v:var>
                <v:var name="ModuleId" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Module ID of this module from Module List
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Numeric Module ID"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:78bc8362-080f-4253-b3da-804ab69a7154"/>
                  <a:da name="DEFAULT" value="0"/>
                </v:var>
                <v:var name="VendorId" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v>EN:
                      &lt;html&gt;
                        Vendor ID of the dedicated implementation of this module according to the AUTOSAR vendor list
                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Vendor ID"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:01b0f467-6943-4558-b4f2-3fa1fad28449"/>
                  <a:da name="DEFAULT" value="1"/>
                </v:var>
                <v:var name="Release" type="STRING_LABEL">
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       value="PublishedInformation"/>
                  <a:a name="LABEL" value="Release Information"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" 
                       value="ECUC:1c68a547-f24e-4a4e-9540-69fbd533ec89"/>
                  <a:da name="DEFAULT" value=""/>
                </v:var>
              </v:ctr>
              <v:ctr name="General" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        This container contains the general proprieties of the node.
                                    &lt;/html&gt;</a:v>
                </a:a>
                <v:var name="MANAGE_PERIOD" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specifies the period of the PROG manage task in ms.&lt;/p&gt;
                                            &lt;p&gt;This period must be multiple of EB periodical value in EB module configuration.&lt;/p&gt;
                                            &lt;p&gt;Range:[1ms ; 25ms]&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="10"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=1"/>
                    <a:tst expr="&lt;=25"/>
                  </a:da>
                </v:var>
                <v:var name="NO_SECURITYLEVEL_RESET_ON_SESSIONCHANGE" 
                       type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Enabling this parameter allows the Bootloader: &lt;/p&gt;
                                            &lt;p&gt;1. To have the security level unchanged(no security level reset) across the transitions between Non-Default sessions. &lt;/p&gt;
                                            &lt;p&gt;2. No need to unlock the same security level in the Bootloader, if the unlocking of Security (for the same Security level) is already done from the Application just before starting/jumping to the Bootloader. &lt;/p&gt;
                                            &lt;p&gt; Note: To have the second functionality enabled, the SecurityLevel variable shall be mapped to the shared Non volatile memory of Application and Bootloader. &lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="No Security Level reset on Session change"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFCA&apos;)))"/>
                </v:var>
                <v:var name="Enable_Compression" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify if the compression is enable.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Compression_Algorithm" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Compression algorithm id that shall be supported from dataFormatIdentifier field of RequestDownload service&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Compression algorithm Id"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range" expr="&lt;=15"/>
                </v:var>
                <v:var name="Decomp_Out_Buffer_size" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Size of the Output decompression buffer.&lt;/p&gt;

                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="4000"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="as:modconf(&apos;Prog&apos;)/General/Enable_Compression=&apos;true&apos;"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=1000"/>
                    <a:tst expr="&lt;=50000"/>
                  </a:da>
                </v:var>
                <v:var name="Enable_Decompression_Slicing" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify if the slicing decompression is enable.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="as:modconf(&apos;Prog&apos;)/General/Enable_Compression=&apos;true&apos;"/>
                </v:var>
                <v:var name="Decomp_Slice_size" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Size of the decompression input buffer slice.&lt;/p&gt;

                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="512"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="as:modconf(&apos;Prog&apos;)/General/Enable_Decompression_Slicing=&apos;true&apos;"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=1"/>
                    <a:tst expr="&lt;=1000"/>
                  </a:da>
                </v:var>
                <v:var name="Data_Size_In_RD" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This entry allows to specify if the data size passed in the RequestDownload service means
                                            the compressed or decompressed data size.&lt;/p&gt;
                                            &lt;p&gt;Please select between :&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;compressed&lt;/li&gt;
                                              &lt;li&gt;decompressed&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Compression"/>
                  <a:da name="DEFAULT" value="compressed"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="as:modconf(&apos;Prog&apos;)/General/Enable_Compression=&apos;true&apos;"/>
                  <a:da name="RANGE">
                    <a:v>compressed</a:v>
                    <a:v>decompressed</a:v>
                  </a:da>
                </v:var>
                <v:ctr name="ProgCalReferences" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                             Contains references to Cal configuration identifiers.&lt;br/&gt;
                                          &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ProgCalReferences"/>
                  <a:a name="TAB" value="Compression"/>
                  <v:ref name="ProgCalDecompressConfigId" 
                         type="CHOICE-REFERENCE">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                             &lt;p&gt;Reference a &lt;em&gt;CalDecompress&lt;/em&gt;&lt;/p&gt;

                                             &lt;p&gt;Dependencies:&lt;/p&gt;
                                             &lt;ul&gt;
                                                &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                             &lt;/ul&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                         type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v class="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="LABEL" value="ProgCalDecompressConfigId"/>
                    <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(node:exists(as:modconf(&apos;Cal&apos;)) and as:modconf(&apos;Prog&apos;)/General/Enable_Compression=&apos;true&apos;)"/>
                    <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                          false="Invalid reference."/>
                    <a:da name="REF" 
                          value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Cal/CalDecompress/CalDecompressConfig"/>
                  </v:ref>
                </v:ctr>
                <v:var name="Dsc_Prog_Response" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify if the DSC 02 response shall be sent by the bootloader if
                                            the application receive a reprogramming request&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case tick: The response will be sent by the bootloader&lt;/li&gt;
                                              &lt;li&gt;Case untick: The response will not be sent by the bootloader&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Diagnostic Reprogramming response"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgJLR&apos;)) or node:exists(as:modconf(&apos;ProgGM&apos;))                                     or node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgFCA&apos;))                                     or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))                                     or node:exists(as:modconf(&apos;ProgPSA&apos;)) or node:exists(as:modconf(&apos;ProgFord&apos;)))"/>
                </v:var>
                <v:var name="Prog_RC_CrcOffset" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                        &lt;p&gt;the CRC Offset is applicable for RoutineControl CheckMemory and the configured CRC Offset will be added to the PROG_MSG_BYTE_INDEX. For offset &quot;0&quot; CRC will be added right after the RoutineControl CheckMemory(i.e 31 01 &quot;CheckMemoryRID&quot; &quot;CRC&quot;). &lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="PROG RoutineControl CheckMemory CRC OFFSET"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=4294967295"/>
                  </a:da>
                </v:var>
                <v:var name="Expected_Crc_Location" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify if the expected CRC should be get by calling a callback or if it is passed in the request.&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case Application: The CRC is get by calling PROG_CustomGetExpectedCrc callback&lt;/li&gt;
                                              &lt;li&gt;Case Request: The CRC is passed in the CheckMemory routine request.&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="CRC Location: Request/Application"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Request"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>Request</a:v>
                    <a:v>Application</a:v>
                  </a:da>
                </v:var>
                <v:var name="Network_Management" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify if the network management shall be supported or not.&lt;/p&gt;
                                          &lt;p&gt;This feature shall only be activated for VCC or Ford Bootloader on FlexRay.&lt;/p&gt;
                                          &lt;ul&gt;
                                            &lt;li&gt;Case tick: Network management supported&lt;/li&gt;
                                            &lt;li&gt;Case untick: Network management not supported&lt;/li&gt;
                                          &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVCC&apos;))"/>
                </v:var>
                <v:var name="Auto_Control" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify if auto-control shall be done or not at the end of application download.&lt;/p&gt;
                                          &lt;ul&gt;
                                            &lt;li&gt;Case tick: Auto-Control shall be done&lt;/li&gt;
                                            &lt;li&gt;Case untick: Auto-Control shall not be done&lt;/li&gt;
                                          &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgJLR&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;))"/>
                </v:var>
                <v:var name="Use_CSM_ASR430_DemoWrapper" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;To have the compatibility of BL modules with Cryto ASR 4.3.x the CSM wrapper in the demo is introduced.&lt;/p&gt;
                                      &lt;p&gt;Tick this option if you wish to make use of CSM wrapper to integrate ASR version 4.3.x Crypto modules.&lt;/p&gt;
                                      &lt;p&gt;Note: This parameter is depreciated in the current Prog module version and integration of the Csm ASR 4.3
                                      wrapper is no longer needed as the product supports the integration of Csm stack ASR 4.3. For having the backward 
                                      compatibility with the previous versions of the BL modules, this parameter is retained and shall be removed in 
                                      the future releases.&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Use ASR 4.3 Demo-CSM Wrapper"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Tunable_Parameters" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;This option allows to set the Segment configuration of the layer (in PROG_Cfg.c) in RAM.&lt;/p&gt;
                                      &lt;p&gt;An API called PROG_ParametersInit is also generated to initialize the parameters from the ROM.&lt;/p&gt;
                                      &lt;p&gt;This allows the customer to change dynamically the segment address values after the initialization.&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Dual_Memory_Bank_Used" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;This option allows the usage of dual memory bank feature on the supported hardware.
                                      Please reffer to the user manual for details.&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Dual Memory Bank Used"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Transmit_Nrc78_Before_EraseCheck" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if an NRC78 response shall be systematically sent receiving the Erase request and before the routine
                                        processing (before software invalidation).&lt;/p&gt;
                                      &lt;ul&gt;
                                        &lt;li&gt;Case untick: NRC78 will not be sent immediatly after a valid Erase request.&lt;/li&gt;
                                      &lt;/ul&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="NRC78 transmission before software invalidation"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Erase"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Transmit_Nrc78_On_Erase" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if an NRC78 response shall be sent before starting the memory erasing and after the software
                                        invalidation.&lt;/p&gt;
                                      &lt;ul&gt;
                                        &lt;li&gt;Case untick: NRC78 will not be sent before the start of the memory erasing.&lt;/li&gt;
                                      &lt;/ul&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="NRC78 transmission after software invalidation"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Erase"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="PreliminaryErasing" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Enable the Preliminary Erasing in EraseMemory request (Available only if erasing mode is by LogicalBlock)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Preliminary Erasing Enable"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Erase"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)))"/>
                </v:var>
                <v:var name="MaxBlockID" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;The identifier used for the Preliminary Erasing can be defined in 1 or 2 bytes (e.g. 0xFF or 0xFFFF).&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Max Block ID"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Erase"/>
                  <a:da name="DEFAULT" value="FF"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) and ../PreliminaryErasing = &apos;true&apos;)"/>
                  <a:da name="RANGE">
                    <a:v>FF</a:v>
                    <a:v>FFFF</a:v>
                  </a:da>
                </v:var>
                <v:var name="Number_Of_Sector_To_Erase_Before_Sending_NRC78" 
                       type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Defines the number of sectors to erase before sending NRC78 to the tester&lt;/p&gt;
                                      &lt;ul&gt;
                                        &lt;li&gt;If this value is set to &quot;0&quot; then the feature erase by sector is deactivated and the whole erase is performed&lt;/li&gt;
                                        &lt;li&gt;If this value is greater than &quot;0&quot; then the erase by sector is enabled. In this case the NRC78 is sent each time
                                            the number of erased sectors reaches this value. It allows specifying a minimum time between two NRC78&lt;/li&gt;
                                      &lt;/ul&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Number of sector to erase before sending NRC78"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Erase"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=255"/>
                  </a:da>
                </v:var>
                <v:var name="Erase_Check" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify if software shall check if memory is already erased before doing an erase.&lt;/p&gt;
                                          &lt;ul&gt;
                                            &lt;li&gt;Disabled: No check will be done and memory will be always erase on request.&lt;/li&gt;
                                            &lt;li&gt;First Programming Check: Memory will not be erased if it has never been programmed.&lt;/li&gt;
                                            &lt;li&gt;Memory Block Erased Check: If logical block is used for erasing, the memory block is not erased if the coresponding flag is set. One flag per memory block is used to know if the memory block is already erased.&lt;/li&gt;
                                          &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Disabled"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="((node:exists(as:modconf(&apos;ProgJLR&apos;)))                                                 or (node:exists(as:modconf(&apos;ProgFord&apos;)))                                                 or (node:exists(as:modconf(&apos;ProgGM&apos;)))                                                 or ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_Mid&apos;)  ))                                                and (. =&apos;Memory Block Erased Check&apos;)" 
                        true="Memory Block Erased check cannot be chosen for the current OEM"/>
                  <a:da name="RANGE">
                    <a:v>Disabled</a:v>
                    <a:v>First Programming Check</a:v>
                    <a:v>Memory Block Erased Check</a:v>
                  </a:da>
                </v:var>
                <v:var name="Transmit_Response_Before_Reset" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if response shall be sent before resetting software.&lt;/p&gt;
                                      &lt;p&gt;Case untick: No response transmitted before performing the reset&lt;/p&gt;
                                      &lt;p&gt;Case tick: Case tick: Response is transmitted before performing the reset&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Check_Programming_PreConditions" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the programming pre-conditions should be checked.&lt;/p&gt;
                                      &lt;p&gt;If activated, Prog module will call callback PROG_CustCheckProgPrecond on reception of pre-conditions check routine and DiagnosticSessionControl(ProgrammingSession) request.&lt;/p&gt;
                                      &lt;p&gt;Project specific condition check shall be implemented in this callback.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)) or                                                                          node:exists(as:modconf(&apos;ProgPSA&apos;)) or                                                                          ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)) "/>
                </v:var>
                <v:var name="ResetAfterS3TimeoutInProgrammingSession" 
                       type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if software reset is required after S3 timeout coming from the Programming session.
                                      &lt;ul&gt;
                                        &lt;li&gt;Case tick: Trigger reset after S3 timeout coming from the Programming session.&lt;/li&gt;
                                        &lt;li&gt;Case untick: No reset triggered after S3 timeout coming from the Programming session.&lt;/li&gt;
                                      &lt;/ul&gt;
                                      &lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Trigger Reset after S3 Timeout in Programming Session"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
                <v:var name="ResetAfterS3TimeoutInExtendedSession" 
                       type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if software reset is required after S3 timeout coming from the Extended session.
                                      &lt;ul&gt;
                                        &lt;li&gt;Case tick: Trigger reset after S3 timeout coming from the Extended session.&lt;/li&gt;
                                        &lt;li&gt;Case untick: No reset triggered after S3 timeout coming from the Extended session.&lt;/li&gt;
                                      &lt;/ul&gt;
                                      &lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Trigger Reset after S3 Timeout in Extended Session"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
                <v:var name="ResetAfterDsc01InDefaultSession" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if ECU reset shall be triggered receiving a DefaultSession request while the ECU is already in Default Session.
                                      &lt;ul&gt;
                                        &lt;li&gt;Case tick: Trigger reset from any session to default session.&lt;/li&gt;
                                        &lt;li&gt;Case untick: No reset triggered if current session is already Default.&lt;/li&gt;
                                      &lt;/ul&gt;
                                      &lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Trigger Reset While Switching from default to Default Session"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
                <v:var name="Sleep_Management_Type" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify the sleep management type that shall be use&lt;/p&gt;
                                          &lt;ul&gt;
                                            &lt;li&gt;Off: No sleep management managed by the bootloader&lt;/li&gt;
                                            &lt;li&gt;Timeout: The bootloader will go into sleep mode on after a timeout without bus communication and wake up with network communication. This is also valid in case of NM message reception (when enabled)&lt;/li&gt;
                                            &lt;li&gt;I/O: The bootloader will go into sleep mode on activation of an external I/O or switch (not supported yet)&lt;/li&gt;
                                          &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Sleep Management"/>
                  <a:da name="DEFAULT" value="Timeout"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgJLR&apos;)) or node:exists(as:modconf(&apos;ProgGM&apos;)) or node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgFCA&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;)) or node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))"/>
                  <a:da name="RANGE">
                    <a:v>Off</a:v>
                    <a:v>Timeout</a:v>
                  </a:da>
                </v:var>
                <v:var name="Sleep_Management_NM_Message" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if Sleep Management feature shall be active or not active for NM Message.
                                      &lt;ul&gt;
                                        &lt;li&gt;Case tick: Sleep Management feature shall be active for NM Message.&lt;/li&gt;
                                        &lt;li&gt;Case untick: Sleep Management feature shall not be active for NM Message.&lt;/li&gt;
                                      &lt;/ul&gt;
                                      &lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Sleep Management for NM Message"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Sleep Management"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVAG&apos;))"/>
                </v:var>
                <v:var name="Sleep_Timeout" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="DEC"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify the sleep timeout value in ms.&lt;/p&gt;
                                          &lt;p&gt;This timeout is started when the ECU enter in default session&lt;/p&gt;
                                          &lt;p&gt;After this timeout expired the ECU will go in sleep mode&lt;/p&gt;
                                          &lt;p&gt;This feature is only be supported when Sleep_Management type is &quot;Timeout&quot;.&lt;/p&gt;
                                          &lt;p&gt;Default value: 15000 (15 seconds)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Sleep Management"/>
                  <a:da name="DEFAULT" value="15000"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgJLR&apos;)) or node:exists(as:modconf(&apos;ProgGM&apos;)) or node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgFCA&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;)) or node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))) and ../Sleep_Management_Type = &apos;Timeout&apos;"/>
                </v:var>
                <v:var name="Max_Bytes_in_TD" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the maxblock length for a TransferData If Osek stack is used, make sure this value was lower than buffer message value in TP module.&lt;/p&gt;
                                            &lt;p&gt; This value shall be lower than &quot;Rx Physical Buffer Size&quot; value. Please check BlPduR .&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="4095"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst 
                           expr="node:exists(as:modconf(&apos;BlPduR&apos;)) and (. &gt; num:i((as:modconf(&apos;BlPduR&apos;)[1]/General/RxPhysicalBufferSize)))" 
                           true="This value is greater than &apos;Rx Physical Buffer Size&apos; value in BlPduR module. "/>
                    <a:tst 
                           expr="(node:exists(as:modconf(&apos;ProgJLR&apos;)) or node:exists(as:modconf(&apos;ProgGM&apos;)) or node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgFCA&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;)) or node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)))                                              and (. &gt; 4294967295)" 
                           true=" This value cannot be greater than 65535 for the current OEM."/>
                  </a:da>
                </v:var>
                <v:var name="FAR_POINTER_Definition" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the syntax for far pointer.&lt;/p&gt;
                                            &lt;ul&gt;
                                                &lt;li&gt;&lt;b&gt;Example1:&lt;/b&gt; &lt;code&gt;__far&lt;/code&gt; will done &lt;code&gt;Data = (* (volatile __far *)&lt;POINTER&gt;)&lt;/code&gt;&lt;/li&gt;
                                                &lt;li&gt;&lt;b&gt;Example2:&lt;/b&gt; &lt;code&gt;&lt;/code&gt; (empty) will done &lt;code&gt;Data = (* (volatile *)&lt;POINTER&gt;)&lt;/code&gt;&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value=""/>
                </v:var>
                <v:var name="ResumableReprog" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the resumable reprogramming feature shall be used.&lt;/p&gt;
                                      &lt;p&gt;If activated, Prog module will store information allowing to resume an interrupted reprogramming.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Resumable reprogramming"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgDAG&apos;))"/>
                </v:var>
                <v:var name="SuppressPositiveResponse" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the positive response shall be suppressed.&lt;/p&gt;
                                      &lt;p&gt;If activated, Prog module will not send positive response if the request is received with SPRMIB set&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Suppress Positive Response"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="BypassSACompareKey" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if SA compare key (sub-function sendKey) is bypassed or not&lt;/p&gt;
                                      &lt;p&gt;Enabled: The SA sub-function sendKey is bypassed&lt;/p&gt;
                                      &lt;p&gt;Disabled: The SA sub-function sendKey is performed&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Bypass the SA compare key"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgPSA&apos;))"/>
                </v:var>
              </v:ctr>
              <v:ctr name="DownloadVerification" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the configuration element for download verification&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="DownloadVerification"/>
                <v:var name="FCA_Reprogramming" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify which reprogramming type shall be used.&lt;/p&gt;
                                          &lt;p&gt;Standard : use CRC16 flashed with data at address given by CRC Address field.&lt;/p&gt;
                                          &lt;p&gt;Authenticated : use a header containing a hash.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="FCA reprogramming type"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Authenticated"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)"/>
                  <a:da name="RANGE">
                    <a:v>Standard</a:v>
                    <a:v>Authenticated</a:v>
                  </a:da>
                </v:var>
                <v:var name="VerificationOnTheFly" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the download verification shall be performed after data download or in parallel (on the fly) of the download.&lt;/p&gt;
                                      &lt;p&gt;Feature availability is OEM dependent.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Verification on the fly"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;))"/>
                </v:var>
                <v:var name="Verification_Buffer_size" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="DEC"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Buffer size used during the Verification calculation.&lt;/p&gt;
                                          &lt;p&gt;Increase the value if you need to accelerate the calculation.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Verification Buffer size"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="32"/>
                </v:var>
                <v:var name="Checksum_Algo" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify which checksum algorithm shall be used&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case Signature: A cryptographic signature verification will be done (only possible if cryptographic libraries are used).
                                                  An additional CRC32 computation can be done by enabling &quot;Additional CRC computation&quot; parameter&lt;/li&gt;
                                              &lt;li&gt;Case CRC32 Ethernet: Polynomial 0x04C11DB7 / Init value 0xFFFFFFFF / ReflectIn TRUE / ReflectOut TRUE / XOR on Output 0xFFFFFFFF &lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="CRC algorithm: Signature / CRC32 Ethernet / CRC16"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="CRC32 Ethernet"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgVAG&apos;)))"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst 
                           expr="(node:exists(as:modconf(&apos;ProgFord&apos;))) and not(. =&apos;CRC16&apos;)" 
                           true="Only Algo CRC16 is supported"/>
                    <a:tst 
                           expr="(node:exists(as:modconf(&apos;ProgVAG&apos;))) and (. =&apos;CRC16&apos;)" 
                           true="Algo CRC16 is not supported"/>
                  </a:da>
                  <a:da name="RANGE">
                    <a:v>Signature</a:v>
                    <a:v>CRC32 Ethernet</a:v>
                    <a:v>CRC16</a:v>
                  </a:da>
                </v:var>
                <v:var name="SignatureVerificationOnFlashData" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;If enabled: the signature will be verified by reading the Flash memory after the data have been written.
                                         If compression is used signature is so verified on decompressed data.&lt;/p&gt;
                                      &lt;p&gt;If disabled: the signature will be verified on received data before writing to Flash memory.
                                         If compression is used signature is so verified on compressed data.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Signature Verification on Flashed data"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="true"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) and ../Checksum_Algo = &apos;Signature&apos;)"/>
                </v:var>
                <v:var name="SignatureVerificationWithAddrLen" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;If enabled: the signature will be computed including the address and length of the segment.&lt;/p&gt;
                                      &lt;p&gt;If disabled: the signature will be computed including only the programmed data.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Signature Verification with segment address/length"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgVAG&apos;)))                                     or (node:exists(as:modconf(&apos;ProgFCA&apos;)) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;) and (as:modconf(&apos;Prog&apos;)/DownloadVerification/FCA_Reprogramming = &apos;Standard&apos;))"/>
                </v:var>
                <v:var name="SignatureVerificationWithPhyAddr" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;If enabled: When address shall be included in signature computation, the physical address will be used (i.e in case of external Flash, the configured offset will apply).&lt;/p&gt;
                                      &lt;p&gt;If disabled: When address shall be included in signature computation, the logical address (received address) will be used.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Signature Verification with physical address"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgDAG&apos;)) and ../SignatureVerificationWithAddrLen = &apos;true&apos;)                                     or (node:exists(as:modconf(&apos;ProgFCA&apos;)) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;) and (as:modconf(&apos;Prog&apos;)/DownloadVerification/FCA_Reprogramming = &apos;Standard&apos;))"/>
                </v:var>
                <v:var name="AdditionalCRCComputation" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;In case signature computation is performed, if enabled an additional CRC32 computation will be performed after signature verification on the reception of the
                                      CheckMemory routine.&lt;/p&gt;
                                      &lt;p&gt;Feature availability is OEM dependent.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Additional CRC Computation"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="((node:exists(as:modconf(&apos;ProgDAG&apos;))) and ../Checksum_Algo = &apos;Signature&apos;)"/>
                </v:var>
                <v:var name="CVN_Verification" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;If enabled a calibration verification number will be performed on the reception of the verify partial software checksum routine.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="CVN Verification"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)))"/>
                </v:var>
                <v:var name="MaxNumberOfRDPerBlock" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="DEC"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the maximum number of RequestDownload that Bootloader shall support for a single logical block. This shall not exceed 255&lt;/p&gt;
                                            &lt;p&gt;It will impact the RAM memory consumption to store the downloaded memory area that shall be used for checksum computation.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Maximum RequestDownload Per Block"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="10"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgFord&apos;)) or node:exists(as:modconf(&apos;ProgVCC&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)))                                     or (node:exists(as:modconf(&apos;ProgFCA&apos;)) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;) and (as:modconf(&apos;Prog&apos;)/DownloadVerification/FCA_Reprogramming = &apos;Standard&apos;))"/>
                </v:var>
                <v:var name="Allow2MaxSuccessiveCheckMemoryRequests" 
                       type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;If enabled: Only a second successive Check Memory Requests can be allowed by the Bootloader if the result of the first one was not sucessful.&lt;/p&gt;
                                      &lt;p&gt;If disabled: No successive Check Memory Requests will be allowed by the Bootloader.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Allow 2 maximum successive Check Memory Requests"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVCC&apos;))"/>
                </v:var>
              </v:ctr>
              <v:ctr name="DownloadFlashRoutines" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the configuration element for downloading Flash routines&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="DownloadFlashRoutines"/>
                <v:var name="Download_Flash_Routines" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the flash routines will be downloaded to RAM via tester tool.&lt;/p&gt;
                                      &lt;p&gt;If activated, a RAM segment shall be configured.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Download FLash driver"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="not(as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Download_Flash_Routines=&apos;true&apos; and as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Decompress_Flash_Routines=&apos;true&apos;)" 
                        false="Decompress Flash driver and Download Flash driver can&apos;t be both activated."/>
                </v:var>
                <v:var name="Download_Pseudo_Flash_Routines" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the pseudo flash routines will be downloaded to RAM via tester tool.&lt;/p&gt;
                                      &lt;p&gt;If activated, a RAM segment shall be configured.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Download Pseudo FLash driver"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="not(as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Download_Pseudo_Flash_Routines=&apos;true&apos; and as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Decompress_Flash_Routines=&apos;true&apos;)" 
                        false="Decompress Pseudo Flash driver and Download Flash driver can&apos;t be both activated."/>
                </v:var>
                <v:var name="Decompress_Flash_Routines" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;Specify if the driver flash routines are compressed in the bootloader and need to be decompressed to RAM on security access unlock.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Decompress Flash driver"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="not(as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Download_Flash_Routines=&apos;true&apos; and as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Decompress_Flash_Routines=&apos;true&apos;)" 
                        false="Decompress Flash driver and Download Flash driver can&apos;t be both activated."/>
                </v:var>
                <v:var name="Reject_RD_After_Corrupt_Flash_Routines" 
                       type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      &lt;p&gt;if activated, after a failed check memory, a second attempt for downloading flash routines will be rejected.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Reject second attempt after failure"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))) and (as:modconf(&apos;Prog&apos;)/DownloadFlashRoutines/Download_Flash_Routines=&apos;true&apos;)"/>
                </v:var>
              </v:ctr>
              <v:ctr name="SBLVerificationBlockTable" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the location data of the verification block table of the secondary bootloader&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="VCC"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="(node:exists(as:modconf(&apos;ProgVCC&apos;)) and as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;)"/>
                <v:var name="Verification_Block_Table_Start_Address" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Start address of the verification block table of the secondary bootloader&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x7000DC00"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVCC&apos;)) and as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;)"/>
                </v:var>
                <v:var name="Verification_Block_Table_Length" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Length of the verification block table of the secondary bootloader before any processing (i.e. padding)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x0000002C"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVCC&apos;)) and as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;)"/>
                </v:var>
              </v:ctr>
              <v:ctr name="SBLVerificationStructure" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the location data of the verification structure of the secondary bootloader&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="FORD"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;)"/>
                <v:var name="Verification_Structure_Start_Address" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Start address of the verification structure of the secondary bootloader&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x7000DC00"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;)"/>
                </v:var>
                <v:var name="Verification_Structure_Length" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Length of the verification structure of the secondary bootloader before any processing (i.e. padding)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x0000002C"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;)"/>
                </v:var>
              </v:ctr>
              <v:ctr name="VerificationStructure" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the verification structure version of the PBL and SBL&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="FORD"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="(node:exists(as:modconf(&apos;ProgFord&apos;)))"/>
                <v:var name="Verification_Structure_Version" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define Verification Structure Version for the PBL and SBL.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Verification Structure Version"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="INVALID" type="Range" expr="&lt;=65535"/>
                </v:var>
              </v:ctr>
              <v:ctr name="Startup" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the general proprieties of the node&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="VCC"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgVCC&apos;))"/>
                <v:var name="PROG_Signature_High" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;MSB value set by the application to know if the reset is done from application.&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x50726f67"/>
                </v:var>
                <v:var name="PROG_Signature_Low" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;LSB value set by the application to know if the reset is done from application.&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x5369676e"/>
                </v:var>
                <v:var name="PROG_Signature_Clear" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;LSB value set by the application to know if the reset is done from application.&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x00000000"/>
                </v:var>
              </v:ctr>
              <v:ctr name="CompleteAndCompatibleBlock" type="IDENTIFIABLE">
                <a:a name="TAB" value="VCC"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgVCC&apos;))"/>
                <v:var name="Block_Start_Addr" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;First address of the Complete and compatible block.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                </v:var>
                <v:var name="Start_Complete_Compatible_Signature_High" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;MSB value set by the application at the start of the complete and compatible block&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x53746172"/>
                </v:var>
                <v:var name="Start_Complete_Compatible_Signature_Low" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;LSB value set by the application at the start of the complete and compatible block&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x74536967"/>
                </v:var>
                <v:var name="End_Complete_Compatible_Signature_High" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;MSB Value set by the application at the start of the complete and compatible block&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x456e6453"/>
                </v:var>
                <v:var name="End_Complete_Compatible_Signature_Low" 
                       type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;LSB Value set by the application at the start of the complete and compatible block&lt;/p&gt;
                                            &lt;p&gt;the default value is recommended by VCC&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x69676e61"/>
                </v:var>
                <v:var name="CompleteCompatibleFunction_Timeout" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="DEC"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Timeout value of the completecompatibleFunction&lt;/p&gt;
                                            &lt;p&gt;15ms by default&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="15"/>
                </v:var>
              </v:ctr>
              <v:lst name="Segments" type="MAP">
                <a:a name="COLUMNS">
                  <a:v>Memory</a:v>
                  <a:v>Access_Type</a:v>
                  <a:v>Reprog_Start_Address</a:v>
                  <a:v>Reprog_End_Address</a:v>
                  <a:v>Erase_Start_Address</a:v>
                  <a:v>Erase_End_Address</a:v>
                  <a:v>Partition_Type</a:v>
                  <a:v>Partition_ID</a:v>
                  <a:v>ValidityCheck</a:v>
                </a:a>
                <v:ctr name="Segments" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This container contains the description of the Segments of available memory to reprogram and the kind of memory used.&lt;/p&gt;
                                            &lt;p&gt;PLEASE NOTE THAT:&lt;/p&gt;
                                            &lt;p&gt;                  - ONLY ONE SEGMENT SHALL BE OF DEFINED FOR UPDATER PARTITION&lt;/p&gt;
                                            &lt;p&gt;                  - UNIQUE SEGMENT FOR UPDATER PARTITION SHALL REFER TO BLOCK DEFINED WITH INDEX 0&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <v:ref name="Memory" type="REFERENCE">
                    <a:a name="COLUMN_TITLE" value="Memory"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Reference to the memory which contains the segment.&lt;/p&gt;
                                                &lt;ul&gt;
                                                    &lt;li&gt;&lt;b&gt;FLASH&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;FLASH_EXT&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;EEPROM&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;RAM&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;SCRATCHPAD&lt;/b&gt;&lt;/li&gt;
                                                &lt;/ul&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:da name="REF">
                      <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/ReProgMemM/Memory</a:v>
                      <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Prog/Memory</a:v>
                    </a:da>
                  </v:ref>
                  <v:var name="Access_Type" type="ENUMERATION">
                    <a:a name="COLUMN_TITLE" value="Access_Type"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Define Authorized memory access types to this segment&lt;/p&gt;
                                                &lt;ul&gt;
                                                    &lt;li&gt;&lt;b&gt;READ: Only allow Read memory access&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;WRITE: Only allow Write and Erase memory access&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;READ_WRITE: Allow Read, Write and Erase memory access&lt;/b&gt;&lt;/li&gt;
                                                &lt;/ul&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="READ_WRITE"/>
                    <a:da name="INVALID" type="XPath" 
                          expr="((node:exists(as:modconf(&apos;ProgJLR&apos;))) and (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT= &apos;PBL&apos;)and not(. =&apos;READ&apos;) and          not((node:ref(../Memory)/Memory_Type) = &apos;RAM&apos;))" 
                          true="The PBL shall only be capable of writing data to RAM."/>
                    <a:da name="RANGE">
                      <a:v>READ</a:v>
                      <a:v>WRITE</a:v>
                      <a:v>READ_WRITE</a:v>
                    </a:da>
                  </v:var>
                  <v:var name="Reprog_Start_Address" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Reprog_Start_Address"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Start address of the segment in the memory.&lt;/p&gt;
                                                &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF]&lt;/p&gt;
                                                &lt;p&gt;Coded on 32 bits&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="INVALID" type="XPath" 
                          expr=". &lt; node:ref(../Memory)/Addr_Offset and                                             node:ref(../Memory)/Memory_Type =&apos;FLASH_EXT&apos;" 
                          true="the Offset configured shall be lower than the start address of an external FLASH segment"/>
                  </v:var>
                  <v:var name="Reprog_End_Address" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Reprog_End_Address"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;End address of the segment in the memory.&lt;/p&gt;
                                                &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF]&lt;/p&gt;
                                                &lt;p&gt;Coded on 32 bits&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  </v:var>
                  <v:var name="Erase_Start_Address" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Erase_Start_Address"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                        &lt;p&gt;Erasing start address of the segment in the memory.&lt;/p&gt;
                                        &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF]&lt;/p&gt;
                                        &lt;p&gt;Coded on 32 bits&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="INVALID" type="XPath" 
                          expr=". &lt; node:ref(../Memory)/Addr_Offset and                                         node:ref(../Memory)/Memory_Type =&apos;FLASH_EXT&apos;" 
                          true="the Offset configured shall be lower than the start address of an external FLASH segment"/>
                  </v:var>
                  <v:var name="Erase_End_Address" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Erase_End_Address"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                        &lt;p&gt;Erasing End address of the segment in the memory.&lt;/p&gt;
                                        &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF]&lt;/p&gt;
                                        &lt;p&gt;Coded on 32 bits&lt;/p&gt;
                                      &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  </v:var>
                  <v:var name="Partition_Type" type="STRING">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the partition type&lt;/p&gt;
                                            &lt;ul&gt;
                                                &lt;li&gt;Application partition&lt;/li&gt;
                                                &lt;li&gt;Calibration partition&lt;/li&gt;
                                                &lt;li&gt;BLUpdater/Application partition&lt;/li&gt;
                                                &lt;li&gt;BLUpdater/Calibration partition&lt;/li&gt;
                                                &lt;li&gt;BLUpdater partition&lt;/li&gt;
                                                &lt;li&gt;HSM partition&lt;/li&gt;
                                                &lt;li&gt;Protected calibration partition - will not be erased&lt;/li&gt;
                                                &lt;li&gt;Bootloader partition&lt;/li&gt;
                                                &lt;li&gt;Flash Routines partition (here will be the erase/write routines of the flash driver, this partition shall be configured to RAM)&lt;/li&gt;
                                                &lt;li&gt;Software Structure partition&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Partition Type"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="PROG_APPLICATION_PARTITION"/>
                    <a:da name="INVALID" type="XPath">
                      <a:tst 
                             expr="((.=&apos;PROG_FLASH_ROUTINES_PARTITION&apos;) and not(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))))" 
                             true="Flash Routines Partition is not supported for the current OEM."/>
                      <a:tst 
                             expr="((.=&apos;PROG_PSEUDO_FLASH_ROUTINES_PARTITION&apos;) and not(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))))" 
                             true="Pseudo Flash Routines Partition is not supported for the current OEM."/>
                      <a:tst 
                             expr="((.=&apos;PROG_PROT_CALIBRATION_PARTITION&apos;) and not(node:exists(as:modconf(&apos;ProgGM&apos;))))" 
                             true="Protected calibration is not supported for the current OEM."/>
                      <a:tst 
                             expr="count(text:grep(as:modconf(&apos;Prog&apos;)/Segments/*/Partition_Type, &apos;PROG_PROT_CALIBRATION_PARTITION&apos;)) &gt; 31" 
                             true="Only a maximum of 31 Protected Calibrations is allowed."/>
                      <a:tst 
                             expr="text:uniq(as:modconf(&apos;Prog&apos;)/Segments/*/Partition_Type, &apos;PROG_FLASH_ROUTINES_PARTITION&apos;)" 
                             false="Only one segment can be set to FLASH_ROUTINE partition."/>
                      <a:tst 
                             expr="text:uniq(as:modconf(&apos;Prog&apos;)/Segments/*/Partition_Type, &apos;PROG_PSEUDO_FLASH_ROUTINES_PARTITION&apos;)" 
                             false="Only one segment can be set to PSEUDO FLASH_ROUTINE partition."/>
                      <a:tst 
                             expr="((.=&apos;PROG_ESS_PARTITION&apos;) and not(node:exists(as:modconf(&apos;ProgVCC&apos;)) ))" 
                             true="Software structure is not supported for the current OEM."/>
                      <a:tst 
                             expr="(((.=&apos;PROG_BLU_APP_PARTITION&apos;) or (.=&apos;PROG_BLU_CAL_PARTITION&apos;) or (.=&apos;PROG_BLU_PARTITION&apos;))                                                  and not(node:exists(as:modconf(&apos;ProgVAG&apos;))) and not(node:exists(as:modconf(&apos;ProgOEMInd&apos;))))" 
                             true="Bootloader Updater is not supported for the current OEM."/>
                    </a:da>
                    <a:da name="RANGE">
                      <a:v>PROG_FLASH_ROUTINES_PARTITION</a:v>
                      <a:v>PROG_PSEUDO_FLASH_ROUTINES_PARTITION</a:v>
                      <a:v>PROG_APPLICATION_PARTITION</a:v>
                      <a:v>PROG_CALIBRATION_PARTITION</a:v>
                      <a:v>PROG_BLU_APP_PARTITION</a:v>
                      <a:v>PROG_BLU_CAL_PARTITION</a:v>
                      <a:v>PROG_BLU_PARTITION</a:v>
                      <a:v>PROG_PROT_CALIBRATION_PARTITION</a:v>
                      <a:v>PROG_ESS_PARTITION</a:v>
                      <a:v>PROG_HSM_PARTITION</a:v>
                      <a:v>PROG_RAM_PARTITION</a:v>
                      <a:v>PROG_APP1_PARTITION</a:v>
                      <a:v>PROG_CAL1_PARTITION</a:v>
                    </a:da>
                  </v:var>
                  <v:var name="StartSegment" type="INTEGER">
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                              &lt;p&gt;Define the First segment index for Logical block&lt;/p&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="StartSegment"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="0"/>
                  </v:var>
                  <v:var name="Protected_Partition_ID" type="INTEGER">
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the partition ID for protected segment&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Protected Partition ID"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_PROT_CALIBRATION_PARTITION&apos;"/>
                    <a:da name="INVALID" type="Range" expr="&gt;=0x2"/>
                  </v:var>
                  <v:var name="HSM_PartitionID" type="INTEGER">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the BootLoader HSM Partition ID&lt;/p&gt;
                                            &lt;p&gt;The Partition ID needs to be defined&lt;/p&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="HSM Partition ID"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="8"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_HSM_PARTITION&apos;"/>
                    <a:da name="INVALID" type="Range" expr="&gt;=0x2"/>
                  </v:var>
                  <v:var name="HSM_RAM_Buffer" type="INTEGER">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the BootLoader HSM Partition RAM buffer size&lt;/p&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="HSM Buffer Size"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="4000"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_HSM_PARTITION&apos;"/>
                  </v:var>
                  <v:var name="PROG_HSM_Timeout" type="INTEGER">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the BootLoader HSM TD response Timeout in ms&lt;/p&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="HSM TD Response Timeout"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="10"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_HSM_PARTITION&apos;"/>
                  </v:var>
                  <v:var name="ValidityCheck" type="BOOLEAN">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Check or not the status of this segment for the application validity check&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Validity Check"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="true"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)) or  node:exists(as:modconf(&apos;ProgJLR&apos;)))"/>
                    <a:da name="INVALID" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_FLASH_ROUTINES_PARTITION&apos; and .=&apos;true&apos;" 
                          true="Validity check cannot be performed for PROG_FLASH_ROUTINES_PARTITION."/>
                  </v:var>
                  <v:var name="SignatureVerification" type="BOOLEAN">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Enable this to perform Signature verification for this segment.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Verify Signature"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(((node:exists(as:modconf(&apos;ProgFCA&apos;)) and as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_Mid&apos;)) or (node:exists(as:modconf(&apos;ProgJLR&apos;)) and (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;OneLevelBL&apos;)))"/>
                    <a:da name="INVALID" type="XPath" 
                          expr="../Partition_Type = &apos;PROG_FLASH_ROUTINES_PARTITION&apos; and .=&apos;true&apos;" 
                          true="Signature verification cannot be performed for PROG_FLASH_ROUTINES_PARTITION."/>
                  </v:var>
                  <v:ctr name="SecureBoot" type="IDENTIFIABLE">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                    This container contains all configurations for Secure/Authenticated bootloader features for the Implementation 30 Bootloader, and for the other bootloader variants please check under (Blocks)-tab.
                                    Configuration can be done only if Secure Boot feature or Authenticated Boot feature is activated under BM.
                                    &lt;/html&gt;</a:v>
                    </a:a>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(not((as:modconf(&apos;BM&apos;)/Security/SecureBoot/SECURE_AUTHENTICATED_BOOT = &apos;OFF&apos;) and (as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;false&apos;)))                                  and ((node:exists(as:modconf(&apos;ProgFCA&apos;)) and as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_Mid&apos;)                                 or node:exists(as:modconf(&apos;ProgJLR&apos;))                                 or node:exists(as:modconf(&apos;ProgFord&apos;))or (node:exists(as:modconf(&apos;ProgOEMInd&apos;)) and ../../../OemInd/Erase_Mode != &apos;LogicalBlock&apos;))"/>
                    <v:var name="Verified_For_Secure_Boot" type="ENUMERATION">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify if the Block shall be verified when Secure Boot is activated.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Verified in Secure Boot"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="Block won&apos;t be verified"/>
                      <a:da name="RANGE">
                        <a:v>Block will be verified</a:v>
                        <a:v>Block won&apos;t be verified</a:v>
                      </a:da>
                    </v:var>
                    <v:var name="Blocker_for_Software_execution" 
                           type="ENUMERATION">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify if the Block will prevent the corresponding software to be executed in case of Secure Boot verification failure.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Blocker for Software execution"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" 
                            value="Won&apos;t block software execution"/>
                      <a:da name="RANGE">
                        <a:v>Will block software execution</a:v>
                        <a:v>Won&apos;t block software execution</a:v>
                      </a:da>
                    </v:var>
                    <v:var name="Start_Address_Secure_Boot_Verification" 
                           type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="HEX"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify the Start Address of the area on which the Secure Boot verification will be done.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Start Address for the Secure Boot Verification"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="INVALID" type="Range" expr="&lt;=4294967295"/>
                    </v:var>
                    <v:var name="Length_Secure_Boot_Verification" 
                           type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="HEX"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify the length of the area on which the Secure Boot verification will be done.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Length of the Block area for the Secure Boot Verification"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="INVALID" type="Range" expr="&lt;=4294967295"/>
                    </v:var>
                  </v:ctr>
                </v:ctr>
              </v:lst>
              <v:lst name="Blocks" type="MAP">
                <a:a name="COLUMNS">
                  <a:v>First_Segment</a:v>
                  <a:v>Segment_Number</a:v>
                  <a:v>Block_Programming_Counter_Max</a:v>
                  <a:v>Block_Identifier</a:v>
                  <a:v>Crc_Address</a:v>
                  <a:v>Downgrade_Protected</a:v>
                </a:a>
                <a:da name="MAX" value="250"/>
                <v:ctr name="Blocks" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This container contains the description of the blocks used to request the erasing.&lt;/p&gt;
                                            &lt;p&gt;PLEASE NOTE THAT BLOCK CONTAINING BOOTLOADER SEGMENT SHALL HAVE INDEX 0.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <v:ref name="First_Segment" type="REFERENCE">
                    <a:a name="COLUMN_TITLE" value="First Segment"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Reference to the first segment of the block&lt;/p&gt;
                                           &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:da name="REF" 
                          value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Prog/Segments"/>
                  </v:ref>
                  <v:var name="Segment_Number" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Number of segments"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Number of Segment in the block.&lt;/p&gt;
                                            &lt;p&gt;These represent the number of segment in the block based on the first configured segment&lt;/p&gt;
                                            &lt;p&gt;(segments of the same block shall be consecutive in segments configuration)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="INVALID" type="XPath">
                      <a:tst 
                             expr=". &gt; 1 and as:modconf(&apos;Prog&apos;)/VAG/Request_Download_Address_Mode=&apos;Download by logical block&apos; and node:exists(as:modconf(&apos;ProgVAG&apos;))" 
                             true="Only one segment allowed per block when Download by logical block is used as the Request Download Addressing Mode."/>
                      <a:tst expr=". &lt;= count(as:modconf(&apos;Prog&apos;)/Segments/*)" 
                             false="This block uses more segments then the total number of defined segments."/>
                      <a:tst expr=". &gt;= 1" 
                             false="This block should use at least one segment."/>
                      <a:tst expr="var:set(&apos;myBlockIndex&apos;,num:i(../@index+1))" 
                             false="Cannot get the index of current node!"/>
                      <a:tst 
                             expr=". + node:ref(as:modconf(&apos;Prog&apos;)/Blocks/*[num:i($myBlockIndex)]/First_Segment)/@index &lt;= count(as:modconf(&apos;Prog&apos;)/Segments/*)" 
                             false="Invalid number of segments. Decrement the &apos;Number of Segments&apos; or choose a &apos;First Segment&apos; with a lower index."/>
                    </a:da>
                  </v:var>
                  <v:var name="Block_Programming_Counter_Max" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Programming counter Max"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Maximum number of allowed to program the block.&lt;/p&gt;
                                            &lt;p&gt;This represent the maximum number of times allowed to program the block&lt;/p&gt;
                                            &lt;p&gt;(If the counter is set to 0 then there will be no limit for programming)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or node:exists(as:modconf(&apos;ProgPSA&apos;)) or ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)))"/>
                  </v:var>
                  <v:var name="Block_Identifier" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Block Identifier"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Identifier of the block.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;)) or node:exists(as:modconf(&apos;ProgDAG&apos;)) or                                         node:exists(as:modconf(&apos;ProgPSA&apos;)) or ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)))"/>
                    <a:da name="INVALID" type="Multi">
                      <mt:range 
                                false="Value of block identifier must be &lt;=65534 (can be coded on two bytes maxi)." 
                                expr="&lt;=65534"/>
                      <mt:xpath>
                        <mt:tst 
                                true="The following identifiers 0xFF is reserved." 
                                expr=". = 255"/>
                        <mt:tst 
                                true="The following identifiers 0xFFFF is reserved." 
                                expr=". = 65535"/>
                        <mt:tst false="Index of block has to be unique." 
                                expr="text:uniq(as:modconf(&apos;Prog&apos;)/Blocks/*/Block_Identifier, .)"/>
                      </mt:xpath>
                    </a:da>
                  </v:var>
                  <v:var name="Crc_Address" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="CRC Address"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;The address of the CRC in the memory block.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="CRC Address"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(node:exists(as:modconf(&apos;ProgFCA&apos;)) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;) and (as:modconf(&apos;Prog&apos;)/DownloadVerification/FCA_Reprogramming = &apos;Standard&apos;))"/>
                  </v:var>
                  <v:var name="Downgrade_Protected" type="BOOLEAN">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                              &lt;p&gt;Specify if the logical block needs to be downgrade protected.
                                              &lt;ul&gt;
                                                &lt;li&gt;Case tick: Downgrade protection applies on the corresponding block&lt;/li&gt;
                                                &lt;li&gt;Case untick: Downgrade protection does not apply on the corresponding block&lt;/li&gt;
                                              &lt;/ul&gt;
                                              &lt;/p&gt;
                                          &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Downgrade Protected"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;ProgVAG&apos;)) and (as:modconf(&apos;Prog&apos;)/VAG/Downgrade_Protection=&apos;true&apos;)"/>
                    <a:da name="INVALID" type="XPath" 
                          expr="node:ref(as:modconf(&apos;Prog&apos;)/VAG/PFT_Block_Id)/Downgrade_Protected =&apos;true&apos;" 
                          true="The pseudo flash driver block shall be excluded from downgrade protection verification."/>
                  </v:var>
                  <v:ctr name="SecureBoot" type="IDENTIFIABLE">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                    This container contains all configurations for Secure/Authenticated bootloader features, for all the supported Bootloaders other than Implementation 30, and for the Implementation 30 bootloader please check under (Segments)-tab.
                                    Configuration can be done only if Secure Boot feature or Authenticated Boot feature is activated under BM.
                                    &lt;/html&gt;</a:v>
                    </a:a>
                    <a:da name="ENABLE" type="XPath" 
                          expr="(not((as:modconf(&apos;BM&apos;)/Security/SecureBoot/SECURE_AUTHENTICATED_BOOT = &apos;OFF&apos;) and (as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;false&apos;)))                                                 and (node:exists(as:modconf(&apos;ProgDAG&apos;))                                                 or (node:exists(as:modconf(&apos;ProgFCA&apos;))                                                 and as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)                                                or (node:exists(as:modconf(&apos;ProgOEMInd&apos;)) and ../../../OemInd/Erase_Mode = &apos;LogicalBlock&apos;))"/>
                    <v:var name="Verified_For_Secure_Boot" type="ENUMERATION">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify if the Block shall be verified when Secure Boot is activated.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Verified in Secure Boot"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="Block won&apos;t be verified"/>
                      <a:da name="RANGE">
                        <a:v>Block will be verified</a:v>
                        <a:v>Block won&apos;t be verified</a:v>
                      </a:da>
                    </v:var>
                    <v:var name="Blocker_for_Software_execution" 
                           type="ENUMERATION">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify if the Block will prevent the corresponding software to be executed in case of Secure Boot verification failure.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Blocker for Software execution"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" 
                            value="Won&apos;t block software execution"/>
                      <a:da name="RANGE">
                        <a:v>Will block software execution</a:v>
                        <a:v>Won&apos;t block software execution</a:v>
                      </a:da>
                    </v:var>
                    <v:var name="Start_Address_Secure_Boot_Verification" 
                           type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="HEX"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify the Start Address of the area on which the Secure Boot verification will be done.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Start Address for the Secure Boot Verification"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="INVALID" type="Range" expr="&lt;=4294967295"/>
                    </v:var>
                    <v:var name="Length_Secure_Boot_Verification" 
                           type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="HEX"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                        &lt;p&gt;Specify the length of the area on which the Secure Boot verification will be done.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Length of the Block area for the Secure Boot Verification"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="INVALID" type="Range" expr="&lt;=4294967295"/>
                    </v:var>
                  </v:ctr>
                </v:ctr>
              </v:lst>
              <v:lst name="Memory" type="MAP">
                <a:a name="COLUMNS">
                  <a:v>Memory_Type</a:v>
                  <a:v>Memory_Mode</a:v>
                  <a:v>Min_Value_To_Write</a:v>
                  <a:v>Addr_Offset</a:v>
                  <a:v>Erase_Value</a:v>
                </a:a>
                <v:ctr name="Memory" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This container contains the description of the memories used by the bootloader.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <v:var name="Memory_Type" type="ENUMERATION">
                    <a:a name="COLUMN_TITLE" value="Memory_Type"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Type of the memory.&lt;/p&gt;
                                                &lt;ul&gt;
                                                    &lt;li&gt;&lt;b&gt;FLASH&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;FLASH_EXT&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;RAM&lt;/b&gt;&lt;/li&gt;
                                                    &lt;li&gt;&lt;b&gt;CUSTOM&lt;/b&gt;&lt;/li&gt;
                                                &lt;/ul&gt;
                                                &lt;p&gt;NOTE: Only one memory of each type can be defined!&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Memory Type"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;Flash&apos;))                                       or ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and                                         (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;))                                        or ((node:exists(as:modconf(&apos;ProgFord&apos;))) and                                        (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;))                                        or ((node:exists(as:modconf(&apos;ProgJLR&apos;))) and                                        (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;PBL&apos;)) "/>
                    <a:da name="INVALID" type="XPath" 
                          expr="text:uniq(../../../Memory/*/Memory_Type, .)" 
                          false="FLASH Type has to be unique."/>
                    <a:da name="RANGE">
                      <a:v>FLASH</a:v>
                      <a:v>FLASH_EXT</a:v>
                      <a:v>RAM</a:v>
                      <a:v>CUSTOM</a:v>
                    </a:da>
                  </v:var>
                  <v:var name="Memory_Mode" type="STRING">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;This entry allows to specify if the memory is access synchronously or asynchronously.&lt;/p&gt;
                                                &lt;p&gt;Please select between :&lt;/p&gt;
                                                &lt;ul&gt;
                                                  &lt;li&gt;asynchronous&lt;/li&gt;
                                                  &lt;li&gt;synchronous&lt;/li&gt;
                                                &lt;/ul&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Memory Mode"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="synchronous"/>
                    <a:da name="EDITABLE" type="XPath" 
                          expr="../Memory_Type != &apos;RAM&apos;"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;Flash&apos;))                              or ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and                              (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;))                                        or ((node:exists(as:modconf(&apos;ProgFord&apos;))) and                                        (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;))                              or ((node:exists(as:modconf(&apos;ProgJLR&apos;))) and                              (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;PBL&apos;)) "/>
                    <a:da name="RANGE">
                      <a:v>asynchronous</a:v>
                      <a:v>synchronous</a:v>
                    </a:da>
                  </v:var>
                  <v:var name="Min_Value_To_Write" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Min_Value_To_Write"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Define the minimum size the memory driver could write at a time.&lt;/p&gt;
                                                &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF].&lt;/p&gt;
                                                &lt;p&gt;Coded on 32 bits.&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Minimum value to write"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="8"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;Flash&apos;))                              or ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and                              (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;))                                        or ((node:exists(as:modconf(&apos;ProgFord&apos;))) and                                        (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;))                              or ((node:exists(as:modconf(&apos;ProgJLR&apos;))) and                              (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;PBL&apos;)) "/>
                    <a:da name="INVALID" type="Range" expr="&gt;=8"/>
                  </v:var>
                  <v:var name="Addr_Offset" type="INTEGER">
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                                &lt;p&gt;Define the start address offset for the memory.&lt;/p&gt;
                                                &lt;p&gt;In the case of the EXTERNAL FLASH and CUSTOM this offset is SUBSTRACTED from the received address.&lt;/p&gt;
                                                &lt;p&gt;In the case of the RAM and INTERNAL FLASH this offset is ADDED to the received address.&lt;/p&gt;
                                                &lt;p&gt;Range: [0x00000000 ; 0xFFFFFFFF].&lt;/p&gt;
                                                &lt;p&gt;Coded on 32 bits.&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Address Offset"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="0"/>
                    <a:da name="EDITABLE" type="XPath" 
                          expr="../Memory_Type != &apos;RAM&apos;"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;Flash&apos;))                              or ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and                              (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;))                                       or ((node:exists(as:modconf(&apos;ProgFord&apos;))) and                                        (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;))                              or ((node:exists(as:modconf(&apos;ProgJLR&apos;))) and                              (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;PBL&apos;)) "/>
                  </v:var>
                  <v:var name="Erase_Value" type="INTEGER">
                    <a:a name="COLUMN_TITLE" value="Erase_Value"/>
                    <a:a name="DEFAULT_RADIX" value="HEX"/>
                    <a:a name="DESC">
                      <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the value to set for each byte when the memory is erased&lt;/p&gt;
                                            &lt;p&gt;Example: 0xFFu will affect the value 0xFF to every byte of the memory when erasure.&lt;/p&gt;
                                            &lt;p&gt;Range: [0x00 ; 0xFF].&lt;/p&gt;
                                            &lt;p&gt;Coded on 8 bits.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                    </a:a>
                    <a:a name="LABEL" value="Erase Value"/>
                    <a:a name="ORIGIN" value="EB"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:da name="DEFAULT" value="255"/>
                    <a:da name="EDITABLE" type="XPath" 
                          expr="../Memory_Type != &apos;RAM&apos;"/>
                    <a:da name="ENABLE" type="XPath" 
                          expr="node:exists(as:modconf(&apos;Flash&apos;))                          or ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and                           (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;PBL&apos;))                                   or ((node:exists(as:modconf(&apos;ProgFord&apos;))) and                                    (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;PBL&apos;))                          or ((node:exists(as:modconf(&apos;ProgJLR&apos;))) and                           (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;PBL&apos;)) "/>
                    <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=0"/>
                      <a:tst expr="&lt;=255"/>
                    </a:da>
                  </v:var>
                </v:ctr>
              </v:lst>
              <v:ctr name="GM" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the GM specific configuration&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="GM"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgGM&apos;))"/>
                <v:ctr name="ProgCsmReferences" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                             Contains references to Csm configuration identifiers.&lt;br/&gt;
                                          &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ProgCsmReferences"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;Csm&apos;))"/>
                  <v:ctr name="SignatureVerification" type="IDENTIFIABLE">
                    <v:ref name="ProgCsmSignatureVerifyConfigId" 
                           type="CHOICE-REFERENCE">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                             &lt;p&gt;Reference a &lt;em&gt;CsmSignatureVerify&lt;/em&gt;&lt;/p&gt;

                                             &lt;p&gt;Dependencies:&lt;/p&gt;
                                             &lt;ul&gt;
                                                &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                             &lt;/ul&gt;
                                          &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="LABEL" value="ProgCsmSignatureVerifyConfigId"/>
                      <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                      <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                            false="Invalid reference."/>
                      <a:da name="REF">
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmSignatureVerify/CsmSignatureVerifyConfig</a:v>
                      </a:da>
                    </v:ref>
                    <v:var name="BS_size" type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="DEC"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                           &lt;p&gt;This feature shall allow the Integrator to decide the size of the data to be processed 
                                                           in a single Asynchronous Crypto main function call.&lt;/p&gt;
                                                           &lt;p&gt;it allows to reduce the time blocked by the CryptoMainfunction in a single main 
                                                           function call.&lt;/p&gt;
                                                           &lt;p&gt;This feature can be enabled by entering any value other than 0(in bytes) in this field. 
                                                           Setting it to 0 shall allow the Bootlaoder to pass the entire available data for processing
                                                           in a single CryptoMainfunction call.&lt;/p&gt;
                                                           &lt;p&gt;Note:&lt;/p&gt;
                                                           &lt;p&gt;1. This field is only enabled for the integration of ASR Crypto stack version 4.3 or higher.&lt;/p&gt;
                                                           &lt;p&gt;2. Enabling this feature (by setting a very small size) shall increase the time for verification significantly, 
                                                           integrator shall decide the value to be set.&lt;/p&gt;
                                                           &lt;p&gt;3. It is recommended to set this value to a maximum value that is sufficient to 
                                                           not to cause timeouts in the system. &lt;/p&gt;
                                                           &lt;p&gt;4. If this feature is enabled together with verification on fly, the minimum value of Verification_Buffer_size 
                                                           and BS_size shall be effectively selected as the processing data size.&lt;/p&gt;
                                   &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Data size for Block Slicing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))"/>
                    </v:var>
                    <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                           &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                                           &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                                           is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                       &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Allow cancellation of any ongoing Crypto job"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="Allow2SetCryptoKey" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                           &lt;p&gt;This will allow the integrator to pass the desired key and its elements at the start of the Crypto operation. &lt;/p&gt;
                                                           &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                       &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Allow to fetch the stored Key"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="Allow2CustomCsmStartPreprocess" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                           &lt;p&gt;This will allow the integrator to perform the encoding (eg. Base64, DER etc.) on the Key stored at the host side at the start of the Crypto operation&lt;/p&gt;
                                                           &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                           &lt;p&gt;Note: The key encoding shall be performed only if the Crypto driver expects the key to be encoded in an expected format.&lt;/p&gt;
                                                       &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Custom CSM start pre-processing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="AllowStreamStart" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
	                        &lt;p&gt;This parameter shall be enabled if the Signature Start operation takes more than one cycle of CryptoMainFunction execution.&lt;/p&gt;
	                        &lt;p&gt;Note: &lt;/p&gt;
	                        &lt;p&gt;1. This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
	                        &lt;p&gt;2. This shall be enabled only if the crypto engine supports the StreamStart feature.&lt;/p&gt;
	                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Enable StreamStart mode"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="SignFinSendFRP" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                          &lt;p&gt;This parameter if enabled shall provide a force response Pending (NRC78) at the beginning of the Signature Finish operation.&lt;/p&gt;
                                                          &lt;p&gt;This parameter is introduced to avoid casuing P2 timeouts at client side when the Crypto driver main function call 
															for the Crypto Finish operation blocks the other Boot functions longer than the modules manage period.&lt;/p&gt;
                                                      &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Send NRC78 for Signature Finish"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                  </v:ctr>
                  <v:ctr name="HashVerification" type="IDENTIFIABLE">
                    <v:ref name="ProgCsmHashConfigId" type="CHOICE-REFERENCE">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                             &lt;p&gt;Reference a &lt;em&gt;CsmHash&lt;/em&gt;&lt;/p&gt;

                                             &lt;p&gt;Dependencies:&lt;/p&gt;
                                             &lt;ul&gt;
                                                &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                             &lt;/ul&gt;
                                          &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="LABEL" value="ProgCsmHashConfigId"/>
                      <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                      <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                            false="Invalid reference."/>
                      <a:da name="REF">
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmHash/CsmHashConfig</a:v>
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                      </a:da>
                    </v:ref>
                    <v:var name="BS_size" type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="DEC"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                          &lt;p&gt;This feature shall allow the Integrator to decide the size of the data to be processed 
                                                          in a single Asynchronous Crypto main function call.&lt;/p&gt;
                                                          &lt;p&gt;it allows to reduce the time blocked by the CryptoMainfunction in a single main 
                                                          function call.&lt;/p&gt;
                                                          &lt;p&gt;This feature can be enabled by entering any value other than 0(in bytes) in this field. 
                                                          Setting it to 0 shall allow the Bootlaoder to pass the entire available data for processing
                                                          in a single CryptoMainfunction call.&lt;/p&gt;
                                                          &lt;p&gt;Note:&lt;/p&gt;
                                                          &lt;p&gt;1. This field is only enabled for the integration of ASR Crypto stack version 4.3 or higher.&lt;/p&gt;
                                                          &lt;p&gt;2. Enabling this feature (by setting a very small size) shall increase the time for verification significantly.
                                                          The integrator shall decide the value to be set.&lt;/p&gt;
                                                          &lt;p&gt;3. It is recommended to set this value to a maximum value that is sufficient to 
                                                          not to cause timeouts in the system. &lt;/p&gt;
                                                          &lt;p&gt;4. If this feature is enabled together with verification on fly, the minimum value of Verification_Buffer_size 
                                                          and BS_size shall be effectively selected as the processing data size.&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Data size for Block Slicing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                    <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                              &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                                              &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                                              is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                          &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Allow cancellation of any ongoing Crypto job"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                    <v:var name="HashFinSendFRP" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                            &lt;p&gt;This parameter if enabled shall provide a force response Pending (NRC78) at the beginning of the Hash Finish operation.&lt;/p&gt;
                                                            &lt;p&gt;This parameter is introduced to avoid casuing P2 timeouts at client side when the Crypto driver main function call 
															for the Crypto Finish operation blocks the other Boot functions longer than the modules manage period.&lt;/p&gt;
                                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Send NRC78 for Hash Finish"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                  </v:ctr>
                </v:ctr>
                <v:var name="PEC_Enable" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define if the PEC is enable&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="PEC Enable"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
                <v:var name="MAX_PARTITION" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the maximum partition supported by the ECU&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Maximum Partition"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="2"/>
                </v:var>
                <v:var name="MAX_REGION_ALLOWED" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the maximum number of region that is allowed in the software&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Maximum Number of regions"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="2"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=2"/>
                    <a:tst expr="&lt;255"/>
                  </a:da>
                </v:var>
                <v:var name="External_Flash_Offset" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                        &lt;p&gt; External flash offset can be provide &lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="External Flash Offset address"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x00000000"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgGM&apos;)))"/>
                </v:var>
                <v:var name="Security_Access_Seed_Length" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the length of the seed to be able to return the correct size&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Length of the security seed"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="31"/>
                </v:var>
                <v:var name="Application_InfoHeader_Size" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                        &lt;p&gt; Application Info Header size provide &lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Application Info Header Size"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x100"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgGM&apos;)))"/>
                </v:var>
                <v:var name="ECU_ADDR" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the ECU address that will identify the ECU to then reprogramming tool&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Ecu Address"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0xEB"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;255"/>
                  </a:da>
                </v:var>
                <v:var name="PSI_Programmed" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define PSI value when it is programmed&lt;/p&gt;
                                          &lt;p&gt;The value shall be enter as hexadecimal value without the 0x&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Programmed PSI Value"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="A555A5AA5AAA5A55"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="string-length(.) = 16" 
                           false="Value entered shall have 16 character"/>
                    <a:tst expr="contains(.,&apos;0x&apos;)" 
                           true="The &apos;0x&apos; shall not be set in the PSI value"/>
                  </a:da>
                </v:var>
                <v:var name="PSI_Revoked" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define PSI value when it is revoked&lt;/p&gt;
                                          &lt;p&gt;The value shall be enter as hexadecimal value without the 0x&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Revoked PSI Value"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="505245564F4B4544"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="string-length(.) = 16" 
                           false="Value entered shall have 16 character"/>
                    <a:tst expr="contains(.,&apos;0x&apos;)" 
                           true="The &apos;0x&apos; shall not be set in the PSI value"/>
                  </a:da>
                </v:var>
                <v:var name="BCID" type="INTEGER">
                  <a:a name="COLUMN_TITLE" value="BCID value"/>
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                        &lt;p&gt;This value shall contains the Bootloader Compatibility Identifier (BCID)&lt;/p&gt;
                                        &lt;p&gt;This value is two bytes long&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="60395"/>
                  <a:da name="INVALID" type="Range" expr="&lt;=65535"/>
                </v:var>
                <v:var name="EcuId_Source" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This entry allows to specify if the ECU ID is coming from Tresos Configuration or from User Callback.
                                            If the User Callback option is used, the integrator shall implement the callback that will provide the ECU Id.&lt;/p&gt;
                                            &lt;p&gt;Please select between :&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Tresos Configuration&lt;/li&gt;
                                              &lt;li&gt;User Callback&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ECU ID Source"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Tresos_Configuration"/>
                  <a:da name="RANGE">
                    <a:v>Tresos_Configuration</a:v>
                    <a:v>User_Callback</a:v>
                  </a:da>
                </v:var>
                <v:var name="ECU_ID" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the ECU ID&lt;/p&gt;
                                          &lt;p&gt;The value shall be enter as hexadecimal value without the 0x&lt;/p&gt;
                                          &lt;p&gt;the parameter shall be 16 bytes long&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ECU ID"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="00000000000000000000000000000000"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="../EcuId_Source = &apos;Tresos_Configuration&apos;"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="string-length(.) = 32" 
                        false="Value entered shall have 32 character"/>
                </v:var>
                <v:var name="Subject_Name" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the ECU subject name&lt;/p&gt;
                                          &lt;p&gt;The value shall be enter as hexadecimal value without the 0x&lt;/p&gt;
                                          &lt;p&gt;the parameter shall be 16 bytes long&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ECU Subject Name"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="00112233445566778899001122334455"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="string-length(.) = 32" 
                        false="Value entered shall have 32 character"/>
                </v:var>
                <v:var name="ECU_Name" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the ECU name&lt;/p&gt;
                                          &lt;p&gt;The name shall be set as a string with exactly 8 characters (space can be used)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ECU Name"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="GM BOOT"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="string-length(.) &lt;= 8" 
                        false="Value entered shall have maximum 8 characters"/>
                </v:var>
                <v:var name="BOOT_Part_Number" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the BootLoader Part Number&lt;/p&gt;
                                          &lt;p&gt;The value shall be entered as hexadecimal value without the 0x&lt;/p&gt;
                                          &lt;p&gt;the parameter shall be 4 bytes long&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="BootLoader Part Number"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="00112233"/>
                  <a:da name="INVALID" type="XPath" expr="string-length(.) = 8" 
                        false="Value entered shall have 8 characters"/>
                </v:var>
                <v:var name="BOOT_DLS" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Define the BootLoader DLS&lt;/p&gt;
                                          &lt;p&gt;The name shall be set as a string with exactly 2 characters (space cannot be used)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="BootLoader DLS"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="AB"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="string-length(.) &lt;= 2" 
                        false="Value entered shall have maximum 2 characters"/>
                </v:var>
              </v:ctr>
              <v:ctr name="NRC78_Transmission" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                             Contains configuration for the NRC78 transmission before SecurityAccess.&lt;br/&gt;
                                          &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="LABEL" value="NRC78_Transmission"/>
                <a:a name="TAB" value="Security Access"/>
                <v:var name="Transmit_Nrc78_On_SecurityAccess" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Specify if an NRC78 response shall be sent before starting the Security Access.&lt;/p&gt;
                                          &lt;ul&gt;
                                            &lt;li&gt;Case untick: NRC78 will not be sent&lt;/li&gt;
                                          &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
              </v:ctr>
              <v:ctr name="Security" type="IDENTIFIABLE">
                <a:a name="TAB" value="SecureBoot"/>
                <v:var name="Secure_Checksum_computation" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      It allows the computation and writing of the checksum (Hash, MAC...) of logical blocks of Application
                                      used when Secure Boot or Authenticated Boot is activated.
                                      The verification of the checksum computed is activated when the parameter SECURE_AUTHENTICATED_BOOT
                                      is set either to Secure or to Authenticated in BM plugin.
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Checksum computation"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="((as:modconf(&apos;BM&apos;)/Security/SecureBoot/SECURE_AUTHENTICATED_BOOT=&apos;OFF&apos;) and                                       (node:exists(as:modconf(&apos;ProgDAG&apos;)) or           node:exists(as:modconf(&apos;ProgJLR&apos;)) or                                       (node:exists(as:modconf(&apos;ProgFCA&apos;))))) or                                                                             ((node:exists(as:modconf(&apos;ProgVCC&apos;))) and            (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;SBL&apos;)) or        ((node:exists(as:modconf(&apos;ProgFord&apos;))) and            (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;))"/>
                </v:var>
                <v:var name="CHECKSUM_LENGTH" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          Size of the checksum for Authenticated / Secure Boot feature in Bytes
                                       &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Checksum length"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="16"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;true&apos;"/>
                </v:var>
                <v:ref name="ProgCsmSecureConfigId" type="CHOICE-REFERENCE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                         &lt;p&gt;Reference a &lt;em&gt;CsmHash&lt;/em&gt; or &lt;em&gt;CsmMacGenerate&lt;/em&gt; for the Secure Boot checksum generation&lt;/p&gt;

                                         &lt;p&gt;Dependencies:&lt;/p&gt;
                                         &lt;ul&gt;
                                            &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                         &lt;/ul&gt;

                                         &lt;p&gt;This field is disabled if HSM is used.&lt;/p&gt;
                                      &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="ProgCsmSecureConfigId"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(((as:modconf(&apos;BM&apos;)/Security/SecureBoot/SECURE_AUTHENTICATED_BOOT != &apos;OFF&apos;) or (as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;true&apos;))                                              and (as:modconf(&apos;BM&apos;)/Security/SecureBoot/BMSecureBootWithHsm = &apos;false&apos;)                                              and (node:exists(as:modconf(&apos;ProgDAG&apos;))                                              or node:exists(as:modconf(&apos;ProgJLR&apos;))                                              or node:exists(as:modconf(&apos;ProgOEMInd&apos;))                                              or (node:exists(as:modconf(&apos;ProgFCA&apos;)) and as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;)                                              or (node:exists(as:modconf(&apos;ProgFCA&apos;)) and as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_Mid&apos;)))                                              or ((as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;true&apos;) and (node:exists(as:modconf(&apos;ProgVCC&apos;))) and (as:modconf(&apos;ProgVCC&apos;)/General/PROG_VCC_VARIANT=&apos;SBL&apos;))           or ((as:modconf(&apos;Prog&apos;)/Security/Secure_Checksum_computation = &apos;true&apos;) and (node:exists(as:modconf(&apos;ProgFord&apos;))) and (as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;))"/>
                  <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                        false="Invalid reference."/>
                  <a:da name="REF">
                    <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                    <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmHash/CsmHashConfig</a:v>
                    <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmMacGenerate/CsmMacGenerateConfig</a:v>
                  </a:da>
                </v:ref>
                <v:var name="Submit_signature_request" type="STRING">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                      It allows to select between two type of Submit Signature :
                                             &lt;ul&gt;
                                                &lt;li&gt;With Address : The Routine control contains two parameters, the first identifies which software component the signature 
                                                refers to by nominally being the start address of the hash table for the object in the ECU memory,the second parameter is the signature.&lt;/li&gt;
                                                &lt;li&gt;Without Address : The Routine control contains only one parameter which is the signature.&lt;/li&gt;
                                             &lt;/ul&gt;
                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Submit Signature Request"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="With Address"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="((node:exists(as:modconf(&apos;ProgJLR&apos;))) and ((as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;SBL&apos;) or (as:modconf(&apos;ProgJLR&apos;)/General/PROG_JLR_VARIANT=&apos;OneLevelBL&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>With Address</a:v>
                    <a:v>Without Address</a:v>
                  </a:da>
                </v:var>
                <v:var name="BS_size" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="DEC"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;This feature shall allow the Integrator to decide the size of the data to be processed 
                                            in a single Asynchronous Crypto main function call.&lt;/p&gt;
                                            &lt;p&gt;it allows to reduce the time blocked by the CryptoMainfunction in a single main 
                                            function call.&lt;/p&gt;
                                            &lt;p&gt;This feature can be enabled by entering any value other than 0(in bytes) in this field. 
                                            Setting it to 0 shall allow the Bootlaoder to pass the entire available data for processing
                                            in a single CryptoMainfunction call.&lt;/p&gt;
                                            &lt;p&gt;Note:&lt;/p&gt;
                                            &lt;p&gt;1. This field is only enabled for the integration of ASR Crypto stack version 4.3 or higher.&lt;/p&gt;
                                            &lt;p&gt;2. Enabling this feature (by setting a very small size) shall increase the time for verification significantly, 
                                            integrator shall decide the value to be set.&lt;/p&gt;
                                            &lt;p&gt;3. It is recommended to set this value to a maximum value that is sufficient to 
                                            not to cause timeouts in the system. &lt;/p&gt;
                                            
                                &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Data size for Block Slicing"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSecureConfigId)"/>
                </v:var>
                <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                                        is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Allow cancellation of any ongoing Crypto job"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmSecureConfigId)"/>
                </v:var>
                <v:var name="Allow2SetCryptoKey" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;This will allow the integrator to pass the desired key and its elements at the start of the Crypto operation. &lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Allow to fetch the stored Key"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSecureConfigId)"/>
                </v:var>
                <v:var name="Allow2CustomCsmStartPreprocess" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;This will allow the integrator to perform the encoding (eg. Base64, DER etc.) on the Key stored at the host side at the start of the Crypto operation&lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                        &lt;p&gt;Note: The key encoding shall be performed only if the Crypto driver expects the key to be encoded in an expected format.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Custom CSM start pre-processing"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSecureConfigId)"/>
                </v:var>
                <v:ctr name="ProgCsmReferences" type="IDENTIFIABLE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                             Contains references to Csm configuration identifiers.&lt;br/&gt;
                                          &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="ProgCsmReferences"/>
                  <a:a name="TAB" value="DownloadVerification"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;Csm&apos;)) and                                             (node:exists(as:modconf(&apos;ProgDAG&apos;)) or                                             node:exists(as:modconf(&apos;ProgVAG&apos;)) or                                             node:exists(as:modconf(&apos;ProgJLR&apos;)) or                                             node:exists(as:modconf(&apos;ProgVCC&apos;)) or                                             node:exists(as:modconf(&apos;ProgFord&apos;)) or                                                                                        node:exists(as:modconf(&apos;ProgOEMInd&apos;)) or                                             node:exists(as:modconf(&apos;ProgFCA&apos;))) "/>
                  <v:ctr name="SignatureVerification" type="IDENTIFIABLE">
                    <v:ref name="ProgCsmSignatureVerifyConfigId" 
                           type="CHOICE-REFERENCE">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                             &lt;p&gt;Reference a &lt;em&gt;CsmSignatureVerificationID&lt;/em&gt;&lt;/p&gt;
                                             &lt;p&gt;Specify which csm config Id shall be used for Signature Verification.&lt;/p&gt;
                                             &lt;p&gt;When the signature verification is used during the Download procedure(Erase, RequestDownload, CheckMemory).&lt;/p&gt;
                                             &lt;p&gt;An appropriate csm signature verification configuration should be referenced.&lt;/p&gt;

                                             &lt;p&gt;Dependencies:&lt;/p&gt;
                                             &lt;ul&gt;
                                                &lt;li&gt;Cryptographic libraries shall be present&lt;/li&gt;
                                             &lt;/ul&gt;
                                          &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v class="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="LABEL" value="ProgCsmSignatureVerifyConfigId"/>
                      <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;Csm&apos;))                                                 and (node:exists(as:modconf(&apos;ProgDAG&apos;))                                                 or  node:exists(as:modconf(&apos;ProgVAG&apos;))                                                 or  node:exists(as:modconf(&apos;ProgVCC&apos;))                                                 or  node:exists(as:modconf(&apos;ProgFord&apos;))                                                 or  node:exists(as:modconf(&apos;ProgJLR&apos;))                                                 or (node:exists(as:modconf(&apos;ProgOEMInd&apos;)) and (as:modconf(&apos;Prog&apos;)/OemInd/Checksum_Algo = &apos;Signature&apos;))                                                 or  node:exists(as:modconf(&apos;ProgFCA&apos;)))"/>
                      <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                            false="Invalid reference."/>
                      <a:da name="REF">
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmSignatureVerify/CsmSignatureVerifyConfig</a:v>
                      </a:da>
                    </v:ref>
                    <v:var name="BS_size" type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="DEC"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                            &lt;p&gt;This feature shall allow the Integrator to decide the size of the data to be processed 
                                            in a single Asynchronous Crypto main function call.&lt;/p&gt;
                                            &lt;p&gt;it allows to reduce the time blocked by the CryptoMainfunction in a single main 
                                            function call.&lt;/p&gt;
                                            &lt;p&gt;This feature can be enabled by entering any value other than 0(in bytes) in this field. 
                                            Setting it to 0 shall allow the Bootlaoder to pass the entire available data for processing
                                            in a single CryptoMainfunction call.&lt;/p&gt;
                                            &lt;p&gt;Note:&lt;/p&gt;
                                            &lt;p&gt;1. This field is only enabled for the integration of ASR Crypto stack version 4.3 or higher.&lt;/p&gt;
                                            &lt;p&gt;2. Enabling this feature (by setting a very small size) shall increase the time for verification significantly, 
                                            integrator shall decide the value to be set.&lt;/p&gt;
                                            &lt;p&gt;3. It is recommended to set this value to a maximum value that is sufficient to 
                                            not to cause timeouts in the system. &lt;/p&gt;
                                            &lt;p&gt;4. If this feature is enabled together with verification on fly, the minimum value of Verification_Buffer_size 
                                            and BS_size shall be effectively selected as the processing data size.&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Data size for Block Slicing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and (node:exists(../ProgCsmSignatureVerifyConfigId))"/>
                    </v:var>
                    <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                    &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                    &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                    is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                              &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Allow cancellation of any ongoing Crypto job"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="Allow2SetCryptoKey" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                             &lt;p&gt;This will allow the integrator to pass the desired key and its elements at the start of the Crypto operation. &lt;/p&gt;
                                                             &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                         &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Allow to fetch the stored Key"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="Allow2CustomCsmStartPreprocess" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                            &lt;p&gt;This will allow the integrator to perform the custom operations such as key encoding (eg. Base64, DER etc.) on the Key stored at the host side at the start of the Crypto operation&lt;/p&gt;
                                                            &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                                            &lt;p&gt;Note: The key encoding shall be performed only if the Crypto driver expects the key to be encoded in an expected format.&lt;/p&gt;
                                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Custom CSM start pre-processing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="AllowStreamStart" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                   &lt;p&gt;This parameter shall be enabled if the Signature Start operation takes more than one cycle of CryptoMainFunction execution.&lt;/p&gt;
                                   &lt;p&gt;Note: &lt;/p&gt;
                                   &lt;p&gt;1. This option is applicable only for the integration of Crypto ASR 4.3 or higher versions.&lt;/p&gt;
                                   &lt;p&gt;2. This shall be enabled only if the crypto engine supports the StreamStart feature.&lt;/p&gt;
                                   &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Enable StreamStart mode"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                    <v:var name="SignFinSendFRP" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                            &lt;p&gt;This parameter if enabled shall provide a force response Pending (NRC78) at the beginning of the Signature Finish operation.&lt;/p&gt;
                                                            &lt;p&gt;This parameter is introduced to avoid casuing P2 timeouts at client side when the Crypto driver main function call 
								     for the Crypto Finish operation blocks the other Boot functions longer than the modules manage period.&lt;/p&gt;
                                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Send NRC78 for Signature Finish"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmSignatureVerifyConfigId)"/>
                    </v:var>
                  </v:ctr>
                  <v:ctr name="HashVerification" type="IDENTIFIABLE">
                    <v:ref name="ProgCsmHashConfigId" type="CHOICE-REFERENCE">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                             &lt;p&gt;Reference a &lt;em&gt;CsmHashVerificationID&lt;/em&gt;&lt;/p&gt;
                                             &lt;p&gt;Specify which csm config Id shall be used for Hash Verification.&lt;/p&gt;
                                             &lt;p&gt;When the hash verification is used during the Download procedure(Erase, RequestDownload, CheckMemory).&lt;/p&gt;
                                             &lt;p&gt;An appropriate csm hash verification configuration should be referenced.&lt;/p&gt;

                                             &lt;p&gt;Dependencies:&lt;/p&gt;
                                             &lt;ul&gt;
                                                &lt;li&gt;Cryptographic libraries shall be present&lt;/li&gt;
                                             &lt;/ul&gt;
                                          &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v class="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="LABEL" value="ProgCsmHashConfigId"/>
                      <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;Csm&apos;))                                                 and (node:exists(as:modconf(&apos;ProgDAG&apos;))                                                 or   node:exists(as:modconf(&apos;ProgVCC&apos;))                                                 or   node:exists(as:modconf(&apos;ProgFord&apos;))                                                 or   node:exists(as:modconf(&apos;ProgJLR&apos;))                                                 or  (node:exists(as:modconf(&apos;ProgOEMInd&apos;)) and ((as:modconf(&apos;Prog&apos;)/OemInd/Checksum_Algo = &apos;Hash256&apos;) or (as:modconf(&apos;Prog&apos;)/OemInd/Checksum_Algo = &apos;Hash512&apos;)))                                                 or ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_High&apos;))                                                 or ((node:exists(as:modconf(&apos;ProgFCA&apos;))) and (as:modconf(&apos;ProgFCA&apos;)/General/PROG_FCA_VARIANT=&apos;Atlantis_Mid&apos;)))"/>
                      <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                            false="Invalid reference."/>
                      <a:da name="REF">
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                        <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmHash/CsmHashConfig</a:v>
                      </a:da>
                    </v:ref>
                    <v:var name="BS_size" type="INTEGER">
                      <a:a name="DEFAULT_RADIX" value="DEC"/>
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                             &lt;p&gt;This feature shall allow the Integrator to decide the size of the data to be processed 
                                                             in a single Asynchronous Crypto main function call.&lt;/p&gt;
                                                             &lt;p&gt;it allows to reduce the time blocked by the CryptoMainfunction in a single main 
                                                             function call.&lt;/p&gt;
                                                             &lt;p&gt;This feature can be enabled by entering any value other than 0(in bytes) in this field. 
                                                             Setting it to 0 shall allow the Bootlaoder to pass the entire available data for processing
                                                             in a single CryptoMainfunction call.&lt;/p&gt;
                                                             &lt;p&gt;Note:&lt;/p&gt;
                                                             &lt;p&gt;1. This field is only enabled for the integration of ASR Crypto stack version 4.3 or higher.&lt;/p&gt;
                                                             &lt;p&gt;2. Enabling this feature (by setting a very small size) shall increase the time for verification significantly.
                                                             The integrator shall decide the value to be set.&lt;/p&gt;
                                                             &lt;p&gt;3. It is recommended to set this value to a maximum value that is sufficient to 
                                                             not to cause timeouts in the system. &lt;/p&gt;
                                                             &lt;p&gt;4. If this feature is enabled together with verification on fly, the minimum value of Verification_Buffer_size 
                                                             and BS_size shall be effectively selected as the processing data size.&lt;/p&gt;
                                     &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Data size for Block Slicing"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                    <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                                 &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                                                 &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                                                 is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                             &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" 
                           value="Allow cancellation of any ongoing Crypto job"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="true"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                    <v:var name="HashFinSendFRP" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v>&lt;html&gt;
                                                            &lt;p&gt;This parameter if enabled shall provide a force response Pending (NRC78) at the beginning of the Hash Finish operation.&lt;/p&gt;
                                                            &lt;p&gt;This parameter is introduced to avoid casuing P2 timeouts at client side when the Crypto driver main function call 
															for the Crypto Finish operation blocks the other Boot functions longer than the modules manage period.&lt;/p&gt;
                                                        &lt;/html&gt;</a:v>
                      </a:a>
                      <a:a name="LABEL" value="Send NRC78 for Hash Finish"/>
                      <a:a name="ORIGIN" value="EB"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:da name="DEFAULT" value="false"/>
                      <a:da name="ENABLE" type="XPath" 
                            expr="node:exists(../ProgCsmHashConfigId)"/>
                    </v:var>
                  </v:ctr>
                </v:ctr>
              </v:ctr>
              <v:ctr name="OemInd" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the OemInd specific configuration&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="OemInd"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgOEMInd&apos;))"/>
                <v:var name="Erase_Mode" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify how the erasing shall be performed.&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case All: No information are provided in EraseMemory routine and all the configured segments will be erased on reception of the routine.&lt;/li&gt;
                                              &lt;li&gt;Case Address: Erasing will be performed on the configured segment matching the address provided in EraseMemory routine&lt;/li&gt;
                                              &lt;li&gt;Case LogicalBlock: Erasing will be performed on the configured segments associated (by configuration) to the logical block Id provided in EraseMemory routine&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Erasing mode"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Address"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>All</a:v>
                    <a:v>Address</a:v>
                    <a:v>LogicalBlock</a:v>
                  </a:da>
                </v:var>
                <v:var name="EraseALFI_Enable" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Enable the ALFI UDS field in EraseMemory request (Available only if erasing mode is by address)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Erase request ALFI Enable"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;))) and as:modconf(&apos;Prog&apos;)/OemInd/Erase_Mode=&apos;Address&apos;"/>
                </v:var>
                <v:var name="Request_Download_Address_Mode" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify the content of the request download start address&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case Download by logical block: Only block ID will be sent in the request and the block cannot have more than one segment&lt;/li&gt;
                                              &lt;li&gt;Case Download by logical block and segment: block ID and segment ID will be sent in the request and the block can have multiple segments&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Request Download Addressing Mode"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="Download by Segment Address"/>
                  <a:da name="RANGE">
                    <a:v>Download by Segment Address</a:v>
                    <a:v>Download by logical block</a:v>
                    <a:v>Download by logical block and segment</a:v>
                  </a:da>
                </v:var>
                <v:var name="CoherencyCheck_Enable" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                          &lt;p&gt;Enable the coherency check (check programming dependencies).&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Coherency check Enable"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                </v:var>
                <v:var name="Application_Validity_Algo" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify if the Elektrobit algorithm shall be used for application validity management and fingerprint management or a customer specific one.&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case EB: standard algorithm will be used&lt;/li&gt;
                                              &lt;li&gt;Case Custom: Customer shall complete the PROG_IsValidApplication/PROG_CustomSetDownloadVerificationSuccess/PROG_InvalidateSection/PROG_EntryWriteFingerprint and managed the application status.&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Application validity check and fingerprint: EB specific / Customer specific"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="EB"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>EB</a:v>
                    <a:v>Custom</a:v>
                  </a:da>
                </v:var>
                <v:var name="Checksum_Algo" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify which checksum algorithm shall be used&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case NO CRC: No checksum needed.&lt;/li&gt;
                                              &lt;li&gt;Case Signature: A cryptographic signature verification will be done (only possible if cryptographic libraries are used)&lt;/li&gt;
                                              &lt;li&gt;Case Hash256: A cryptographic Hash verification will be done with SHA-256(only possible if cryptographic libraries are used)&lt;/li&gt;
                                              &lt;li&gt;Case Hash512: A cryptographic Hash verification will be done SHA-512(only possible if cryptographic libraries are used)&lt;/li&gt;
                                              &lt;li&gt;Case CRC16 CCITT : Polynomial 0x1021 / Init value 0xFFFF / ReflectIn FALSE / ReflectOut FALSE / No XOR on Output&lt;/li&gt;
                                              &lt;li&gt;Case CRC32 Ethernet: Polynomial 0x04C11DB7 / Init value 0xFFFFFFFF / ReflectIn TRUE / ReflectOut TRUE / XOR on Output 0xFFFFFFFF &lt;/li&gt;
                                              &lt;li&gt;Case CRC32 International Standard 32-Bit CRC: Polynomial 0xEDB88320 / Init value 0xFFFFFFFF / ReflectIn FALSE / ReflectOut FALSE / XOR on Output 0xFFFFFFFF &lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="CRC algorithm: NO CRC / Signature / Hash256 / Hash512 / CRC16 CCITT/ CRC32 Ethernet / CRC32 International Standard 32-Bit CRC"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="CRC32 Ethernet"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgOEMInd&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>NO CRC</a:v>
                    <a:v>Signature</a:v>
                    <a:v>Hash256</a:v>
                    <a:v>Hash512</a:v>
                    <a:v>CRC16</a:v>
                    <a:v>CRC32 Ethernet</a:v>
                    <a:v>CRC32 InternationalStandard</a:v>
                  </a:da>
                </v:var>
                <v:var name="Size_Of_FingerPrint" type="INTEGER">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Define the size of the FingerPrint in Bytes.&lt;/p&gt;
                                            &lt;p&gt;The size can&apos;t be negative.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="16"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgOEMInd&apos;)) and as:modconf(&apos;Uds&apos;)/Service_DID/*/Callback = &apos;PROG_WriteFingerprint&apos;"/>
                  <a:da name="INVALID" type="Range" expr="&gt;=0"/>
                </v:var>
              </v:ctr>
              <v:ctr name="VAG" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the Volkswagen specific configuration&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="VAG"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgVAG&apos;))"/>
                <v:var name="Request_Download_Address_Mode" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Specify the content of the request download start address&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case Download by logical block: Only block ID will be sent in the request and the block cannot have more than one segment&lt;/li&gt;
                                              &lt;li&gt;Case Download by logical block and segment: block ID and segment ID will be sent in the request and the block can have multiple segments&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Request Download Addressing Mode"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" 
                        value="Download by logical block and segment"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)))"/>
                  <a:da name="RANGE">
                    <a:v>Download by logical block</a:v>
                    <a:v>Download by logical block and segment</a:v>
                  </a:da>
                </v:var>
                <v:var name="Downgrade_Protection" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Enable the downgrade protection feature&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case tick  : Downgrade protection feature is enabled and the configuration of the PFT block shall be performed&lt;/li&gt;
                                              &lt;li&gt;Case untick: Downgrade protection feature is disabled&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Downgrade Protection"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="BID_Length" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Length of the block identifier contained in the pseudo flash driver 1 or 2 bytes&lt;/p&gt;
                                            &lt;ul&gt;
                                              &lt;li&gt;Case 1 byte   : BIDLEN is 1 byte&lt;/li&gt;
                                              &lt;li&gt;Case 2 bytes  : BIDLEN is 2 bytes&lt;/li&gt;
                                            &lt;/ul&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Block Identifier Length"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) and ../Downgrade_Protection = &apos;true&apos;)"/>
                  <a:da name="RANGE">
                    <a:v>1</a:v>
                    <a:v>2</a:v>
                  </a:da>
                </v:var>
                <v:ref name="PFT_Block_Id" type="CHOICE-REFERENCE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                         &lt;p&gt;Reference to the &lt;em&gt;pseudo flash driver block identifier&lt;/em&gt;&lt;/p&gt;

                                         &lt;p&gt;Dependencies:&lt;/p&gt;
                                         &lt;ul&gt;
                                            &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                         &lt;/ul&gt;
                                      &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="PFT Block Identifier"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;)) and as:modconf(&apos;Prog&apos;)/VAG/Downgrade_Protection=&apos;true&apos;)"/>
                  <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                        false="Invalid reference."/>
                  <a:da name="REF" 
                        value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Prog/Blocks"/>
                </v:ref>
              </v:ctr>
              <v:ctr name="PSA" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the PSA specific configuration&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="PSA"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="node:exists(as:modconf(&apos;ProgPSA&apos;))"/>
                <v:var name="Memory_Base_Address" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Provides the Most Significant Byte (MSB) of addresses&lt;/p&gt;
                                            &lt;p&gt;Applicable only for 32 bits ECU address&lt;/p&gt;
                                            &lt;p&gt;If ECU address is different from 32 bits, set this value 0x00&lt;/p&gt;
                                            &lt;p&gt;Range [0x00; 0xFF]&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Memory Base Address"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0xA0"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;ProgPSA&apos;))"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=255"/>
                  </a:da>
                </v:var>
              </v:ctr>
              <v:ctr name="Decryption" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        This container contains the Decryption specific configuration.
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="LABEL" value="Decryption"/>
                <a:a name="TAB" value="Decryption"/>
                <v:var name="Enable_Decryption" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;If enabled, a callback will be called on data reception allowing integration code to perform data decryption.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                <v:var name="Decryption_Algorithm" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                &lt;p&gt;Decryption algorithm id that shall be supported from dataFormatIdentifier field of RequestDownload service&lt;/p&gt;
                                            &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Decryption algorithm Id"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="TAB" value="Decryption"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range" expr="&lt;=15"/>
                </v:var>
                <v:var name="Enable_Csm_Decryption" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt; If enabled, it allows to use a symetric algorithm provided by CSM library. Current implementation is limited to CBC decryption with PKCS7 Padding. Cry Primitive name : CbcPkcs7Decrypt.&lt;/p&gt;
                                            &lt;p&gt; If disabled, the user is free to implement its own decryption algorithm within callback function.&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Use Symetric algorithm for decryption"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="((node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))) and as:modconf(&apos;Prog&apos;)/Decryption/Enable_Decryption=&apos;true&apos;)"/>
                  <a:da name="INVALID" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgVAG&apos;))and as:modconf(&apos;Prog&apos;)/Decryption/Enable_Csm_Decryption=&apos;false&apos;)" 
                        true="For VWAG, the decryption algorithm must be used from Csm."/>
                </v:var>
                <v:ref name="ProgCsmDecryptionConfigId" type="CHOICE-REFERENCE">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                         &lt;p&gt;Reference a &lt;em&gt;CsmSymDecryptConfig&lt;/em&gt;&lt;/p&gt;

                                         &lt;p&gt;Dependencies:&lt;/p&gt;
                                         &lt;ul&gt;
                                            &lt;li&gt;Reference shall be valid&lt;/li&gt;
                                         &lt;/ul&gt;
                                      &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="ProgCsmDecryptionConfigId"/>
                  <a:a name="ORIGIN" value="Elektrobit Automotive GmbH"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;Csm&apos;)) and (node:exists(as:modconf(&apos;ProgVAG&apos;)) or node:exists(as:modconf(&apos;ProgOEMInd&apos;))) and as:modconf(&apos;Prog&apos;)/Decryption/Enable_Csm_Decryption=&apos;true&apos;)"/>
                  <a:da name="INVALID" type="XPath" expr="node:refvalid(.)" 
                        false="Invalid reference."/>
                  <a:da name="REF">
                    <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmJobs/CsmJob</a:v>
                    <a:v>ASPathDataOfSchema:/AUTOSAR/EcucDefs/Csm/CsmSymDecrypt/CsmSymDecryptConfig</a:v>
                  </a:da>
                </v:ref>
                <v:var name="Allow2Cancel_OngoingJobs" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                              &lt;p&gt;If enabled, any ongoing or active Crypto job operations shall be cancelled at the start of this job operation.&lt;/p&gt;
                                                              &lt;p&gt;This option is applicable only for the integration of Crypto ASR 4.3 or higher versions, for older version this feature 
                                                              is realized using &apos;Enable the cancelation of ongoing requests&apos; in the Csm/Cry modules.&lt;/p&gt;
                                                          &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" 
                       value="Allow cancellation of all ongoing Crypto jobs"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;))and node:exists(../ProgCsmDecryptionConfigId)"/>
                </v:var>
                <v:var name="Allow2SetCryptoKey" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;This will allow the integrator to pass the desired key and its elements at the start of the Crypto operation. &lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto 4.3 or higher versions.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Allow to set the stored Key"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmDecryptionConfigId)"/>
                </v:var>
                <v:var name="Allow2SetIV" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;This will allow the integrator to pass the desired IV value needed for the decryption (this is AES algo dependant). &lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto 4.3 or higher versions.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Allow to set the IV"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and node:exists(../ProgCsmDecryptionConfigId)"/>
                </v:var>
                <v:var name="Allow2CustomCsmStartPreprocess" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                                        &lt;p&gt;This will allow the integrator to perform Csm job specific preprocessing operations such as performing encoding (eg. Base64, DER etc.) 
                                                        on the Key stored at the host side just before the start of the Crypto operation&lt;/p&gt;
                                                        &lt;p&gt;This option is applicable only for the integration of Crypto 4.3 or higher versions.&lt;/p&gt;
                                                        &lt;p&gt;Note: The key encoding shall be performed only if the Crypto driver expects the key to be encoded in an expected format.&lt;/p&gt;
                                                    &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="LABEL" value="Custom CSM start pre-processing"/>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="node:exists(as:modconf(&apos;CryIf&apos;)) and  node:exists(../ProgCsmDecryptionConfigId)"/>
                </v:var>
              </v:ctr>
              <v:ctr name="SwitchingKeyRoutineData" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v>&lt;html&gt;
                                        &lt;p&gt;This container contains the Fixed Paramters related to Switch Key Routine&lt;/p&gt;
                                    &lt;/html&gt;</a:v>
                </a:a>
                <a:a name="TAB" value="FORD"/>
                <a:da name="ENABLE" type="XPath" 
                      expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                <v:var name="SwitchingKey_Routine_Max_Length" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Maximum Length of the switching key routine (i.e. request was made for other then update keys)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x768"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                </v:var>
                <v:var name="SwitchingKey_Routine_Min_Length" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt;Minimum Length of the switching key routine (i.e. request was made to switch the modes)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x14D"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                </v:var>
                <v:var name="SwitchingKey_DevPublic_Key_Size" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt; This parameter will have the lenght of the development Public Key size (Used for signature verification in development mode)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x200"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                </v:var>
                <v:var name="SwitchingKey_ProdPublic_Key_Size" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt; This parameter will have the lenght of the Production Public Key size (Used for signature verification in production mode)&lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x200"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                </v:var>
                <v:var name="SwitchingKey_TokenPublic_Key_Size" type="INTEGER">
                  <a:a name="DEFAULT_RADIX" value="HEX"/>
                  <a:a name="DESC">
                    <a:v>&lt;html&gt;
                                            &lt;p&gt; This parameter will have the lenght of the Token Public Key size (Used for routine signature verification) &lt;/p&gt;
                                        &lt;/html&gt;</a:v>
                  </a:a>
                  <a:a name="ORIGIN" value="EB"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:da name="DEFAULT" value="0x200"/>
                  <a:da name="ENABLE" type="XPath" 
                        expr="(node:exists(as:modconf(&apos;ProgFord&apos;)) and as:modconf(&apos;ProgFord&apos;)/General/PROG_FORD_VARIANT=&apos;SBL&apos;)"/>
                </v:var>
              </v:ctr>
            </v:ctr>
          </d:chc>
          <d:chc name="myEcuParameterDefinition" type="AR-ELEMENT" 
                 value="ECU_PARAMETER_DEFINITION">
            <d:ctr type="AR-ELEMENT">
              <a:a name="DEF" 
                   value="ASPath:/AR_PACKAGE_SCHEMA/ECU_PARAMETER_DEFINITION"/>
              <d:lst name="MODULE_REF">
                <d:ref type="MODULE_REF" value="ASPath:/TS_TxDxM2I74R0/Prog"/>
              </d:lst>
            </d:ctr>
          </d:chc>
        </d:lst>
      </d:ctr>
    </d:lst>
  </d:ctr>

</datamodel>
