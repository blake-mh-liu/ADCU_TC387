/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \version 6.5.8
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2024 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#ifndef DEM_CFG_H
#define DEM_CFG_H

/* This file contains all target independent public configuration declarations
 * for the AUTOSAR module Dem. */

/* MISRA-C:2012 Deviation List
 *
 * MISRAC2012-1) Deviated Rule: 20.7 (required)
 *     Expressions resulting from the expansion of macro parameters shall be enclosed in
 *     parentheses.
 *
 *     Reason:
 *     The macro DEM_CONST_CALIBRATION is used to modify the read-only attribute of a memory section
 *     to which a constant is assigned via the compiler abstraction macro, in order for the compiler
 *     to allow the simulation of the constant calibration. The syntax of the compiler abstraction
 *     macro definition requires that DEM_CONST_CALIBRATION macro's definition to not be enclosed in
 *     parentheses.
 */

[!AUTOSPACING!]
[!INCLUDE "../../generate_common/Dem_Include.m"!]
[!//
/*==================[includes]==============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

[!IF "node:existsAndTrue(DemGeneral/DemRteUsage)"!]
#include <Rte_Dem_Type.h>        /* types generated by RTE */
[!ENDIF!]
#include <Dem_IntErrId.h>        /* BSW Event ID symbols */
#include <Dem_IntEvtId.h>        /* SW-C Event ID symbols */

[!IF "node:exists(DemGeneral/DemNvRamBlockId/eb-list::*)"!]
#include <NvM.h>           /* NvM symbols */
[!ENDIF!]

/*==================[type definitions]======================================*/

#ifndef RTE_TYPE_Dem_EventIdType
#define RTE_TYPE_Dem_EventIdType
/**  \brief Defines the Dem Event ID which is
 **  identification of an event by assigned EventId
 **  In case the Rte is available this type is defined in Rte_Type.h.
 **/
typedef uint16 Dem_EventIdType;
#endif

/*==================[macros]================================================*/
[!CALL "CREATE_DTCCLASS_LIST_FROM_EVENTS"!][!//
[!CALL "CALC_DESCRIPTION", "Array" = "$EventDescStr"!][!//

[!IF "node:exists(DemGeneral/DemMaxNumberEventEntryEventBuffer)"!][!//
  [!WS "0"!][!VAR "DemMaxNumberExternalEntryDataBuffers" = "num:integer(DemGeneral/DemMaxNumberEventEntryEventBuffer)"!]
/** \brief Definition of DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER */
#if (defined DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER)
#error DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER already defined
#endif
/** \brief Definition of DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER */
  [!WS "0"!]#define DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER [!"num:integer($DemMaxNumberExternalEntryDataBuffers)"!]U
[!ELSE!][!//
/** \brief Definition of DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER */
#if (defined DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER)
#error DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER already defined
#endif
  [!WS "0"!]#define DEM_MAX_NUM_EVENT_ENTRY_CAPTURE_BUFFER   0U
[!ENDIF!]

[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport)"!]
#if (defined DEM_OBD_DTCVALUE3BYTE_SUPPORT)
#error DEM_OBD_DTCVALUE3BYTE_SUPPORT already defined
#endif
/** \brief Macro to define support of the seperate 3-byte OBD DTC
 ** for the OBD variant OBDonUDS */
[!IF "$ObdUdsDtcSeparationSupport = 'true'"!][!//
  [!WS "0"!]#define DEM_OBD_DTCVALUE3BYTE_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_DTCVALUE3BYTE_SUPPORT STD_OFF
[!ENDIF!][!//
[!ENDIF!][!//

[!IF "node:exists(DemGeneral/DemGeneralOBD)"!][!//
#if (defined DEM_GENERAL_OBD)
#error DEM_GENERAL_OBD already defined
#endif
/** \brief Definition of DEM_GENERAL_OBD */
#define DEM_GENERAL_OBD STD_ON
[!ELSE!][!//
#if (defined DEM_GENERAL_OBD)
#error DEM_GENERAL_OBD already defined
#endif
/** \brief Definition of DEM_GENERAL_OBD */
#define DEM_GENERAL_OBD STD_OFF
[!ENDIF!]

[!IF "node:exists(DemGeneral/DemGeneralOBD/DemOBDEngineType) and (DemGeneral/DemGeneralOBD/DemOBDEngineType = 'DEM_IGNITION_COMPRESSION')"!][!//
#if (defined DEM_OBD_ENGINE_TYPE)
#error DEM_OBD_ENGINE_TYPE already defined
#endif
/** \brief Definition of DEM_OBD_ENGINE_TYPE */
#define DEM_OBD_ENGINE_TYPE DEM_IGNITION_COMPRESSION
[!ELSEIF "node:exists(DemGeneral/DemGeneralOBD/DemOBDEngineType) and (DemGeneral/DemGeneralOBD/DemOBDEngineType = 'DEM_IGNITION_SPARK')"!][!//
#if (defined DEM_OBD_ENGINE_TYPE)
#error DEM_OBD_ENGINE_TYPE already defined
#endif
/** \brief Definition of DEM_OBD_ENGINE_TYPE */
#define DEM_OBD_ENGINE_TYPE DEM_IGNITION_SPARK
[!ENDIF!]

[!/* extract the configured readiness group mask for spark and compression engine */!][!//
[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport)"!][!//
  [!IF "node:exists(DemGeneral/DemReadinessGroupCalibration/eb-list::*)"!][!//
    [!CALL "CREATE_READINESSGROUPS_CONFIG_LIST"!][!//
      [!VAR "RGMaskConfigured" = "$RGMaskConfiguredEventSlots"!][!//
  [!ELSEIF "(DemGeneral/DemReadinessGroupCalibrationConfigKind = 'DEM_NUMBER_OF_SLOTS_COMMON_CONFIG')"!][!//
    [!CALL "CREATE_LEGACY_READINESSGROUPS_LIST"!][!//
    [!CALL "CREATE_READINESS_INFO_LIST"!][!//
      [!VAR "RGMaskConfigured" = "$RGMaskConfiguredLegacy"!][!//
  [!ELSE!][!//
    [!CALL "CREATE_READINESSGROUPS_EVENT_LIST"!][!//
      [!VAR "RGMaskConfigured" = "$RGMaskConfiguredEvent"!][!//
  [!ENDIF!][!//
  [!VAR "EngineType"= "node:value(DemGeneral/DemGeneralOBD/DemOBDEngineType)"!][!//
  [!IF "((node:exists(DemGeneral/DemObdVariant)) and (DemGeneral/DemObdVariant = 'DEM_OBD_VARIANT_OBDONUDS'))  or
        (node:exists(DemGeneral/DemCalloutObdVariantFnc))"!][!//
    [!CALL "GET_RGMASK", "Readiness" = "'PIDF501'", "Engine" = "$EngineType"!][!//
#if (defined DEM_RGP_RGMASK_PIDF501)
#error DEM_RGP_RGMASK_PIDF501 already defined
#endif
/** \brief Macro to define positional bit mask, indicating which
 ** readiness groups are required for calculation of PID $F501 */
    [!WS "0"!]#define DEM_RGP_RGMASK_PIDF501 [!"translate(num:inttohex($RGConfigMask), 'abcdef', 'ABCDEF')"!]U
  [!ENDIF!][!//

  [!CALL "GET_RGMASK", "Readiness" = "'PID01_41'", "Engine" = "$EngineType"!][!//
#if (defined DEM_RGP_RGMASK_PID01_PID41)
#error DEM_RGP_RGMASK_PID01_PID41 already defined
#endif
/** \brief Macro to define positional bit mask, indicating which
 ** readiness groups are required for calculation of PID $01 and PID $41 */
  [!WS "0"!]#define DEM_RGP_RGMASK_PID01_PID41 [!"translate(num:inttohex($RGConfigMask), 'abcdef', 'ABCDEF')"!]U

  [!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939Readiness1Support)"!]
    [!CALL "GET_RGMASK", "Readiness" = "'J1939Readiness1'", "Engine" = "$EngineType"!][!//
#if (defined DEM_RGP_RGMASK_J1939READINESS1)
#error DEM_RGP_RGMASK_J1939READINESS1 already defined
#endif
/** \brief Macro to define positional bit mask, indicating which
 ** readiness groups are required for calculation of J1939Readiness1 */
    [!WS "0"!]#define DEM_RGP_RGMASK_J1939READINESS1 [!"translate(num:inttohex($RGConfigMask), 'abcdef', 'ABCDEF')"!]U
    [!CALL "CREATE_J1939_NODE_LIST"!][!//
    [!IF "$ReadinessJ1939Support = 'true'"!][!//
#if (defined DEM_RGP_NUM_J1939_READINESS_NODES)
#error DEM_RGP_NUM_J1939_READINESS_NODES already defined
#endif
/** \brief Macro to define total number of J1939 Node Ids that are relevant
 ** for readiness group calculation */
#define DEM_RGP_NUM_J1939_READINESS_NODES  [!"num:integer($NumReadinessRelevantNodes)"!]U
    [!ENDIF!][!//
  [!ENDIF!][!//
  [!IF "$CalibrationSupport = 'true'"!][!//
    [!CALL "GET_NUMBER_RG_EVENTS"!][!//
/** \brief Macro to define total number of calibratable event slots used for
 ** all readiness groups */
#if (defined DEM_RGP_MAX_NUM_READINESS_EVENTS)
#error DEM_RGP_MAX_NUM_READINESS_EVENTS already defined
#endif
    [!WS "0"!]#define DEM_RGP_MAX_NUM_READINESS_EVENTS [!"translate(num:inttohex($EventIdSlots), 'abcdef', 'ABCDEF')"!]U
  [!ENDIF!][!//
[!ENDIF!][!//

#if (defined DEM_CFG_SIGNATURE)
#error DEM_CFG_SIGNATURE is already defined
#endif
/* !LINKSTO Dem.EB.Config.Id,1 */
/** \brief Sign a certain configuration with unique hash
 **/
#define DEM_CFG_SIGNATURE [!"asc:getConfigSignature(node:difference(as:modconf('Dem')[1]//
                            *[not(child::*) and(node:configclass() = 'PreCompile')],
                            as:modconf('Dem')[1]/DemConfigSet/eb-list::*))"!]U

#if (defined DEM_NVRAM_CONFIG_SIGNATURE_USED)
#error DEM_NVRAM_CONFIG_SIGNATURE_USED is already defined
#endif

/* !LINKSTO Dem.NvDataSignature.Config.Used,1 */
/** \brief Switch, Indicating a support of reset of NVRAM memory based on signature value
 **/
[!IF "(not(node:exists(DemGeneral/DemNvDataConfigSignatureUsed))) or (node:existsAndFalse(DemGeneral/DemNvDataConfigSignatureUsed))"!]
  [!WS "0"!]#define DEM_NVRAM_CONFIG_SIGNATURE_USED    STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_NVRAM_CONFIG_SIGNATURE_USED    STD_ON

#if (defined DEM_CONFIG_NVRAM_SIGNATURE)
#error DEM_CONFIG_NVRAM_SIGNATURE is already defined
#endif

/* !LINKSTO Dem.NvDataSignature.Calculation,1 */
/* !LINKSTO Dem.NvDataSignature.Config.CalcSet,1 */
/** \brief Signature value on a certain configuration parameters which affects Nv Data
 **/
[!IF "(DemGeneral/DemNvDataConfigSignatureCalcSet = 'DEM_NVM_SIGNATURE_ALL')"!]
#define DEM_CONFIG_NVRAM_SIGNATURE [!"asc:getConfigSignature(as:modconf('Dem')[1]//eb-list::*)"!]U
[!ELSE!][!//
/* Note: The last node in the signature is included without util:union as there is only single node,
         If there is another node to be included please use util:union to extend the signature calculation */
#define DEM_CONFIG_NVRAM_SIGNATURE [!"asc:getConfigSignature(
util:union(
  util:union(
    util:union(as:modconf('Dem')[1]/DemGeneral/DemFreezeFrameCapture,
               as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture,
               as:modconf('Dem')[1]/DemGeneral/DemNvRamBlockId/eb-list::*/DemNvRamBlockIdRef,
               as:modconf('Dem')[1]/DemGeneral/DemResetConfirmedBitOnOverflow,
               as:modconf('Dem')[1]/DemGeneral/DemGetDTCByOccurrenceTimeSupport,
               as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryPrimary),
    util:union(as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntrySecondary,
               as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryMirror,
               as:modconf('Dem')[1]/DemGeneral/DemMaxNumberEventEntryPermanent,
               as:modconf('Dem')[1]/DemGeneral/DemOperationCycleStatusStorage,
               as:modconf('Dem')[1]/DemGeneral/DemIndicator/eb-list::*,
               as:modconf('Dem')[1]/DemGeneral/DemMaxNumberDevFreezeFrameAEntry),
    util:union(as:modconf('Dem')[1]/DemGeneral/DemMaxNumberDevFreezeFrameBEntry,
               as:modconf('Dem')[1]/DemGeneral/DemEventCombinationSupport,
               as:modconf('Dem')[1]/DemGeneral/DemOBDSupport,
               as:modconf('Dem')[1]/DemGeneral/DemIntermediateNvStorageOfDTCStatus,
               as:modconf('Dem')[1]/DemGeneral/DemOperationCycle/eb-list::*[DemOperationCycleType = 'DEM_OPCYC_WARMUP'],
               as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDCentralizedPID21Handling),
    util:union(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDCentralizedPID31Handling,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemPidClass/eb-list::*,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventId,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef,
               util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*) ,
    util:union(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*)),
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*))/DemDataElementDataSize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*))/DemDataElementReadFnc,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*))/DemDataElementUsePort,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*))/DemInternalDataElement) ,
    util:union(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef,
               util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidIdentifier,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementDataSize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementReadFnc)
            ),
  util:union(
    util:union(util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementUsePort,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemInternalDataElement,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef,
               util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidIdentifier,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*) ,
    util:union(util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementDataSize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementReadFnc,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementUsePort,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemInternalDataElement,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef,
               util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*) ,
    util:union(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidIdentifier,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementDataSize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementReadFnc,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementUsePort,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemInternalDataElement) ,
    util:union(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refexists(DemDTCClassRef)]/DemDTCClassRef,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:exists(./DemEventClass/DemEventFailureCycleCounterThreshold)]/DemEventClass/DemEventFailureCycleCounterThreshold,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass/DemIndicatorAttribute/eb-list::*,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass/DemEventAvailable,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass/DemEventDestination,
               as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:exists(DemEvtCmbCommonParamMaster)]/DemEvtCmbCommonParamMaster) ,
    util:union(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[DemEventClass/DemDebounceAlgorithmClass = 'DemDebounceCounterBased']/DemEventClass/DemDebounceAlgorithmClass/eb-choice::*[1]/DemDebounceCounterStorage,
               as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef,
               util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidIdentifier,
               util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementDataSize) ,
    util:union(util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementReadFnc,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementUsePort,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemInternalDataElement,
               as:modconf('Dem')[1]/DemGeneral/DemGeneralJ1939/DemJ1939Readiness1Support,
               as:modconf('Dem')[1]/eb-list::*[node:existsAndTrue(DemGeneralJ1939/DemJ1939Readiness1Support)]/../DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass/DemEventOBDReadinessGroup,
               util:distinct(node:refs(as:modconf('Dem')[1]/eb-list::*[node:existsAndTrue(DemGeneralJ1939/DemJ1939Readiness1Support)]/../DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[DemEventClass/DemEventOBDReadinessGroup != 'DEM_OBD_RDY_NONE']/DemDTCClassRef))/eb-list::*[node:refexists(.)])
            ),
  util:union(
    util:union(as:modconf('Dem')[1]/eb-list::*[(node:exists(DemObdVariant) and (DemObdVariant != 'DEM_OBD_VARIANT_OBD_CLASSIC'))]/DemObdVariant,
               as:modconf('Dem')[1]/eb-list::*[node:exists(DemCalloutObdVariantFnc)],
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemExtendedDataClassRef))/DemExtendedDataRecordClassRef/eb-list::*))/DemDataElementClassRef/eb-list::*))/DemDataElementArraySize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementArraySize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameAClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementArraySize,
               util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemDevFreezeFrameBClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementArraySize) ,
    util:union(util:distinct(node:refs(util:distinct(node:refs(util:distinct(node:refs(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))/DemDidClassRef/eb-list::*))/DemDidDataElementClassRef/eb-list::*))/DemDataElementArraySize,
               as:modconf('Dem')[1]/DemGeneral/DemIgnoreResetEventStatusForEventRelatedDataCapturing)
            )
       )
)"!]U
[!ENDIF!]
[!ENDIF!]

/*------------------[RTE configuration]-------------------------------------*/

#if (defined DEM_INCLUDE_RTE)
#error DEM_INCLUDE_RTE already defined
#endif
/** \brief Switch, indicating if RTE is available and can be used from Dem */
[!IF "node:existsAndTrue(DemGeneral/DemRteUsage)"!]
  [!WS "0"!]#define DEM_INCLUDE_RTE              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_INCLUDE_RTE              STD_OFF
[!ENDIF!]

#if (defined DEM_SERVICE_API_NONE)
#error DEM_SERVICE_API_NONE already defined
#endif
/** \brief Definition that no default service API is set */
#define DEM_SERVICE_API_NONE      0U

#if (defined DEM_SERVICE_API_ASR40)
#error DEM_SERVICE_API_ASR40 already defined
#endif
/** \brief Definition that AUTOSAR 4.0 service API is set as default */
#define DEM_SERVICE_API_ASR40     40U

#if (defined DEM_SERVICE_API_ASR42)
#error DEM_SERVICE_API_ASR42 already defined
#endif
/** \brief Definition that AUTOSAR 4.2 service API is set as default */
#define DEM_SERVICE_API_ASR42     42U

#if (defined DEM_SERVICE_API_ASR2011)
#error DEM_SERVICE_API_ASR2011 already defined
#endif
/** \brief Definition that AUTOSAR 20-11 service API is set as default */
#define DEM_SERVICE_API_ASR2011   2011U

#if (defined DEM_ENABLE_ASR40_SERVICE_API)
#error DEM_ENABLE_ASR40_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.0 service API is enabled */
[!IF "node:existsAndTrue(DemGeneral/DemRteUsage) and
      node:existsAndTrue(DemGeneral/DemServiceAPI/DemEnableASR40ServiceAPI)"!]
  [!WS "0"!]#define DEM_ENABLE_ASR40_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR40_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_ENABLE_ASR42_SERVICE_API)
#error DEM_ENABLE_ASR42_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.2 service API is enabled */
[!IF "node:existsAndTrue(DemGeneral/DemRteUsage) and
      node:existsAndTrue(DemGeneral/DemServiceAPI/DemEnableASR42ServiceAPI)"!]
  [!WS "0"!]#define DEM_ENABLE_ASR42_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR42_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_ENABLE_ASR43_SERVICE_API)
#error DEM_ENABLE_ASR43_SERVICE_API already defined
#endif
/** \brief Definition whether AUTOSAR 4.3 service API is enabled */
[!IF "node:existsAndTrue(DemGeneral/DemRteUsage) and
      DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_43'"!]
  [!WS "0"!]#define DEM_ENABLE_ASR43_SERVICE_API  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_ENABLE_ASR43_SERVICE_API  STD_OFF
[!ENDIF!]

#if (defined DEM_DEFAULT_ASR_SERVICE_API)
#error DEM_DEFAULT_ASR_SERVICE_API already defined
#endif
/** \brief Definition of default service API
 ** AUTOSAR_40: service APIs are fully based on the AUTOSAR 4.0 specification.
 ** AUTOSAR_42: some parts of the service APIs are based on the AUTOSAR 4.2
 ** specification the remaning APIs are still based on the AUTOSAR 4.0
 ** specification.
 ** AUTOSAR_43: uses AUTOSAR 4.2 as base, see above, plus some service APIs
 ** based on AUTOSAR 4.3.
 ** AUTOSAR_2011: uses AUTOSAR 4.2 as base, see above, plus some service APIs
 ** based on AUTOSAR 20-11.
 **/
[!IF "node:existsAndTrue(DemGeneral/DemRteUsage)"!]
  [!IF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_40'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR40
  [!ELSEIF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_42'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR42
  [!ELSEIF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_43'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR42
  [!ELSEIF "DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_2011'"!]
    [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_ASR2011
  [!ENDIF!]
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEFAULT_ASR_SERVICE_API DEM_SERVICE_API_NONE
[!ENDIF!]

#if (defined DEM_USER_CTRL_WIR_SUPPORT)
#error DEM_USER_CTRL_WIR_SUPPORT already defined
#endif
/** \brief Switch, indicating if user controlled WIR-bit is enabled */
[!IF "node:existsAndTrue(DemGeneral/DemUserControlledWIRBitSupport)"!]
  [!WS "0"!]#define DEM_USER_CTRL_WIR_SUPPORT              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USER_CTRL_WIR_SUPPORT             STD_OFF
[!ENDIF!]

#if (defined DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT)
#error DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT already defined
#endif
/** \brief Switch, indicating if support for ReadData interface with
  * EventId parameter is enabled */
[!IF "node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[(node:name(.) = 'DemExternalCSDataElementClass') and (node:existsAndTrue(./DemDataElementInterfaceWithEventParameter))])"!]
  [!WS "0"!]#define DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DATA_ELEMENT_INTERFACE_WITH_EVENTID_SUPPORT  STD_OFF
[!ENDIF!]

[!IF "(node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalCSDataElementClass' or node:name(.) = 'DemExternalSRDataElementClass']))"!]
  [!VAR "MaxSizeDE" = "1"!]
  [!LOOP "DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalSRDataElementClass']"!]
    [!VAR "DataTypeSize" = "(substring-after(./DemDataElementDataType, 'UINT')) div 8"!]
    [!IF "$DataTypeSize = 2"!]
      [!VAR "ArraySize" = "num:integer((./DemDataElementDataSize + 1) div 2)"!]
      [!IF "$ArraySize > $MaxSizeDE"!]
        [!VAR "MaxSizeDE" = "$ArraySize"!]
      [!ENDIF!]
    [!ELSEIF "$DataTypeSize = 4"!]
      [!VAR "ArraySize" = "num:integer((./DemDataElementDataSize + 3) div 4)"!]
      [!IF "$ArraySize > $MaxSizeDE"!]
        [!VAR "MaxSizeDE" = "$ArraySize"!]
      [!ENDIF!]
    [!ENDIF!]
  [!ENDLOOP!]
  [!IF "(as:modconf('Dem')[1]/DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_2011')"!]
    [!LOOP "DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalCSDataElementClass']"!]
      [!IF "node:exists(./DemDataElementArraySize)"!]
        [!VAR "ArraySize" = "num:integer(./DemDataElementArraySize)"!]
      [!ELSE!][!//
        [!VAR "ArraySize" = "1"!]
      [!ENDIF!]
      [!IF "$ArraySize > $MaxSizeDE"!]
        [!VAR "MaxSizeDE" = "$ArraySize"!]
      [!ENDIF!]
    [!ENDLOOP!]
  [!ENDIF!]
#if (defined DEM_MAX_SIZE_EXT_DE)
#error DEM_MAX_SIZE_EXT_DE already defined
#endif
/** \brief Maximum array size for a DataElement */
#define DEM_MAX_SIZE_EXT_DE     [!"num:integer($MaxSizeDE)"!]U
[!ENDIF!]



#if (defined DEM_SR_SUPPORT)
#error DEM_SR_SUPPORT already defined
#endif
/* !LINKSTO dsn.Dem.SRFunctionality.Support.Macro,1 */
/** \brief Switch, indicating if sender receiver interface is enabled */
[!IF "(node:existsAndTrue(DemGeneral/DemRteUsage)) and (node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalSRDataElementClass']))"!]
  [!WS "0"!]#define DEM_SR_SUPPORT                         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_SR_SUPPORT                        STD_OFF
[!ENDIF!]

/*------------------[DTC configuration]-------------------------------------*/

#if (defined DEM_NO_DTC)
#error DEM_NO_DTC already defined
#endif
/** \brief No DTC (neither UDS, OBD nor J1939) configured for event */
#define DEM_NO_DTC                 0U

#if (defined DEM_NO_DTC_FUNCTIONAL_UNIT)
#error DEM_NO_DTC_FUNCTIONAL_UNIT already defined
#endif
/** \brief No DTC functional unit configured for event */
#define DEM_NO_DTC_FUNCTIONAL_UNIT 0U

/*------------------[General]-----------------------------------------------*/

#if (defined DEM_VERSION_INFO_API)
#error DEM_VERSION_INFO_API already defined
#endif
/** \brief Switch, indicating if Version Info is activated for Dem */
[!IF "node:existsAndTrue(DemGeneral/DemVersionInfoApi)"!]
  [!WS "0"!]#define DEM_VERSION_INFO_API                  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_VERSION_INFO_API                  STD_OFF
[!ENDIF!]

#if (defined DEM_CALIBRATION_SUPPORT)
#error DEM_CALIBRATION_SUPPORT already defined
#endif
/** \brief Switch for calibration support */
/* !LINKSTO dsn.Dem.Calibration.Support.Macro,1 */
[!IF "$CalibrationSupport = 'true'"!]
  [!WS "0"!]#define DEM_CALIBRATION_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CALIBRATION_SUPPORT STD_OFF
[!ENDIF!]

#if (defined DEM_CALIBRATION_WITHOUTEVCOMB_SUPPORT)
#error DEM_CALIBRATION_WITHOUTEVCOMB_SUPPORT already defined
#endif
/** \brief Switch for calibration support without event combination */
[!IF "$CalibrationWithoutEvCombSupport = 'true'"!]
  [!WS "0"!]#define DEM_CALIBRATION_WITHOUTEVCOMB_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CALIBRATION_WITHOUTEVCOMB_SUPPORT STD_OFF
[!ENDIF!]

#if (defined DEM_CALIBRATION_WITHEVCOMB_SUPPORT)
#error DEM_CALIBRATION_WITHEVCOMB_SUPPORT already defined
#endif
/** \brief Switch for calibration support with event combination */
[!IF "$CalibrationWithEvCombSupport = 'true'"!]
  [!WS "0"!]#define DEM_CALIBRATION_WITHEVCOMB_SUPPORT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CALIBRATION_WITHEVCOMB_SUPPORT STD_OFF
[!ENDIF!]

[!IF "$CalibrationWithoutEvCombSupport = 'true'"!]
  [!VAR "ConsistentFFSize" = "'true'"!]
[!ELSE!][!//
  [!VAR "ConsistentFFSize" = "'false'"!]
[!ENDIF!]

#if (defined DEM_POSITIVE_RESPONSE_NO_FFCLASSES)
#error DEM_POSITIVE_RESPONSE_NO_FFCLASSES already defined
#endif
/** \brief Switch for positive response when event has no FF assigned
 ** (disabled through calibration) */
/* !LINKSTO dsn.Dem.Calibration.NoFFClass.PositiveResponse,1 */
[!IF "$CalibrationWithoutEvCombSupport = 'true'"!]
  [!WS "0"!]#define DEM_POSITIVE_RESPONSE_NO_FFCLASSES   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_POSITIVE_RESPONSE_NO_FFCLASSES   STD_OFF
[!ENDIF!]

#if (defined DEM_CONSISTENT_FF_SIZE_SUPPORT)
#error DEM_CONSISTENT_FF_SIZE_SUPPORT already defined
#endif
/** \brief Switch for consistent FF size */
/* !LINKSTO dsn.Dem.Storage.ConsistentFFSize.Support,1 */
#define DEM_CONSISTENT_FF_SIZE_SUPPORT   [!//
  [!IF "$ConsistentFFSize = 'true'"!]STD_ON[!ELSE!]STD_OFF[!ENDIF!]


[!INDENT "0"!]
  [!IF "$ConsistentFFSize = 'true'"!]
    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryPrimary)"!]
      [!VAR "MaxFFSizePrimary" = "DemGeneral/DemMaxSizeFreezeFrameEntryPrimary"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizePrimary" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_PRIMARY)
    #error DEM_CONSISTENT_FF_SIZE_PRIMARY already defined
    #endif
    /** \brief Consistent size of primary FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_PRIMARY      [!"num:i($MaxFFSizePrimary)"!]U

    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntrySecondary)"!]
      [!VAR "MaxFFSizeSecondary" = "DemGeneral/DemMaxSizeFreezeFrameEntrySecondary"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizeSecondary" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_SECONDARY)
    #error DEM_CONSISTENT_FF_SIZE_SECONDARY already defined
    #endif
    /** \brief Consistent size of primary FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_SECONDARY    [!"num:i($MaxFFSizeSecondary)"!]U

    [!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryMirror)"!]
      [!VAR "MaxFFSizeMirror" = "DemGeneral/DemMaxSizeFreezeFrameEntryMirror"!]
    [!ELSE!][!//
      [!VAR "MaxFFSizeMirror" = "0"!]
    [!ENDIF!]
    #if (defined DEM_CONSISTENT_FF_SIZE_MIRROR)
    #error DEM_CONSISTENT_FF_SIZE_MIRROR already defined
    #endif
    /** \brief Consistent size of mirror FFs */
    /* !LINKSTO dsn.Dem.Storage.ConsistentFFSize,1 */
    #define DEM_CONSISTENT_FF_SIZE_MIRROR       [!"num:i($MaxFFSizeMirror)"!]U

  [!ENDIF!]
[!ENDINDENT!]

#if (defined DEM_COMMON_OPERATION_CYCLE_SUPPORT)
#error DEM_COMMON_OPERATION_CYCLE_SUPPORT already defined
#endif
/** \brief Switch for common operation cycle support */
/* !LINKSTO dsn.Dem.CommonOperationCycle.Support.Macro,1 */
[!IF "($CommonOperationCycleEnabled = 'true') and ($CalibrationWithoutEvCombSupport = 'true')"!]
  [!WS "0"!]#define DEM_COMMON_OPERATION_CYCLE_SUPPORT    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_COMMON_OPERATION_CYCLE_SUPPORT    STD_OFF
[!ENDIF!]

#if (defined DEM_AGINGALLOWED_CONVENIENT_CALIBRATION)
#error DEM_AGINGALLOWED_CONVENIENT_CALIBRATION already defined
#endif
/** \brief Switch to enable a convenient way of aging allowed calibration */
/* !LINKSTO dsn.Dem.Calibration.AgingAllowedConvenient.Macro,1 */
#define DEM_AGINGALLOWED_CONVENIENT_CALIBRATION     [!//
[!IF "(node:existsAndTrue(DemGeneral/DemAgingAllowedSeperateFlag)) and ($CalibrationWithoutEvCombSupport = 'true')"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE)
#error DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE already defined
#endif
/** \brief Switch, indicating whether Dem_SetOperationCycleState() will consider or not the untested cyles */
#define DEM_AGING_REQUIRES_TESTED_CYCLE_SET_OPERATION_CYCLE_STATE  [!//
[!IF "node:existsAndTrue(DemGeneral/DemAgingRequiresTestedCycleSetOperationCycleState)"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE)
#error DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE already defined
#endif
/** \brief Switch, indicating whether Dem_SetAgingCycleState() will consider or not the untested cyles */
#define DEM_AGING_REQUIRES_TESTED_CYCLE_SET_AGING_CYCLE_STATE      [!//
[!IF "node:existsAndTrue(DemGeneral/DemAgingRequiresTestedCycleSetAgingCycleState)"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT)
#error DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT already defined
#endif
/** \brief Switch, indicating whether aging process should start only after healing is finished */
#define DEM_AGING_BASED_ON_HEALING_COMPLETION_SUPPORT  [!//
[!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:existsAndTrue(DemEventClass/DemAgingAllowed)]) and (node:existsAndTrue(DemGeneral/DemAgingBasedOnHealingCompletionSupport))"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_CB_TRIG_ON_EVDAT_ASR403)
#error DEM_CB_TRIG_ON_EVDAT_ASR403 already defined
#endif
/** \brief Switch, indicating whether EventDataChanged callback triggering behavior
 ** will be done according to ASR4.0.3 or or to ASR4.2.1 */
/* !LINKSTO dsn.Dem.CallbackEventDataChangedASR403.Macro,1 */
[!IF "node:existsAndTrue(DemGeneral/DemCallbackEventDataChangedASR403Behaviour)"!]
  [!WS "0"!]#define DEM_CB_TRIG_ON_EVDAT_ASR403    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CB_TRIG_ON_EVDAT_ASR403    STD_OFF
[!ENDIF!]

#if (defined DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT)
#error DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT already defined
#endif
/** \brief Switch, indicating whether Dem_OpCycleProcessCycleStart() will trigger
 ** EventStatusChanged/DTCStatusChanged callback. */
/* !LINKSTO dsn.Dem.DemCallbackEventStatusChangedOpCycStartSupport.Macro,1 */
#define DEM_CB_EVST_CHANGED_OPCYC_START_SUPPORT  [!//
[!IF "node:existsAndTrue(DemGeneral/DemCallbackEventStatusChangedOpCycStartSupport)"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_NO_SUPPRESSION)
#error DEM_NO_SUPPRESSION already defined
#endif
#define DEM_NO_SUPPRESSION  0U

#if (defined DEM_DTC_SUPPRESSION)
#error DEM_DTC_SUPPRESSION already defined
#endif
#define DEM_DTC_SUPPRESSION  1U

#if (defined DEM_SUPPRESSION_SUPPORT)
#error DEM_SUPPRESSION_SUPPORT already defined
#endif
/** \brief Switch for DTC suppression support */
#define DEM_SUPPRESSION_SUPPORT           [!"DemGeneral/DemSuppressionSupport"!]

#if (defined DEM_NO_AVAILABILITY)
#error DEM_NO_AVAILABILITY already defined
#endif
#define DEM_NO_AVAILABILITY  0U

#if (defined DEM_EVENT_AVAILABILITY)
#error DEM_EVENT_AVAILABILITY already defined
#endif
#define DEM_EVENT_AVAILABILITY  1U

#if (defined DEM_AVAILABILITY_SUPPORT)
#error DEM_AVAILABILITY_SUPPORT already defined
#endif
/** \brief Switch for dynamic event availability support */
#define DEM_AVAILABILITY_SUPPORT          [!"DemGeneral/DemAvailabilitySupport"!]

#if (defined DEM_EVENT_DISABLING_SUPPORT)
#error DEM_EVENT_DISABLING_SUPPORT already defined
#endif
/** \brief Switch for DTC availability support */
[!IF "($CalibrationSupport = 'true') or ($AvailabilitySupport = 'true')"!]
  [!WS "0"!]#define DEM_EVENT_DISABLING_SUPPORT           STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_EVENT_DISABLING_SUPPORT           STD_OFF
[!ENDIF!]

#if (defined DEM_CLEAR_DTC_OF_DISABLED_EVENTS )
#error DEM_CLEAR_DTC_OF_DISABLED_EVENTS  already defined
#endif
/** \brief Switch to support clearing of DTCs for disabled events */
[!IF "node:existsAndTrue(DemGeneral/DemClearDTCOfDisabledEvents)"!]
  [!WS "0"!]#define DEM_CLEAR_DTC_OF_DISABLED_EVENTS            STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_CLEAR_DTC_OF_DISABLED_EVENTS            STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE )
#error DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE  already defined
#endif
/** \brief Maximum number of events to be cleared per
 ** Dem_MainFunction() cycle on a ClearDTC request */
#define DEM_MAX_NUM_CLEAR_EVENTS_PER_CYCLE       [!"num:integer(DemGeneral/DemMaxNumberClearEventsPerCycle)"!]U

#if (defined DEM_DTC_STATUS_AVAILABILITY_MASK)
#error DEM_DTC_STATUS_AVAILABILITY_MASK already defined
#endif
/** \brief DTC status availability mask */
#define DEM_DTC_STATUS_AVAILABILITY_MASK    [!"num:integer(DemGeneral/DemDtcStatusAvailabilityMask)"!]U

#if (defined DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT)
#error DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT already defined
#endif

[!VAR "NrOfTFStoragePerEventFlagsSetOnTrue" = "0"!][!//
[!VAR "NrOfTFStoragePerEventFlagsSetOnFalse" = "0"!][!//
[!VAR "NrOfEvents" = "0"!][!//
[!LOOP "util:distinct(node:order(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*, 'DemEventId'))"!][!//
  [!VAR "NrOfEvents" = "$NrOfEvents + 1"!][!//
  [!IF "(node:exists(DemStatusBitStorageTestFailedPerEvent))"!][!//
    [!INDENT "4"!]
    [!IF "node:existsAndTrue(DemStatusBitStorageTestFailedPerEvent)"!][!//
      [!VAR "NrOfTFStoragePerEventFlagsSetOnTrue" = "$NrOfTFStoragePerEventFlagsSetOnTrue + 1"!][!//
    [!ELSE!][!//
      [!VAR "NrOfTFStoragePerEventFlagsSetOnFalse" = "$NrOfTFStoragePerEventFlagsSetOnFalse + 1"!][!//
    [!ENDIF!]
    [!ENDINDENT!]
  [!ENDIF!]
[!ENDLOOP!]

/** \brief macro is enabled only when all the events
 ** do not have same value */
[!IF "( ( ($NrOfTFStoragePerEventFlagsSetOnTrue > '0')         and
          ($NrOfTFStoragePerEventFlagsSetOnTrue < $NrOfEvents) and
          (node:existsAndFalse(DemGeneral/DemStatusBitStorageTestFailed))
        )
        or
        ( ($NrOfTFStoragePerEventFlagsSetOnFalse > '0')         and
          ($NrOfTFStoragePerEventFlagsSetOnFalse < $NrOfEvents) and
          (node:existsAndTrue(DemGeneral/DemStatusBitStorageTestFailed))
        )
      )"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF_PER_EVENT_SUPPORT  STD_OFF
[!ENDIF!][!//

#if (defined DEM_STATUS_BIT_STORAGE_TF)
#error DEM_STATUS_BIT_STORAGE_TF already defined
#endif
/** \brief Switch, indicating if permanent storage of the
 ** "TestFailed" status bit is activated */
[!IF "($NrOfTFStoragePerEventFlagsSetOnTrue = $NrOfEvents)"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_ON
[!ELSEIF "($NrOfTFStoragePerEventFlagsSetOnFalse = $NrOfEvents)"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_OFF
[!ELSEIF "node:existsAndTrue(DemGeneral/DemStatusBitStorageTestFailed)"!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STATUS_BIT_STORAGE_TF     STD_OFF
[!ENDIF!][!//

#if (defined DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT)
#error DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT already defined
#endif
/** \brief Switch, indicating if the pending bit is reset or
 ** not while an event memory entry will be displaced */
[!IF "node:existsAndTrue(DemGeneral/DemResetPendingBitOnOverflow)"!]
  [!WS "0"!]#define DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_PENDING_BIT_ON_OVERFLOW_SUPPORT     STD_OFF
[!ENDIF!]

#if (defined DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT)
#error DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT already defined
#endif
/** \brief Switch, indicating if the confirmed bit is reset or
 ** not while an event memory entry will be displaced */
[!IF "node:existsAndTrue(DemGeneral/DemResetConfirmedBitOnOverflow)"!]
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT     STD_OFF
[!ENDIF!]

#if (defined DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE)
#error DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE already defined
#endif
/** \brief Switch, indicating whether the OccOrder shall be updated
 ** at every event entry update */
[!IF "node:existsAndFalse(DemGeneral/DemUpdateOccOrderOnEventEntryUpdate)"!]
  [!WS "0"!]#define DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE    STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_UPDATE_OCCORDER_ON_EVENTENTRY_UPDATE    STD_ON
[!ENDIF!]

#if (defined DEM_USE_PERMANENT_STORAGE)
#error DEM_USE_PERMANENT_STORAGE already defined
#endif
/** \brief Switch, indicating if Permanent storage of event
 ** memory entries in NvM is activated for
 ** Dem */
[!IF "node:exists(DemGeneral/DemNvRamBlockId/eb-list::*)"!]
  [!WS "0"!]#define DEM_USE_PERMANENT_STORAGE             STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_PERMANENT_STORAGE             STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYC_NVSTORAGE)
#error DEM_OPCYC_NVSTORAGE already defined
#endif
/** \brief Switch, indicating if permanent storage of operation cycle entries
 ** to NVRAM is enabled */
[!IF "node:existsAndTrue(DemGeneral/DemOperationCycleStatusStorage)"!]
  [!WS "0"!]#define DEM_OPCYC_NVSTORAGE                   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYC_NVSTORAGE                   STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLESTATE)
#error DEM_OPCYCLESTATE already defined
#endif
/** \brief Macro to get the operation cycle states based on permanent storage
 ** of operation cycle entries to NVRAM */
[!IF "node:existsAndTrue(DemGeneral/DemOperationCycleStatusStorage)"!]
  [!WS "0"!]#define DEM_OPCYCLESTATE             Dem_NvData.OpCycleState
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLESTATE             Dem_OpCycleState
[!ENDIF!]

/* !LINKSTO Dem.OperationCyclePermStorage.FDC,1 */
#if (defined DEM_NUM_DEBOUNCE_COUNTER_PERM)
#error DEM_NUM_DEBOUNCE_COUNTER_PERM already defined
#endif
/** \brief Number of counter debounced events with permanent debounce
 ** counter storage
 **/
[!VAR "NumPermFDCs" = "0"!]
[!LOOP "DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[DemEventClass/DemDebounceAlgorithmClass = 'DemDebounceCounterBased']"!]
  [!IF "node:existsAndTrue(./DemEventClass/DemDebounceAlgorithmClass/eb-choice::*[1]/DemDebounceCounterStorage)"!]
    [!VAR "NumPermFDCs" = "$NumPermFDCs + 1"!][!//
  [!ENDIF!]
[!ENDLOOP!]
#define DEM_NUM_DEBOUNCE_COUNTER_PERM  [!"num:integer($NumPermFDCs)"!]U

/* !LINKSTO dsn.Dem.FDCTriggerDebounceAlgorithm,1 */
#if (defined DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR)
#error DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR already defined
#endif
/** \brief Macro to get the the support for freeze/reset for time-based and
 ** frequency-based debouncing and counter-based reset behavior via non-fulfilled enable
 ** conditions and disabled DTCSettings.
 ** STD_ON: If at least one event is configured with counter-based RESET behavior or
 ** time/frequency-based debouncing and DemDebounceBehavior is set to RESET/FREEZE.
 **/
#define DEM_USE_TRIGGER_DEBOUNCE_BEHAVIOR [!//
[!IF "count( DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass/DemDebounceAlgorithmClass[
             (node:name(.) = 'DemDebounceCounterBased' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_FREEZE') or
             (node:name(.) = 'DemDebounceTimeBase' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_CONTINUE') or
             (node:name(.) = 'DemDebounceFrequencyBased' and ./DemDebounceBehavior != 'DEM_DEBOUNCE_CONTINUE')] ) > 0"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_INTERNAL_DEBOUNCE_SUPPORT)
#error DEM_INTERNAL_DEBOUNCE_SUPPORT already defined
#endif
/** \brief internal debounce support */
 [!IF "((as:modconf('Dem')[1]/DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI != 'AUTOSAR_2011') or ((as:modconf('Dem')[1]/DemGeneral/DemServiceAPI/DemDefaultASRServiceAPI = 'AUTOSAR_2011') and ((node:existsAndTrue(DemGeneral/DemDebounceCounterBasedSupport)) or
       (node:existsAndTrue(DemGeneral/DemDebounceTimeBasedSupport)) or
       (node:existsAndTrue(DemGeneral/DemDebounceFrequencyBasedSupport)))))"!][!//
#define DEM_INTERNAL_DEBOUNCE_SUPPORT STD_ON
[!ELSE!][!//
#define DEM_INTERNAL_DEBOUNCE_SUPPORT STD_OFF
[!ENDIF!]

#if (defined DEM_NVM_BLOCK_ID_INVALID)
#error DEM_NVM_BLOCK_ID_INVALID already defined
#endif
/** \brief NvM block Id does not exist as it is not configured */
#define DEM_NVM_BLOCK_ID_INVALID      0U

[!IF "node:exists(DemGeneral/DemNvRamBlockId/eb-list::*)"!]
  [!INDENT "0"!]
    [!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refexists(DemDTCClassRef) and node:existsAndTrue(as:ref(DemDTCClassRef)/DemImmediateNvStorage)]) or
          (node:existsAndTrue(DemGeneral/DemImmediateStorageInternalEvents)) or (DemGeneral/DemClearDTCBehavior != 'DEM_CLRRESP_VOLATILE')"!]
      [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_DEFAULT']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]

      [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_PRIMARY']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]


      [!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass[DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY'])"!]
        [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_MIRROR']"!]
          [!CALL "GET_NVM_BLOCK_ID"!][!//
        [!ENDSELECT!]
      [!ELSE!]
        #if (defined DEM_NVM_BLOCK_ID_MIRROR)
        #error DEM_NVM_BLOCK_ID_MIRROR already defined
        #endif
        /** \brief Invalid block Id for Dem mirror block as
         ** no event using mirror memory is configured */
        #define DEM_NVM_BLOCK_ID_MIRROR    DEM_NVM_BLOCK_ID_INVALID
      [!ENDIF!]

      [!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEventClass[DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY'])"!]
        [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_SECONDARY']"!]
          [!CALL "GET_NVM_BLOCK_ID"!][!//
        [!ENDSELECT!]
      [!ELSE!]
        #if (defined DEM_NVM_BLOCK_ID_SECONDARY)
        #error DEM_NVM_BLOCK_ID_SECONDARY already defined
        #endif
        /** \brief Invalid block Id for Dem secondary block as
         ** no event using secondary memory is configured */
          #define DEM_NVM_BLOCK_ID_SECONDARY DEM_NVM_BLOCK_ID_INVALID
        [!ENDIF!]
    [!ELSE!][!/* no immediate non-volatile storage usage */!][!//
      [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_DEFAULT']"!]
        [!CALL "GET_NVM_BLOCK_ID"!][!//
      [!ENDSELECT!]
    [!ENDIF!]
  [!ENDINDENT!]
[!ENDIF!]

[!INDENT "0"!]
  [!IF "node:exists(DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.) = 'DEM_NVM_BLOCK_ID_PERMANENT'])"!]
    [!SELECT "DemGeneral/DemNvRamBlockId/eb-list::*[as:name(.)='DEM_NVM_BLOCK_ID_PERMANENT']"!]
      [!CALL "GET_NVM_BLOCK_ID"!][!//
    [!ENDSELECT!]
  [!ELSE!]
    #if (defined DEM_NVM_BLOCK_ID_PERMANENT)
    #error DEM_NVM_BLOCK_ID_PERMANENT already defined
    #endif
    /** \brief Invalid block Id for Dem permanent block as permanent memory is not configured */
    #define DEM_NVM_BLOCK_ID_PERMANENT DEM_NVM_BLOCK_ID_INVALID
  [!ENDIF!]
[!ENDINDENT!]

/** \brief Maximum number of events over all memory sources */
[!VAR "SupportedEventMemories" = "0"!]
[!VAR "MaximumNumberOfEventsInMemories" = "0"!]
[!/* check for primary origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntryPrimary > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 0)"!]
  [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntryPrimary"!]
[!ENDIF!]
[!/* check for secondary origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntrySecondary > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 1)"!]
  [!IF "number(DemGeneral/DemMaxNumberEventEntrySecondary) > $MaximumNumberOfEventsInMemories"!]
    [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntrySecondary"!]
  [!ENDIF!]
[!ENDIF!]
[!/* check for mirror origin */!][!//
[!IF "DemGeneral/DemMaxNumberEventEntryMirror > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 2)"!]
  [!IF "number(DemGeneral/DemMaxNumberEventEntryMirror) > $MaximumNumberOfEventsInMemories"!]
    [!VAR "MaximumNumberOfEventsInMemories" = "DemGeneral/DemMaxNumberEventEntryMirror"!]
  [!ENDIF!]
[!ENDIF!]
[!IF "DemGeneral/DemMaxNumberEventEntryPermanent > 0"!]
  [!VAR "SupportedEventMemories" = "bit:bitset($SupportedEventMemories, 3)"!]
  [!/* the ordered reporting of DTCs is not applicable for permanent event memory */!][!//
[!ENDIF!]

#if (defined DEM_MAX_NUM_ORDERED_EVENT_IDS)
#error DEM_MAX_NUM_ORDERED_EVENT_IDS already defined
#endif
[!/* !LINKSTO dsn.Dem.ReportingOrderDTC.NumOrderedEventIds,2 */!][!//
/** \brief Array size for ordered output of filtered DTCs */
#define DEM_MAX_NUM_ORDERED_EVENT_IDS [!"num:integer($MaximumNumberOfEventsInMemories)"!]U

#if (defined DEM_TYPE_OF_ORIGIN_SUPPORTED)
#error DEM_TYPE_OF_ORIGIN_SUPPORTED already defined
#endif
/** \brief Supported origin types
 **
 ** This macro is only exported and not used internally.
 ** It is derived from ::DEM_MAX_NUMBER_EVENT_ENTRY_PRI,
 ** ::DEM_MAX_NUMBER_EVENT_ENTRY_SEC, ::DEM_MAX_NUMBER_EVENT_ENTRY_MIR, and
 ** ::DEM_MAX_NUMBER_EVENT_ENTRY_PER.
 **
 ** \note Macro name is still existing for compatibility reasons with AR2.1.
 **/
#define DEM_TYPE_OF_ORIGIN_SUPPORTED [!"num:integer($SupportedEventMemories)"!]U

#if (defined DEM_DEV_ERROR_DETECT)
#error DEM_DEV_ERROR_DETECT already defined
#endif
/* !LINKSTO Dem.ASR40.SWS_Dem_00113,1 */
/** \brief Switch, indicating if development error detection is activated for
 ** Dem */
[!IF "node:existsAndTrue(DemGeneral/DemDevErrorDetect)"!]
  [!WS "0"!]#define DEM_DEV_ERROR_DETECT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEV_ERROR_DETECT         STD_OFF
[!ENDIF!]

#if (defined DEM_DET_RUNTIME_CHECK)
#error DEM_DET_RUNTIME_CHECK already defined
#endif
/* !LINKSTO Dem.DetReport.RuntimeErrors,1 */
/** \brief Switch, indicating if runtime errors check is activated for
 ** Dem */
[!IF "node:existsAndTrue(DemGeneral/DemDetRuntimeChecks)"!]
  [!WS "0"!]#define DEM_DET_RUNTIME_CHECK         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DET_RUNTIME_CHECK         STD_OFF
[!ENDIF!]

#if (defined DEM_TYPE_OF_DTC_SUPPORTED)
#error DEM_TYPE_OF_DTC_SUPPORTED already defined
#endif
/** \brief Returned DTC translation format by Dem_GetTranslationType()
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_TYPE_OF_DTC_SUPPORTED    [!"DemGeneral/DemTypeOfDTCSupported"!]

#if (defined DEM_DCM_ENABLED)
#error DEM_DCM_ENABLED already defined
#endif
/** \brief Switch, indicating whether Dcm module should be a part of Dem */
[!IF "node:existsAndTrue(DemGeneral/DemDcmUsage)"!]
  [!WS "0"!]#define DEM_DCM_ENABLED              STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DCM_ENABLED              STD_OFF
[!ENDIF!]

#if (defined DEM_GET_DTCBYOCCURRENCETIME_SUPPORT)
#error DEM_GET_DTCBYOCCURRENCETIME_SUPPORT already defined
#endif
/** \brief Switch, indicating the existence of the functionality provided
 **  by Dem_GetDTCByOccurrenceTime() and the existence of the function itself
 **  to the Dcm module.
 **/
[!IF "node:existsAndTrue(DemGeneral/DemGetDTCByOccurrenceTimeSupport)"!]
  [!WS "0"!]#define DEM_GET_DTCBYOCCURRENCETIME_SUPPORT      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_GET_DTCBYOCCURRENCETIME_SUPPORT      STD_OFF
[!ENDIF!]

#if (defined DEM_STORE_INTERNAL_EVENTS)
#error DEM_STORE_INTERNAL_EVENTS already defined
#endif
/** \brief Switch, indicating whether DTC=0 means event storage disabled */
[!IF "node:existsAndTrue(DemGeneral/DemStoreInternalEvents)"!]
  [!WS "0"!]#define DEM_STORE_INTERNAL_EVENTS       STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_STORE_INTERNAL_EVENTS       STD_OFF
[!ENDIF!]

#if (defined DEM_TRIGGER_FIM_REPORTS)
#error DEM_TRIGGER_FIM_REPORTS already defined
#endif
/** \brief Switch, indicating if notification to FiM is activated for Dem */
[!IF "node:existsAndTrue(DemGeneral/DemTriggerFiMReports)"!]
  [!WS "0"!]#define DEM_TRIGGER_FIM_REPORTS      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_TRIGGER_FIM_REPORTS      STD_OFF
[!ENDIF!]

#if (defined DEM_SUPPORT_FIM_ON_FDC_TRESHOLD)
#error DEM_SUPPORT_FIM_ON_FDC_TRESHOLD already defined
#endif
/** \brief Switch, indicating if FiM support for FDC threshold is activated for Dem */
[!IF "node:existsAndTrue(DemGeneral/DemSupportFiMFDCThreshold)"!]
  [!WS "0"!]#define DEM_SUPPORT_FIM_ON_FDC_TRESHOLD      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_SUPPORT_FIM_ON_FDC_TRESHOLD      STD_OFF
[!ENDIF!]

#if (defined DEM_TRIGGER_DCM_REPORTS)
#error DEM_TRIGGER_DCM_REPORTS already defined
#endif
/** \brief Switch, indicating if notification to Dcm is activated for Dem */
[!IF "node:existsAndTrue(DemGeneral/DemTriggerDcmReports)"!]
  [!WS "0"!]#define DEM_TRIGGER_DCM_REPORTS      STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_TRIGGER_DCM_REPORTS      STD_OFF
[!ENDIF!]

#if (defined DEM_USE_DYNAMIC_DTCS)
#error DEM_USE_DYNAMIC_DTCS already defined
#endif
/** \brief Macro for Enabling/Disabling dynamic DTC fetching */
[!IF "node:exists(DemGeneral/DemCalloutDynamicDTCFnc)"!]
  [!WS "0"!]#define DEM_USE_DYNAMIC_DTCS   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_DYNAMIC_DTCS   STD_OFF
[!ENDIF!]

#if (defined DEM_EVCOMB_DISABLED)
#error DEM_EVCOMB_DISABLED already defined
#endif
/** \brief Macro used when no event combination is supported. */
#define DEM_EVCOMB_DISABLED                  0x00U

#if (defined DEM_EVCOMB_TYPE1)
#error DEM_EVCOMB_TYPE1  already defined
#endif
/** \brief Event combination is available and combined DTCs are stored/updated
    in a single event memory entry. */
#define DEM_EVCOMB_TYPE1                     0x01U

#if (defined DEM_EVENT_COMBINATION_SUPPORT)
#error DEM_EVENT_COMBINATION_SUPPORT already defined
#endif
/** \brief Macro for Enabling/Disabling event combination support. */
#define DEM_EVENT_COMBINATION_SUPPORT   [!"DemGeneral/DemEventCombinationSupport"!]

#if (defined DEM_SEM_SUPPORT)
#error DEM_SEM_SUPPORT already defined
#endif
/** \brief Macro for Enabling/Disabling security event support. */
/* !LINKSTO dsn.Dem.Sem.Availability,1 */
[!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[DemEventKind = 'DEM_EVENT_KIND_SEV'])"!][!//
  [!WS "0"!]#define DEM_SEM_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_SEM_SUPPORT   STD_OFF
[!ENDIF!][!//

[!IF "DemGeneral/DemEventCombinationSupport = 'DEM_EVCOMB_TYPE1'"!][!//
#if (defined DEM_NUMBER_OF_DTCS)
#error DEM_NUMBER_OF_DTCS already defined
#endif
[!/* !LINKSTO dsn.Dem.EventCombination.Encapsulation,1 */!]
/** \brief Define the number of DTCs available when event combination is activated. */
#define DEM_NUMBER_OF_DTCS   [!"num:integer($DemNbOfDTCClasses)"!]U

#if (defined DEM_NUM_CMB_EVENTS)
#error DEM_NUM_CMB_EVENTS already defined
#endif
/** \brief Define the number of combined events. */
#define DEM_NUM_CMB_EVENTS   [!"num:integer($DemNbOfCmbEvents)"!]U
[!ENDIF!][!//

#if (defined DEM_NUM_CMB_DTCS)
#error DEM_NUM_CMB_DTCS already defined
#endif
/** \brief Define the number of combined DTCs.
 **
 ** This define will be present always in order to know if events are combined.
 ** Could be that event combination is configured and no events are combined.
 **/
#define DEM_NUM_CMB_DTCS   [!"num:integer($DemNbOfCmbDTCs)"!]U

#if (defined DEM_IDENTICAL_OBD_DTC_AVAILABLE)
#error DEM_IDENTICAL_OBD_DTC_AVAILABLE already defined
#endif
/** \brief Switch, indicating if there exists events with identical OBD DTC */
[!VAR "ListObdDTCs" = "''"!][!//
[!VAR "IdentObdDTCs" = "'STD_OFF'"!][!//
[!LOOP "DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refvalid(DemDTCClassRef)]"!][!//
  [!IF "node:exists(as:ref(./DemDTCClassRef)/DemObdDTC)"!][!//
    [!VAR "ObdDTC" = "num:integer(as:ref(./DemDTCClassRef)/DemObdDTC)"!][!//
    [!IF "not(contains($ListObdDTCs, concat(' ', $ObdDTC)))"!][!//
      [!VAR "ListObdDTCs" = "concat($ListObdDTCs, ' ', $ObdDTC)"!][!//
    [!ELSE!][!//
      [!VAR "IdentObdDTCs" = "'STD_ON'"!][!//
      [!BREAK!][!//
    [!ENDIF!][!//
  [!ENDIF!][!//
[!ENDLOOP!][!//
#define DEM_IDENTICAL_OBD_DTC_AVAILABLE  [!"$IdentObdDTCs"!]

#if (defined DEM_INIT_MONITOR_REENABLED_SUPPORT)
#error DEM_INIT_MONITOR_REENABLED_SUPPORT already defined
#endif
 /** \brief Macro for Enabling/Disabling support for InitMonitorReason DEM_INIT_MONITOR_REENABLED */
[!IF "node:existsAndTrue(DemGeneral/DemCallbackInitMForEReenabledSupport)"!]
  [!WS "0"!]#define DEM_INIT_MONITOR_REENABLED_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_INIT_MONITOR_REENABLED_SUPPORT   STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE)
#error DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE already defined
#endif
/* !LINKSTO Dem.ControlDTCSetting.InitMonitorRE.Config,1 */
/** \brief Maximum number of CallbackInitMonitorForEvent calls per scheduling. */
#define DEM_MAX_NUM_INIT_MONITOR_PER_CYCLE    [!"num:integer(DemGeneral/DemMaxHandledInitMonitorReenabledPerScheduling)"!]U

#if (defined DEM_USE_EVENT_DISPLACEMENT)
#error DEM_USE_EVENT_DISPLACEMENT already defined
#endif
/** \brief Switch, indicating if event displacement support is activated for
 ** Dem */
[!IF "node:existsAndTrue(DemGeneral/DemEventDisplacementSupport)"!]
  [!WS "0"!]#define DEM_USE_EVENT_DISPLACEMENT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_USE_EVENT_DISPLACEMENT   STD_OFF
[!ENDIF!]

[!/* !LINKSTO Dem.EventDisplacement.TNCTOC.Config,1 */!][!//
#if (defined DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC)
#error DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC already defined
#endif
/** \brief Switch, indicating if TNCTOC event displacement extension is
 ** activated */
[!IF "node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementCriterionTNCTOC)"!]
  [!WS "0"!]#define DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_EVENT_DISPLACEMENT_CRITERION_TNCTOC STD_OFF
[!ENDIF!]

[!/* !LINKSTO Dem.ECUC_Dem_00796,1 */!][!//
#if (defined DEM_OBD_EVENT_DISPLACEMENT)
#error DEM_OBD_EVENT_DISPLACEMENT already defined
#endif
/** \brief Switch, indicating if OBD event displacement behavior is
 ** activated */
[!IF "node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDEventDisplacement)"!]
  [!WS "0"!]#define DEM_OBD_EVENT_DISPLACEMENT STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_EVENT_DISPLACEMENT STD_OFF
[!ENDIF!]

[!/* !LINKSTO dsn.Dem.Displacement.DemUseAdvancedEventDisplacement,1 */!][!//
#if (defined DEM_USE_ADVANCED_EVENT_DISPLACEMENT)
#error DEM_USE_ADVANCED_EVENT_DISPLACEMENT already defined
#endif
[!/* !LINKSTO VCC_DEM_007_Req192v1,1, dsn.Dem.Displacement.Advanced,1 */!][!//
[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementStrategy = 'DEM_DISPLACEMENT_FULL') and
      (node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementSupport)) and
      num:integer(count(DemConfigSet/eb-list::*/DemAdvDisplacementPassiveTableLine/eb-list::*)) > 0"!]
  [!WS "0"!]/** \brief advanced displacement used **/
  [!WS "0"!]#define DEM_USE_ADVANCED_EVENT_DISPLACEMENT STD_ON
  [!/* generate defines for number of configured passive table lines */!]
  [!INDENT "0"!]
      [!/* !LINKSTO dsn.Dem.Displacement.DemNumOfPassiveTableLines,1 */!][!//
      /** \brief define the number of passive table lines **/
      #if (defined DEM_NUM_OF_PASSIVE_TABLE_LINES)
      #error DEM_NUM_OF_PASSIVE_TABLE_LINES already defined
      #endif
      #define DEM_NUM_OF_PASSIVE_TABLE_LINES [!"num:integer(count(DemConfigSet/eb-list::*/DemAdvDisplacementPassiveTableLine/eb-list::*))"!]U
  [!ENDINDENT!]
  [!/* generate defines for number of configured passive refs per line */!][!//
  [!/* !LINKSTO dsn.Dem.Displacement.DemNumOfPassiveEventRefs,1 */!]
  [!VAR "NumOfLines" = "0"!]
  [!VAR "NumOfPassiveRefs" = "0"!]
  [!WS "0"!]/** \brief define the number of passive event refs per passive table line **/[!//
  [!LOOP "DemConfigSet/eb-list::*/DemAdvDisplacementPassiveTableLine/eb-list::*"!]
    [!INDENT "0"!]

        #if (defined DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!])
        #error DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!] already defined
        #endif
        #define DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumOfLines)"!] [!"num:integer(count(./DemPassiveEventRefs/eb-list::*))"!]U
      [!VAR "NumOfLines" = "$NumOfLines + 1"!]
    [!ENDINDENT!]
  [!ENDLOOP!]

  [!INDENT "0"!]
  [!/* !LINKSTO dsn.Dem.Displacement.DemAdvDisplacementOcc1Limit.Macro,1 */!][!//
  /* number of DemAdvDisplacementOcc1Limit */
  #if (defined DEM_ADV_PASSIVE_OCC1_LIMIT)
  #error DEM_ADV_PASSIVE_OCC1_LIMIT already defined
  #endif
  #define DEM_ADV_PASSIVE_OCC1_LIMIT  [!"DemGeneral/DemAdvDisplacementOcc1Limit"!]U
  [!ENDINDENT!]
[!ELSE!][!//
     [!WS "0"!]/** \brief advanced displacement not used **/
     [!WS "0"!]#define DEM_USE_ADVANCED_EVENT_DISPLACEMENT STD_OFF
[!ENDIF!]

#if (defined DEM_DISPLACEMENT_NONE)
#error DEM_DISPLACEMENT_NONE already defined
#endif
/** \brief Event memory entry displacement is disabled */
#define DEM_DISPLACEMENT_NONE                  0x00U

#if (defined DEM_DISPLACEMENT_PRIO_OCC)
#error DEM_DISPLACEMENT_PRIO_OCC already defined
#endif
/** \brief Event memory entry displacement is enabled, by consideration of
 ** priority and occurrence (but without active/passive status) */
#define DEM_DISPLACEMENT_PRIO_OCC              0x01U

#if (defined DEM_DISPLACEMENT_FULL)
#error DEM_DISPLACEMENT_FULL already defined
#endif
/** \brief Event memory entry displacement is enabled, by consideration of
 ** priority active/passive status, and occurrence */
#define DEM_DISPLACEMENT_FULL                  0x02U

#if (defined DEM_EVENT_DISPLACEMENT_STRATEGY)
#error DEM_EVENT_DISPLACEMENT_STRATEGY already defined
#endif
/** \brief Switch, indicating which displacement strategy is followed */
#define DEM_EVENT_DISPLACEMENT_STRATEGY [!"DemGeneral/DemEventDisplacementStrategy"!]

#ifndef DEM_STATUS_BIT_AGING_AND_DISPLACEMENT
/** \brief The "TestFailedSinceLastClear" status bits are reset to 0, if
 ** aging or displacement applies (like done for the "ConfirmedDTC" status
 ** bits) */
#define DEM_STATUS_BIT_AGING_AND_DISPLACEMENT  0x00U
#endif

#ifndef DEM_STATUS_BIT_NORMAL
/** \brief The aging and displacement has no impact on the
 ** "TestFailedSinceLastClear" status bits */
#define DEM_STATUS_BIT_NORMAL                  0x01U
#endif

#if (defined DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR)
#error DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR already defined
#endif
/** \brief Switch, indicating if the aging and displacement mechanism shall be
 ** applied to the "TestFailedSinceLastClear" status bits */
#define DEM_STATUS_BIT_HANDLING_TESTFAILEDSINCELASTCLEAR \
  [!"DemGeneral/DemStatusBitHandlingTestFailedSinceLastClear"!]

#if (defined DEM_CLRRESP_VOLATILE)
#error DEM_CLRRESP_VOLATILE already defined
#endif
#define DEM_CLRRESP_VOLATILE            0U

#if (defined DEM_CLRRESP_NONVOLATILE_TRIGGER)
#error DEM_CLRRESP_NONVOLATILE_TRIGGER already defined
#endif
#define DEM_CLRRESP_NONVOLATILE_TRIGGER 1U

#if (defined DEM_CLRRESP_NONVOLATILE_FINISH)
#error DEM_CLRRESP_NONVOLATILE_FINISH already defined
#endif
#define DEM_CLRRESP_NONVOLATILE_FINISH  2U

#if (defined DEM_CLEAR_DTC_BEHAVIOR)
#error DEM_CLEAR_DTC_BEHAVIOR already defined
#endif
/** \brief Behaviour of ClearDTC */
#define DEM_CLEAR_DTC_BEHAVIOR  [!"DemGeneral/DemClearDTCBehavior"!]

#if (defined DEM_OBD_DEP_SEC_ECU)
#error DEM_OBD_DEP_SEC_ECU already defined
#endif
#define DEM_OBD_DEP_SEC_ECU      0U

#if (defined DEM_OBD_MASTER_ECU)
#error DEM_OBD_MASTER_ECU already defined
#endif
#define DEM_OBD_MASTER_ECU       1U

#if (defined DEM_OBD_NO_OBD_SUPPORT)
#error DEM_OBD_NO_OBD_SUPPORT already defined
#endif
#define DEM_OBD_NO_OBD_SUPPORT   2U

#if (defined DEM_OBD_PRIMARY_ECU)
#error DEM_OBD_PRIMARY_ECU already defined
#endif
#define DEM_OBD_PRIMARY_ECU      3U

/* !LINKSTO Dem.ASR42.ECUC_Dem_00698_1,1 */
#if (defined DEM_OBD_Support_Kind)
#error DEM_OBD_Support_Kind already defined
#endif
/* !LINKSTO Dem_OBD_0080,1 */
/** \brief Switch defines OBD support and kind of OBD ECU */
[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport)"!][!//
  [!WS "0"!]#define DEM_OBD_Support_Kind    [!"DemGeneral/DemOBDSupportKind"!]
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_Support_Kind    DEM_OBD_NO_OBD_SUPPORT
[!ENDIF!][!//

#if (defined DEM_OBD_VARIANT_OBD_CLASSIC)
#error DEM_OBD_VARIANT_OBD_CLASSIC already defined
#endif
/** \brief Defines the value used to check that OBD variant
 ** is OBD Classic */
#define DEM_OBD_VARIANT_OBD_CLASSIC 0U

#if (defined DEM_OBD_VARIANT_OBDONUDS)
#error DEM_OBD_VARIANT_OBDONUDS already defined
#endif
/** \brief Defines the value used to check that OBD variant
 ** is OBDonUDS */
#define DEM_OBD_VARIANT_OBDONUDS    1U

#if (defined DEM_OBD_VARIANT_NONE)
#error DEM_OBD_VARIANT_NONE already defined
#endif
/** \brief Defines the value used to check that no OBD variant
 ** is defined */
#define DEM_OBD_VARIANT_NONE      2U

#if (defined DEM_OBD_VARIANT )
#error DEM_OBD_VARIANT  already defined
#endif
/* !LINKSTO Dem.ObdVariant.Config,1 */
/** \brief switch selects the supported OBD variant */
[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport) and (node:exists(DemGeneral/DemObdVariant))"!][!//
  [!WS "0"!]#define DEM_OBD_VARIANT  [!"DemGeneral/DemObdVariant"!]
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_VARIANT     DEM_OBD_VARIANT_NONE
[!ENDIF!][!//

#if (defined DEM_OBDONUDS_COMBINATION_ENABLED )
#error DEM_OBDONUDS_COMBINATION_ENABLED  already defined
#endif
/* !LINKSTO dsn.Dem.OBDonUDS.EventCombination.Support,1 */
[!IF "($OBDonUDSCombination = 'true') and (count(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*/DemEvtCmbCommonParamMaster) > 0)"!]
  [!WS "0"!]#define DEM_OBDONUDS_COMBINATION_ENABLED    STD_ON
[!ELSE!]
  [!WS "0"!]#define DEM_OBDONUDS_COMBINATION_ENABLED    STD_OFF
[!ENDIF!]

/* !LINKSTO Dem.ObdVariantSwitch.Config,1 */
#if (defined DEM_OBD_VARIANT_SELECTABLE)
#error DEM_OBD_VARIANT_SELECTABLE already defined
#endif
/** \brief Switch, indicating if switching of OBD variant is enabled */
[!IF "node:exists(DemGeneral/DemCalloutObdVariantFnc)"!]
  [!WS "0"!]#define DEM_OBD_VARIANT_SELECTABLE   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_VARIANT_SELECTABLE   STD_OFF
[!ENDIF!]

#if (defined DEM_OBD_CLASSIC_SUPPORT)
#error DEM_OBD_CLASSIC_SUPPORT already defined
#endif
/** \brief Macro indicating if OBD Classic features are activated as per SAE J1979 */
#define DEM_OBD_CLASSIC_SUPPORT ( (DEM_OBD_VARIANT == DEM_OBD_VARIANT_OBD_CLASSIC) || \
                                  (DEM_OBD_VARIANT_SELECTABLE == STD_ON) )

#if (defined DEM_OBDONUDS_SUPPORT)
#error DEM_OBDONUDS_SUPPORT already defined
#endif
/** \brief Macro indicating if OBDonUDS features are activated as per SAE J1979-2 */
#define DEM_OBDONUDS_SUPPORT ( (DEM_OBD_VARIANT == DEM_OBD_VARIANT_OBDONUDS) || \
                               (DEM_OBD_VARIANT_SELECTABLE == STD_ON) )

#if (defined DEM_OBD_CLASSIC_FIXED_SLOTS_SUPPORT)
#error DEM_OBD_CLASSIC_FIXED_SLOTS_SUPPORT already defined
#endif
/** \brief Macro indicating if an equal number of event slots are allocated for
 ** the OBD readiness groups in the calibration array Dem_OBDReadinessGroup[] */
[!IF "(DemGeneral/DemReadinessGroupCalibrationConfigKind = 'DEM_NUMBER_OF_SLOTS_COMMON_CONFIG')"!][!//
  [!WS "0"!]#define DEM_OBD_CLASSIC_FIXED_SLOTS_SUPPORT    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_CLASSIC_FIXED_SLOTS_SUPPORT    STD_OFF
[!ENDIF!][!//

#if (defined DEM_NUM_FFPARTS)
#error DEM_NUM_FFPARTS already defined
#endif
/** \brief The Number of freeze frame parts of an event entry
 **   (common + individual or only individual) */
[!IF "(node:refexists(DemGeneral/DemCommonFFDataClassRef)) or
      ( (node:existsAndTrue(DemGeneral/DemDevFreezeFrameSupport)) and
        (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef)) )"!]
  [!WS "0"!]#define DEM_NUM_FFPARTS     2U
[!ELSE!][!//
  [!WS "0"!]#define DEM_NUM_FFPARTS     1U
[!ENDIF!]

[!IF "$CalibrationWithoutEvCombSupport = 'true'"!]
  [!WS "0"!]#define DEM_STATIC
[!ELSE!]
  [!WS "0"!]#define DEM_STATIC  STATIC
[!ENDIF!]

/* !LINKSTO dsn.Dem.ProjectSpecificCustomization.Macro,1 */
#if (defined DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT)
#error DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT already defined
#endif
/** \brief Switch for user defined APIs support */
[!IF "node:existsAndTrue(DemGeneral/DemIncludeProjectSpecificCustomizationSupport)"!]
  [!WS "0"!]#define DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT    STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_PROJECT_SPECIFIC_CUSTOMIZATION_SUPPORT    STD_OFF
[!ENDIF!]

/*-----------------------[Event burst reduction]----------------------------*/
/* !LINKSTO dsn.Dem.EventBurstReduction.MaxPassed,1 */
#if (defined DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING)
#error DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING already defined
#endif
/** \brief The number of passed events handled per Dem_MainFunction call */
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxHandledPassedEventsPerScheduling)"!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING [!"DemGeneral/DemMaxHandledPassedEventsPerScheduling"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_PASSED_EVENTS_PER_SCHEDULING 255U
[!ENDIF!][!//

/* !LINKSTO dsn.Dem.EventBurstReduction.MaxFailed,1 */
#if (defined DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING)
#error DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING already defined
#endif
/** \brief The number of failed events handled per Dem_MainFunction call */
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxHandledFailedEventsPerScheduling)"!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING [!"DemGeneral/DemMaxHandledFailedEventsPerScheduling"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_HANDLED_FAILED_EVENTS_PER_SCHEDULING 255U
[!ENDIF!][!//

[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef)) and
      (node:existsAndTrue(DemGeneral/DemOBDSupport)) and
      (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef))"!]

/*---------------------------[MIL configuration]----------------------------*/

/* !LINKSTO Dem_OBD_0004,1 */
#if (defined DEM_MIL_ID)
#error DEM_MIL_ID already defined
#endif
#define DEM_MIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemMILIndicatorRef)/DemIndicatorID"!]U
[!ENDIF!]

/* !LINKSTO Dem_OBD_0001,2 */
#if (defined DEM_OBD_Support)
#error DEM_OBD_Support already defined
#endif
/** \brief Switch, indicating if OBD functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport)"!]
  [!WS "0"!]#define DEM_OBD_Support         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_Support         STD_OFF
[!ENDIF!]

/*-------------------------[MIL group configuration]------------------------*/

#if (defined DEM_MILGROUP_SUPPORT)
#error DEM_MILGROUP_SUPPORT already defined
#endif
/** \brief Switch, indicating if MIL group functionality is enabled */
[!IF "$NumberOfMILGroups > 0"!]
[!WS "0"!]#define DEM_MILGROUP_SUPPORT   STD_ON
#if (defined DEM_MILGROUP_NUM_GROUP)
#error DEM_MILGROUP_NUM_GROUP already defined
#endif
/** \brief Number of configured MIL groups */
#define DEM_MILGROUP_NUM_GROUP   [!"num:integer($NumberOfMILGroups)"!]U

#if (defined DEM_MILGROUP_GROUP_IDX_INVALID)
#error DEM_MILGROUP_GROUP_IDX_INVALID already defined
#endif
/** \brief Internally used value to indicate that an event does not belong
 ** to a MIL group */
#define DEM_MILGROUP_GROUP_IDX_INVALID   DEM_MILGROUP_NUM_GROUP

#if (defined DEM_MILGROUP_NUM_EVENTS)
#error DEM_MILGROUP_NUM_EVENTS already defined
#endif
/** \brief Number of all events assigned to any MIL group */
#define DEM_MILGROUP_NUM_EVENTS   [!"num:integer($NumberOfEventsInMILGroups)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MILGROUP_SUPPORT   STD_OFF
[!ENDIF!]

/*-------------------------[MAR events configuration]------------------------*/

#if (defined DEM_MAR_SUPPORT)
#error DEM_MAR_SUPPORT already defined
#endif
/** \brief Switch, indicating if Monitor Activity Ratio feature is enabled */
[!IF "$MARSupport = 'true'"!]
  [!CALL "CREATE_MAR_EVENTS_LIST"!]
  [!WS "0"!]#define DEM_MAR_SUPPORT            STD_ON

#if (defined DEM_NUM_MAR_EVENTS)
#error DEM_NUM_MAR_EVENTS already defined
#endif
/** \brief Number of events that have EDRN 0x93 configured */
#define DEM_NUM_MAR_EVENTS         [!"num:integer($MAREventsNum)"!]U

#if (defined DEM_NUM_MAR_SINGLE_EVENTS)
#error DEM_NUM_MAR_SINGLE_EVENTS already defined
#endif
/** \brief Number of non-combined events that have EDRN 0x93 configured */
#define DEM_NUM_MAR_SINGLE_EVENTS  [!"num:integer($MARNonCmbEventsNum)"!]U

#if (defined DEM_NUM_MAR_DTCS)
#error DEM_NUM_MAR_DTCS already defined
#endif
/** \brief Number of DTCs that have EDRN 0x93 configured */
#define DEM_NUM_MAR_DTCS           [!"num:integer($MARNonCmbDTCsNum + $MARCmbDTCsNum)"!]U

#if (defined DEM_NUM_MAR_CMB_DTCS)
#error DEM_NUM_MAR_CMB_DTCS already defined
#endif
/** \brief Number of combined DTCs that have EDRN 0x93 configured */
#define DEM_NUM_MAR_CMB_DTCS       [!"num:integer($MARCmbDTCsNum)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAR_SUPPORT   STD_OFF
[!ENDIF!]

#if (defined DEM_RESET_PERFORMANCE_COUNTERS_ENABLED)
#error DEM_RESET_PERFORMANCE_COUNTERS_ENABLED already defined
#endif
/** \brief Switch, indicating if Dem_ResetPerformanceCounters() API is supported */
[!IF "(node:existsAndTrue(DemGeneral/DemResetPerformanceCountersAPI))"!][!//
  [!WS "0"!]#define DEM_RESET_PERFORMANCE_COUNTERS_ENABLED   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_PERFORMANCE_COUNTERS_ENABLED   STD_OFF
[!ENDIF!]

/*-------------------------[OBDonUDS freeze frame]---------------------------*/
[!VAR "OBDonUDSFreezeFrameSize" = "0"!]
[!VAR "OBDonUDSFreezeFrameNumOfDIDs" = "0"!]
#if (defined DEM_OBDONUDS_FF_SUPPORT)
#error DEM_OBDONUDS_FF_SUPPORT already defined
#endif
/** \brief Switch, indicating if OBDonUDS freeze frame support is enabled */
[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef)) and
      (node:existsAndTrue(DemGeneral/DemOBDSupport)) and
      ( ((node:exists(DemGeneral/DemObdVariant)) and (DemGeneral/DemObdVariant = 'DEM_OBD_VARIANT_OBDONUDS')) or
        (node:exists(DemGeneral/DemCalloutObdVariantFnc)) ) and
      (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef))"!]
  [!WS "0"!]#define DEM_OBDONUDS_FF_SUPPORT         STD_ON
[!SELECT "node:ref(DemGeneral/DemUDSOBDFreezeFrameClassRef)"!]
  [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
[!ENDSELECT!]
[!VAR "OBDonUDSFreezeFrameSize" = "$SizeOfFreezeFrameClass"!]
[!VAR "OBDonUDSFreezeFrameNumOfDIDs" = "count(as:ref(as:modconf('Dem')[1]/DemGeneral/DemUDSOBDFreezeFrameClassRef)/DemDidClassRef/eb-list::*)"!]

#if (defined DEM_NUM_OF_DIDS_IN_OBDONUDS_FF)
#error DEM_NUM_OF_DIDS_IN_OBDONUDS_FF already defined
#endif
/** \brief number of segments in OBDonUDS freeze frame */
  [!WS "0"!]#define DEM_NUM_OF_DIDS_IN_OBDONUDS_FF         [!"num:integer($OBDonUDSFreezeFrameNumOfDIDs)"!]U

#if (defined DEM_SIZE_OBDONUDS_OBD_FF)
#error DEM_SIZE_OBDONUDS_OBD_FF already defined
#endif
/** \brief size of stored OBDonUDS freeze frame data */
  [!WS "0"!]#define DEM_SIZE_OBDONUDS_OBD_FF         [!"num:integer($OBDonUDSFreezeFrameSize)"!]U

#if (defined DEM_TRIGGER_ON_TFTOC)
#error DEM_TRIGGER_ON_TFTOC already defined
#endif
/** \brief The last OBDonUDS freeze frame occurrence is updated on the TFTOC
 ** UDSstatus bit transition from 0 to 1.**/
#define DEM_TRIGGER_ON_TFTOC         0U

#if (defined DEM_TRIGGER_ON_TFTOC_AND_TF)
#error DEM_TRIGGER_ON_TFTOC_AND_TF already defined
#endif
/** \brief The last OBDonUDS freeze frame occurrence is updated on the
 ** transitions from 0 to 1 of the TFTOC and TF UDS status bits.**/
#define DEM_TRIGGER_ON_TFTOC_AND_TF         1U

#if (defined DEM_OBDONUDS_FF_UPDATE_TRIGGER)
#error DEM_OBDONUDS_FF_UPDATE_TRIGGER already defined
#endif
/** \brief The trigger for the update of the last occurrence of the OBDonUDS freeze frame.*/
[!IF "DemGeneral/DemOBDonUDSFreezeFrameUpdateTrigger = 'DEM_TRIGGER_ON_TFTOC_AND_TF'"!]
#define DEM_OBDONUDS_FF_UPDATE_TRIGGER         DEM_TRIGGER_ON_TFTOC_AND_TF
[!ELSE!][!//
#define DEM_OBDONUDS_FF_UPDATE_TRIGGER         DEM_TRIGGER_ON_TFTOC
[!ENDIF!][!//

[!ELSE!][!//
  [!WS "0"!]#define DEM_OBDONUDS_FF_SUPPORT         STD_OFF

[!ENDIF!][!//
/*---------------------------[J1939 configuration]----------------------------*/

#if (defined DEM_J1939_SUPPORT)
#error DEM_J1939_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemJ1939Support)"!]
  [!WS "0"!]#define DEM_J1939_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_SUPPORT         STD_OFF
[!ENDIF!][!//

[!IF "(node:existsAndTrue(DemGeneral/DemJ1939Support))"!][!//
[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef)) and
  (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef))"!]
#if (defined DEM_AWIL_ID)
#error DEM_AWIL_ID already defined
#endif
/** \brief Amber Warning Indicator Lamp ID */
#define DEM_AWIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemAmberWarningLampIndicatorRef)/DemIndicatorID"!]U
[!ENDIF!][!//

[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef)) and
  (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef))"!]
#if (defined DEM_PIL_ID)
#error DEM_PIL_ID already defined
#endif
/** \brief Protect Indicator Lamp ID */
#define DEM_PIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemProtectLampIndicatorRef)/DemIndicatorID"!]U
[!ENDIF!][!//

[!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef)) and
  (node:refvalid(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef))"!]
#if (defined DEM_RSIL_ID)
#error DEM_RSIL_ID already defined
#endif
/** \brief Red Stop Indicator Lamp ID */
#define DEM_RSIL_ID [!"as:ref(as:modconf('Dem')[1]/DemGeneral/DemRedStopLampIndicatorRef)/DemIndicatorID"!]U
[!ENDIF!][!//
[!ENDIF!][!//

#if (defined DEM_J1939_READING_DTC_SUPPORT)
#error DEM_J1939_READING_DTC_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Reading DTC functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939ReadingDtcSupport)"!]
  [!WS "0"!]#define DEM_J1939_READING_DTC_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READING_DTC_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_RATIO_SUPPORT)
#error DEM_J1939_RATIO_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Ratio functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939RatioSupport)"!]
  [!WS "0"!]#define DEM_J1939_RATIO_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_RATIO_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS1_SUPPORT)
#error DEM_J1939_READINESS1_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Readiness1 functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939Readiness1Support)"!]
  [!WS "0"!]#define DEM_J1939_READINESS1_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS1_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS2_SUPPORT)
#error DEM_J1939_READINESS2_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Readiness2 functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939Readiness2Support)"!]
  [!WS "0"!]#define DEM_J1939_READINESS2_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS2_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_READINESS3_SUPPORT)
#error DEM_J1939_READINESS3_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Readiness3 functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939Readiness3Support)"!]
  [!WS "0"!]#define DEM_J1939_READINESS3_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_READINESS3_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_CLEAR_DTC_SUPPORT)
#error DEM_J1939_CLEAR_DTC_SUPPORT already defined
#endif
/** \brief Switch, indicating if J1939 Clear DTC functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939ClearDTCSupport)"!]
  [!WS "0"!]#define DEM_J1939_CLEAR_DTC_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_CLEAR_DTC_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_FREEZEFRAME_SUPPORT)
#error DEM_J1939_FREEZEFRAME_SUPPORT already defined
#endif
/** \brief Macro for Enabling/Disabling J1939 freeze frames functionality */
[!IF "node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemGeneralJ1939/DemJ1939FreezeFrameSupport) "!]
  [!WS "0"!]#define DEM_J1939_FREEZEFRAME_SUPPORT   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_FREEZEFRAME_SUPPORT   STD_OFF
[!ENDIF!]

#if (defined DEM_J1939_EXPANDED_FREEZEFRAME_SUPPORT)
#error DEM_J1939_EXPANDED_FREEZEFRAME_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 expanded freeze frames functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939ExpandedFreezeFrameSupport)"!]
  [!WS "0"!]#define DEM_J1939_EXPANDED_FREEZEFRAME_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_EXPANDED_FREEZEFRAME_SUPPORT         STD_OFF
[!ENDIF!][!//

#if (defined DEM_J1939_DM31_SUPPORT)
#error DEM_J1939_DM31_SUPPORT already defined
#endif
 /** \brief Switch, indicating if J1939 DM31 functionalities are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemGeneralJ1939/DemJ1939Dm31Support)"!]
  [!WS "0"!]#define DEM_J1939_DM31_SUPPORT         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_J1939_DM31_SUPPORT         STD_OFF
[!ENDIF!][!//

/*---------------------[IUMPR function support ]----------------------------*/
/* !LINKSTO Dem.Config.IumprFunctionsEnabled,1 */
#if (defined DEM_IUMPR_FUNCTIONS_ENABLED)
#error DEM_IUMPR_FUNCTIONS_ENABLED already defined
#endif
/* Switch, indicating whether IUMPR related functions are enabled. */
[!IF "node:existsAndTrue(DemGeneral/DemOBDIumprFunctionsEnabled)"!]
  [!WS "0"!]#define DEM_IUMPR_FUNCTIONS_ENABLED         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_IUMPR_FUNCTIONS_ENABLED         STD_OFF
[!ENDIF!]

#if (defined DEM_OBD_COMPLIANCY_ENABLED)
#error DEM_OBD_COMPLIANCY_ENABLED already defined
#endif
[!IF "node:exists(DemGeneral/DemGeneralOBD/DemOBDCompliancy)"!]
  [!WS "0"!]#define DEM_OBD_COMPLIANCY_ENABLED         STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_COMPLIANCY_ENABLED         STD_OFF
[!ENDIF!]

/*---------------------[OBD centralized PID handling]-----------------------*/

#if (defined DEM_OBD_CENTRALIZED_PID31_HANDLING)
#error DEM_OBD_CENTRALIZED_PID31_HANDLING already defined
#endif
 /** \brief Switch, indicating if PID$31 is calculated Dem internally (if set to 'false')
  ** or returned as 0 always (if set to 'true')*/
[!IF "node:existsAndFalse(DemGeneral/DemGeneralOBD/DemOBDCentralizedPID31Handling)"!]
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID31_HANDLING         STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID31_HANDLING         STD_ON
[!ENDIF!]

#if (defined DEM_OBD_CENTRALIZED_PID21_HANDLING)
#error DEM_OBD_CENTRALIZED_PID21_HANDLING already defined
#endif
 /** \brief Switch, indicating if PID$21 is calculated Dem internally (if set to 'false')
  ** or returned as 0 always (if set to 'true')*/
[!IF "node:existsAndFalse(DemGeneral/DemGeneralOBD/DemOBDCentralizedPID21Handling)"!]
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID21_HANDLING         STD_OFF
[!ELSE!][!//
  [!WS "0"!]#define DEM_OBD_CENTRALIZED_PID21_HANDLING         STD_ON
[!ENDIF!]

[!VAR "NumOfBytesInOBDFF" = "0"!]
[!VAR "MaxDataElementOffsetInPID" = "0"!]
[!VAR "MaxNumOfBytesInPidClass" = "0"!]
[!IF "node:existsAndTrue(DemGeneral/DemOBDSupport)"!]
/*-----------------------[OBD PID identifier ]------------------------------*/
  [!LOOP "DemConfigSet/eb-list::*/DemPidClass/eb-list::*"!]
    [!INDENT "0"!]

      #if (defined DEM_OBDFF_PID_[!"as:name(.)"!])
      #error DEM_OBDFF_PID_[!"as:name(.)"!] already defined
      #endif
      /** \brief PID Identifier of [!"as:name(.)"!] */
      /* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_PID_NameOfPid,1 */
      #define DEM_OBDFF_PID_[!"as:name(.)"!] [!"num:integer(DemPidIdentifier)"!]U
    [!ENDINDENT!]
  [!ENDLOOP!]

  [!INDENT "0"!]
    /*------------------[Size of OBD FF in bytes]----------------------------*/
      [!LOOP "DemConfigSet/eb-list::*/DemPidClass/eb-list::*"!]
        [!VAR "NumOfBytesInPidClass" = "0"!]
        [!VAR "DataElementOffsetInPID" = "0"!]
        [!LOOP "DemPidDataElement/eb-list::*/DemPidDataElementClassRef"!]
          [!CALL "GET_SIZE_OF_DATA_ELEMENT"!][!//
          [!VAR "DataElementOffsetInPID" = "$NumOfBytesInPidClass"!]
          [!VAR "NumOfBytesInOBDFF" = "$NumOfBytesInOBDFF + $SizeOfDataElement"!]
          [!VAR "NumOfBytesInPidClass" = "$NumOfBytesInPidClass + $SizeOfDataElement"!]
        [!ENDLOOP!]
        [!IF "$MaxDataElementOffsetInPID < $DataElementOffsetInPID"!]
          [!VAR "MaxDataElementOffsetInPID" = "$DataElementOffsetInPID"!]
        [!ENDIF!]
        [!IF "$MaxNumOfBytesInPidClass < $NumOfBytesInPidClass"!]
          [!VAR "MaxNumOfBytesInPidClass" = "$NumOfBytesInPidClass"!]
        [!ENDIF!]
      [!ENDLOOP!]
      #if (defined DEM_SIZE_OBDFF_DATA)
      #error DEM_SIZE_OBDFF_DATA already defined
      #endif
      /* !LINKSTO dsn.Dem.OBD.DEM_SIZE_OBDFF_DATA,2 */
      [!IF "$OBDonUDSFreezeFrameSize > $NumOfBytesInOBDFF"!]
      #define DEM_SIZE_OBDFF_DATA [!"num:integer($OBDonUDSFreezeFrameSize)"!]U
      [!ELSE!]
      #define DEM_SIZE_OBDFF_DATA [!"num:integer($NumOfBytesInOBDFF)"!]U
      [!ENDIF!]

      #if (defined DEM_SIZE_CLASSIC_OBD_FF )
      #error DEM_SIZE_CLASSIC_OBD_FF  already defined
      #endif
      #define DEM_SIZE_CLASSIC_OBD_FF [!"num:integer($NumOfBytesInOBDFF)"!]U
  [!ENDINDENT!]
[!ENDIF!]

#if (defined DEM_MAX_SIZE_PID_CLASS)
#error DEM_MAX_SIZE_PID_CLASS already defined
#endif
/** \brief Maximum size of a PID class.
 ** This value is derived from the size of the configured PID DataElements for each PID. */
#define DEM_MAX_SIZE_PID_CLASS    [!"num:i($MaxNumOfBytesInPidClass)"!]U

#if (defined DEM_MAX_INDEX_PID_CLASS)
#error DEM_MAX_INDEX_PID_CLASS already defined
#endif
/** \brief Maximum index of a PID class.
 ** This value is derived from the index of the configured PID DataElements for each PID. */
#define DEM_MAX_INDEX_PID_CLASS    [!"num:i($MaxDataElementOffsetInPID)"!]U

/*-----[Indexes to access PID0D and PID1F within data element class]--------*/

[!IF "(node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) != 'DemInternalDataElementClass']))"!]
  [!INDENT "0"!]
  [!VAR "OBDTimeRequired" = "'false'"!]
  [!VAR "VehicleSpeedRequired" = "'false'"!]
  [!VAR "NumberOfElements" = "(count(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) != 'DemInternalDataElementClass']))"!]
  [!VAR "PID1F_DataIndex" = "$NumberOfElements"!]
  [!VAR "PID0D_DataIndex" = "$NumberOfElements"!]
  [!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDTimeSinceEngineStart)"!]
    [!VAR "OBDTimeRequired" = "'true'"!]
    [!VAR "OBDTimeReference" = "as:name(as:ref(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDTimeSinceEngineStart))"!]
  [!ENDIF!]
  [!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDInputVehicleSpeed)"!]
    [!VAR "VehicleSpeedRequired" = "'true'"!]
    [!VAR "VehicleSpeedReference" = "as:name(as:ref(as:modconf('Dem')[1]/DemGeneral/DemGeneralOBD/DemOBDInputVehicleSpeed))"!]
  [!ENDIF!]
  [!VAR "Index" = "0"!]
  [!IF "node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalCSDataElementClass'])"!]
    [!IF "($OBDTimeRequired = 'true') or ($VehicleSpeedRequired = 'true')"!]
      [!LOOP "DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalCSDataElementClass']"!]
        [!IF "$VehicleSpeedRequired = 'true'"!]
          [!IF "as:name(.) = $VehicleSpeedReference"!]
            [!VAR "PID0D_DataIndex" = "num:integer($Index)"!]
            [!VAR "VehicleSpeedRequired" = "'false'"!]
            [!IF "$OBDTimeRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!IF "$OBDTimeRequired = 'true'"!]
          [!IF "as:name(.) = $OBDTimeReference"!]
            [!VAR "PID1F_DataIndex" = "num:integer($Index)"!]
            [!VAR "OBDTimeRequired" = "'false'"!]
            [!IF "$VehicleSpeedRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!VAR "Index" = "$Index + 1"!]
      [!ENDLOOP!]
    [!ENDIF!]
  [!ENDIF!]
  [!IF "node:exists(DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalSRDataElementClass'])"!]
    [!IF "($OBDTimeRequired = 'true') or ($VehicleSpeedRequired = 'true')"!]
      [!LOOP "DemGeneral/DemDataElementClass/eb-choice::*[1]/eb-list::*[node:name(.) = 'DemExternalSRDataElementClass']"!]
        [!IF "$VehicleSpeedRequired = 'true'"!]
          [!IF "as:name(.) = $VehicleSpeedReference"!]
            [!VAR "PID0D_DataIndex" = "num:integer($Index)"!]
            [!VAR "VehicleSpeedRequired" = "'false'"!]
            [!IF "$OBDTimeRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!IF "$OBDTimeRequired = 'true'"!]
          [!IF "as:name(.) = $OBDTimeReference"!]
            [!VAR "PID1F_DataIndex" = "num:integer($Index)"!]
            [!VAR "OBDTimeRequired" = "'false'"!]
            [!IF "$VehicleSpeedRequired = 'false'"!]
              [!BREAK!]
            [!ENDIF!]
          [!ENDIF!]
        [!ENDIF!]
        [!VAR "Index" = "$Index + 1"!]
      [!ENDLOOP!]
    [!ENDIF!]
  [!ENDIF!]
  [!IF "$PID0D_DataIndex != $NumberOfElements"!]
    #if (defined DEM_OBD_INDEX_PID0D)
    #error DEM_OBD_INDEX_PID0D already defined
    #endif
    [!WS "0"!]#define DEM_OBD_INDEX_PID0D [!"num:integer($PID0D_DataIndex)"!]U
  [!ENDIF!]

  [!IF "$PID1F_DataIndex != $NumberOfElements"!]
    #if (defined DEM_OBD_INDEX_PID1F)
    #error DEM_OBD_INDEX_PID1F already defined
    #endif
    [!WS "0"!]#define DEM_OBD_INDEX_PID1F [!"num:integer($PID1F_DataIndex)"!]U
  [!ENDIF!]
  [!ENDINDENT!]
[!ENDIF!]

#if (defined DEM_MAINCYCLE_TICKS_PER_SECOND)
#error DEM_MAINCYCLE_TICKS_PER_SECOND already defined
#endif
#define DEM_MAINCYCLE_TICKS_PER_SECOND [!"num:integer(1 div (DemGeneral/DemTaskTime))"!]U

/*------------------[Extended data configuration]---------------------------*/

/* Symbolic names of configured extended data record numbers */
[!LOOP "DemGeneral/DemExtendedDataRecordClass/eb-list::*"!]
  [!INDENT "0"!]

    #if (defined DEM_EDS_NUM_[!"as:name(.)"!])
    #error DEM_EDS_NUM_[!"as:name(.)"!] already defined
    #endif
    /** \brief Symbolic name of extended data [!"as:name(.)"!] */
    #define DEM_EDS_NUM_[!"as:name(.)"!] [!"num:integer(DemExtendedDataRecordNumber)"!]U
  [!ENDINDENT!]
[!ENDLOOP!]

/* DEM_TRIGGER_<...> macros used for DEM_EXTENDED_DATA_CAPTURE are
 * defined in section 'Freeze frame configuration' */

#if (defined DEM_EXTENDED_DATA_CAPTURE)
#error DEM_EXTENDED_DATA_CAPTURE already defined
#endif
/** \brief Type of extended data capture trigger
 **
 ** This parameter defines the point in time, when the extended data
 ** collection is done for the initial event memory entry.
 **/
#define DEM_EXTENDED_DATA_CAPTURE     [!"DemGeneral/DemExtendedDataCapture"!]

#if (defined DEM_NUM_EVENT_PRIORITIES)
#error DEM_NUM_EVENT_PRIORITIES already defined
#endif
[!CALL "GET_NUMBER_OF_EVENT_PRIORITIES"!]
/** \brief Used for defining size of Dem_ExternalPrioValue array */
#define DEM_NUM_EVENT_PRIORITIES      [!"num:integer($NumberOfPriorities)"!]

/*------------------[Fault confirmation configurations]---------------------*/

#if (defined DEM_NUM_FAILURECYCLES)
#error DEM_NUM_FAILURECYCLES already defined
#endif
/** \brief Number of fault confirmation configurations */
#define DEM_NUM_FAILURECYCLES [!"num:integer($EventFailureClassIdx)"!]U

#if (defined DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION)
#error DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION already defined
#endif
/** \brief Switch, indicating support for fault confirmation without event memory entry */
[!IF "( (node:existsAndFalse(DemGeneral/DemResetConfirmedBitOnOverflow)) and (num:integer($EventFailureClassIdx) > 0) )"!]
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION     STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_RESET_CONFIRMED_BIT_ON_OVERFLOW_SUPPORT_FAULT_CONFIRMATION     STD_OFF
[!ENDIF!]

#if (defined DEM_STATUS_COUNTER_SIZE)
#error DEM_STATUS_COUNTER_SIZE already defined
#endif
/** \brief Number of status counters in ::Dem_NvData
 ** per non-combined event with fault confirmation enabled */
[!VAR "StatusCounterSize" = "0"!]
[!IF "node:existsAndFalse(DemGeneral/DemResetConfirmedBitOnOverflow)"!]
  [!VAR "StatusCounterSize" = "count((DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[not(node:exists(DemEvtCmbCommonParamMaster)) and node:exists(DemEventClass/DemEventFailureCycleCounterThreshold)]))"!]
[!ENDIF!]
#define DEM_STATUS_COUNTER_SIZE   [!"num:integer($StatusCounterSize)"!]U

/*------------------[Memory size configuration]-----------------------------*/

/* !LINKSTO dsn.Dem.ErrorQueueOpt,1 */
#if (defined DEM_BSW_ERROR_BUFFER_SIZE)
#error DEM_BSW_ERROR_BUFFER_SIZE already defined
#endif
/** \brief Maximal number of error-queue entries
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_BSW_ERROR_BUFFER_SIZE [!"num:integer(DemGeneral/DemBswErrorBufferSize)"!]U

[!//
[!/* Number of PIDs to be stored in OBD freeze frame */!][!//
[!VAR "NumOfPidInOBDFF" = "num:integer(count(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemPidClass/eb-list::*))"!]
[!//
[!VAR "MaxFFSizePrimary" = "-1"!]
[!VAR "MaxFFSizeSecondary" = "-1"!]
[!VAR "MaxFFSizeMirror" = "-1"!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryPrimary)"!]
  [!VAR "MaxFFSizePrimary" = "DemGeneral/DemMaxSizeFreezeFrameEntryPrimary"!]
[!ENDIF!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntrySecondary)"!]
  [!VAR "MaxFFSizeSecondary" = "DemGeneral/DemMaxSizeFreezeFrameEntrySecondary"!]
[!ENDIF!]
[!IF "node:exists(DemGeneral/DemMaxSizeFreezeFrameEntryMirror)"!]
  [!VAR "MaxFFSizeMirror" = "DemGeneral/DemMaxSizeFreezeFrameEntryMirror"!]
[!ENDIF!]
[!/* --- Size of common freeze frame */!][!//
[!VAR "CommonFFName" = "''"!]
[!VAR "CommonFFSize" = "0"!]
[!VAR "CommonFFNumDid" = "0"!]
[!IF "node:refexists(DemGeneral/DemCommonFFDataClassRef)"!]
  [!VAR "CommonFFName" = "as:name(as:ref(DemGeneral/DemCommonFFDataClassRef))"!]
  [!SELECT "node:ref(DemGeneral/DemCommonFFDataClassRef)"!]
    [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
  [!ENDSELECT!]
  [!VAR "CommonFFSize" = "$SizeOfFreezeFrameClass"!]
  [!VAR "CommonFFNumDid" = "$SizeOfFreezeFrameClassNumDid"!]
[!ENDIF!]
[!/* --- Size of common development freeze frame A (DevFF A) */!][!//
[!VAR "CommonDevFFASize" = "0"!]
[!VAR "CommonDevFFANumDid" = "0"!]
[!IF "(node:existsAndTrue(DemGeneral/DemDevFreezeFrameSupport)) and
      (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef))"!]
  [!SELECT "node:ref(DemGeneral/DemCommonFFDataDevAClassRef)"!]
    [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
  [!ENDSELECT!]
  [!VAR "CommonDevFFASize" = "$SizeOfFreezeFrameClass"!]
  [!VAR "CommonDevFFANumDid" = "$SizeOfFreezeFrameClassNumDid"!]
[!ENDIF!]
[!/* --- Create event lists with largest event related data */!][!//
[!VAR "ListPrm" = "''"!]
[!VAR "ListSec" = "''"!]
[!VAR "ListMir" = "''"!]
[!VAR "FFASizeLargest" = "0"!]
[!VAR "FFBSizeLargest" = "0"!]
[!VAR "MaxEventCaptureBufferSize" = "0"!]
[!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameAEntry))"!]
  [!VAR "MaxSizeDevFFA" = "num:integer(DemGeneral/DemMaxSizeDevFreezeFrameAEntry)"!]
[!ENDIF!]
[!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameBEntry))"!]
  [!VAR "MaxSizeDevFFB" = "num:integer(DemGeneral/DemMaxSizeDevFreezeFrameBEntry)"!]
[!ENDIF!]
[!VAR "NumberOfEventsSupportingAging" = "num:integer(count(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:existsAndTrue(DemEventClass/DemAgingAllowed)]))"!]
[!LOOP "DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[not(node:exists(DemEvtCmbCommonParamMaster)) or (node:existsAndTrue(DemEvtCmbCommonParamMaster))]"!]
  [!VAR "IntValSize" = "0"!]
  [!VAR "AgingSupport" = "'false'"!]
  [!IF "(node:existsAndTrue(./DemEventClass/DemAgingAllowed)) or (($CalibrationSupport = 'true') and ($NumberOfEventsSupportingAging > 0))"!]
    [!VAR "AgingSupport" = "'true'"!]
  [!ENDIF!]
  [!IF "$AgingSupport = 'true'"!]
    [!VAR "IntValSize" = "$IntValSize + 1"!]
  [!ENDIF!]
  [!VAR "EDSize" = "0"!]
  [!IF "node:refexists(DemExtendedDataClassRef)"!]
    [!LOOP "as:ref(DemExtendedDataClassRef)/DemExtendedDataRecordClassRef/eb-list::*"!]
      [!LOOP "as:ref(.)/DemDataElementClassRef/eb-list::*"!]
[!/*      internal data elements will not be stored inside ED-area */!][!//
        [!IF "node:name(as:ref(.)) != 'DemInternalDataElementClass' and (node:name(as:ref(.)) != 'DemExternalCSDataElementClass' or node:existsAndFalse(as:ref(.)/DemDataElementCaptureOnRetrieval))"!]
          [!CALL "GET_SIZE_OF_DATA_ELEMENT"!][!//
          [!VAR "EDSize" = "$EDSize + $SizeOfDataElement"!]
        [!ENDIF!]
      [!ENDLOOP!]
    [!ENDLOOP!]
  [!ENDIF!]
[!/* --- regular freeze frames */!][!//
  [!VAR "FFSize" = "0"!]
  [!VAR "NumDid" = "0"!]
  [!VAR "NumFFRecords" = "0"!]
  [!IF "node:refexists(DemFreezeFrameClassRef)"!]
    [!SELECT "node:ref(DemFreezeFrameClassRef)"!]
      [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
    [!ENDSELECT!]
    [!VAR "FFSize" = "$CommonFFSize + $SizeOfFreezeFrameClass"!]
    [!VAR "NumDid" = "$SizeOfFreezeFrameClassNumDid + $CommonFFNumDid"!]
    [!CALL "GET_NUM_FF_RECORDS"!]
  [!ELSEIF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemCommonFFDataClassRef)"!]
    [!VAR "FFSize" = "$CommonFFSize"!]
    [!VAR "NumDid" = "$CommonFFNumDid"!]
    [!CALL "GET_NUM_FF_RECORDS"!]
  [!ENDIF!]
[!/* --- DevFFA */!][!//
  [!VAR "DevFFASize" = "0"!]
  [!VAR "DevFFANumDid" = "0"!][!//
  [!IF "node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemDevFreezeFrameSupport)"!]
    [!IF "node:refexists(DemDevFreezeFrameAClassRef)"!]
      [!SELECT "node:ref(DemDevFreezeFrameAClassRef)"!]
        [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
      [!ENDSELECT!]
      [!VAR "DevFFASize" = "$CommonDevFFASize + $SizeOfFreezeFrameClass"!]
      [!VAR "DevFFANumDid" = "$SizeOfFreezeFrameClassNumDid + $CommonDevFFANumDid"!]
    [!ELSEIF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemCommonFFDataDevAClassRef)"!]
      [!VAR "DevFFASize" = "$CommonDevFFASize"!]
      [!VAR "DevFFANumDid" = "$CommonDevFFANumDid"!]
    [!ENDIF!]
    [!IF "$FFASizeLargest < $DevFFASize"!]
      [!VAR "FFASizeLargest" = "$DevFFASize"!]
    [!ENDIF!]
  [!ENDIF!]
[!//
[!/* --- DevFFB */!][!//
  [!VAR "DevFFBSize" = "0"!]
  [!VAR "DevFFBNumDid" = "0"!]
  [!IF "node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemDevFreezeFrameSupport)"!]
    [!IF "node:refexists(DemDevFreezeFrameBClassRef)"!]
      [!SELECT "node:ref(DemDevFreezeFrameBClassRef)"!]
        [!CALL "GET_SIZE_OF_FREEEZE_FRAME_CLASS"!]
      [!ENDSELECT!]
      [!VAR "DevFFBSize" = "$SizeOfFreezeFrameClass"!]
      [!VAR "DevFFBNumDid" = "$SizeOfFreezeFrameClassNumDid"!]
    [!ENDIF!]
    [!IF "$FFBSizeLargest < $DevFFBSize"!]
      [!VAR "FFBSizeLargest" = "$DevFFBSize"!]
    [!ENDIF!]
  [!ENDIF!]
[!//
  [!IF "$ConsistentFFSize = 'true'"!]
    [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_PRIMARY_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizePrimary"!]
    [!ELSEIF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizeSecondary"!]
    [!ELSEIF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY'"!]
      [!VAR "MaxFFSize" = "$MaxFFSizeMirror"!]
    [!ELSE!][!//
      [!VAR "MaxFFSize" = "0"!]
    [!ENDIF!]
    [!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxSizeDevFreezeFrameAEntry))"!]
      [!IF "($MaxSizeDevFFA) < ($FFASizeLargest)"!]
        [!ERROR!]The largest configured Development Freeze Frame A Class ([!"$FFASizeLargest"!] bytes) is greater than DemMaxSizeDevFreezeFrameAEntry ([!"$MaxSizeDevFFA"!] bytes)[!ENDERROR!]
      [!ELSE!]
        [!VAR "FFASizeLargest" = "$MaxSizeDevFFA"!]
      [!ENDIF!]
    [!ENDIF!]
    [!IF "(node:exists(as:modconf('Dem')[1]/DemGeneral/DemMaxSizeDevFreezeFrameBEntry))"!]
      [!IF "($MaxSizeDevFFB) < ($FFBSizeLargest)"!]
        [!ERROR!]The largest configured Development Freeze Frame B Class ([!"num:integer($FFBSizeLargest)"!] bytes) is greater than DemMaxSizeDevFreezeFrameBEntry ([!"$MaxSizeDevFFB"!] bytes)[!ENDERROR!]
      [!ELSE!]
        [!VAR "FFBSizeLargest" = "$MaxSizeDevFFB"!]
      [!ENDIF!]
    [!ENDIF!]
    [!IF "$FFSize > $MaxFFSize"!]
      [!IF "$MaxFFSize != -1"!]
        [!IF "node:refexists(DemFreezeFrameClassRef)"!]
          [!ERROR!]The size of freeze frame '[!"as:name(as:ref(DemFreezeFrameClassRef))"!]'[!IF "$CommonFFName != ''"!] including common freeze frame '[!"$CommonFFName"!]'[!ENDIF!] ([!"num:integer($FFSize)"!] bytes) is bigger than the maximal allowed size of [!"num:integer($MaxFFSize)"!] bytes. Increase maximal freeze frame size for [!"DemEventClass/DemEventDestination"!].[!ENDERROR!]
        [!ELSE!]
          [!ERROR!]The size of common freeze frame '[!"$CommonFFName"!]' ([!"num:integer($FFSize)"!] bytes) is bigger than the maximal allowed size of [!"num:integer($MaxFFSize)"!] bytes. Increase maximal freeze frame size for [!"DemEventClass/DemEventDestination"!].[!ENDERROR!]
        [!ENDIF!]
      [!ENDIF!]
    [!ELSE!]
[!/* Use configured maximum freeze frame size */!][!//
      [!VAR "FFSize" = "$MaxFFSize"!]
    [!ENDIF!]
  [!ENDIF!]
[!/* Check maximum SizeOfFreezeFrame in Dem_GetSizeOfFreezeFrameSelection */!]
  [!IF "($FFSize != 0)"!]
    [!VAR "SizeOfRegularFreezeFrame" = "$FFSize + (2 * $NumDid) + 2"!]
  [!ELSE!]
    [!VAR "SizeOfRegularFreezeFrame" = "0"!]
  [!ENDIF!]
  [!IF "($DevFFASize != 0)"!]
    [!VAR "SizeOfDevFreezeFrameA" = "$DevFFASize + (2 * $DevFFANumDid) + 2"!]
  [!ELSE!]
    [!VAR "SizeOfDevFreezeFrameA" = "0"!]
  [!ENDIF!]
  [!IF "($DevFFBSize != 0)"!]
    [!VAR "SizeOfDevFreezeFrameB" = "$DevFFBSize + (2 * $DevFFBNumDid) + 2"!]
  [!ELSE!]
    [!VAR "SizeOfDevFreezeFrameB" = "0"!]
  [!ENDIF!]
  [!IF "($NumOfBytesInOBDFF != 0)"!]
    [!VAR "SizeOfOBDFreezeFrame" = "$NumOfBytesInOBDFF + (2 * $NumOfPidInOBDFF) + 2"!]
  [!ELSE!]
    [!VAR "SizeOfOBDFreezeFrame" = "0"!]
  [!ENDIF!]
  [!IF "($OBDonUDSFreezeFrameSize != 0)"!]
    [!VAR "SizeOfOBDonUDSFreezeFrame" = "2 * ($OBDonUDSFreezeFrameSize + (2 * $OBDonUDSFreezeFrameNumOfDIDs) + 2)"!]
  [!ELSE!]
    [!VAR "SizeOfOBDonUDSFreezeFrame" = "0"!]
  [!ENDIF!]
  [!IF "($SizeOfOBDonUDSFreezeFrame > $SizeOfOBDFreezeFrame)"!]
   [!VAR "SizeOfOBDFreezeFrame" = "$SizeOfOBDonUDSFreezeFrame"!]
  [!ENDIF!]
   [!VAR "TotalSizeOfFreezeFrames" = "($SizeOfRegularFreezeFrame * $NumFFRecords) + $SizeOfDevFreezeFrameA + $SizeOfDevFreezeFrameB + $SizeOfOBDFreezeFrame"!]
[!/* !LINKSTO dsn.Dem.FreezeFrameSize.MaxSize,1 */!]
  [!IF "$TotalSizeOfFreezeFrames > 65535"!]
    [!ERROR!]In Dem_GetSizeOfFreezeFrameSelection() the SizeOfFreezeFrame could be 65535 as maximum. In the current configuration of event [!"as:name(.)"!] this size is exceeded! Please reduce the size of referred freeze frame classes, the number of freeze frame records, or disable some freeze frames kindes[!ENDERROR!]
  [!ENDIF!]
[!/* -- J1939 Freeze Frames --*/!][!//
[!VAR "J1939FFSize" = "0"!]
[!IF "node:refexists(DemJ1939FreezeFrameClassRef) and (node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemGeneralJ1939/DemJ1939FreezeFrameSupport))"!]
[!LOOP "as:ref(DemJ1939FreezeFrameClassRef)/DemSPNClassRef/eb-list::*"!]
    [!IF "node:name(as:ref(as:ref(.)/DemSPNDataElementClassRef)) != 'DemInternalDataElementClass'"!]
        [!SELECT "(as:ref(.)/DemSPNDataElementClassRef)"!]
          [!CALL "GET_SIZE_OF_DATA_ELEMENT"!]
          [!VAR "J1939FFSize" = "$J1939FFSize + $SizeOfDataElement"!]
        [!ENDSELECT!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDIF!]
 [!/* Calculate size of the capture buffer used for external data elements */!][!//
  [!VAR "EventCaptureBufferSize" = "num:integer($EDSize + $FFSize + $J1939FFSize)"!]
  [!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameAEntry))"!]
    [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $MaxSizeDevFFA)"!]
  [!ELSE!]
    [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $DevFFASize)"!]
  [!ENDIF!]
  [!IF "(node:exists(DemGeneral/DemMaxSizeDevFreezeFrameBEntry))"!]
    [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $MaxSizeDevFFB)"!]
  [!ELSE!]
    [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $DevFFBSize)"!]
  [!ENDIF!]
  [!IF "( ($CalibrationSupport = 'true') or
          ( (node:exists(as:modconf('Dem')[1]/DemGeneral/DemCalloutObdVariantFnc)) and
            ( (node:refvalid(DemDTCClassRef)) and
              ( (node:exists(as:ref(./DemDTCClassRef)/DemObdDTC)) or (node:exists(as:ref(./DemDTCClassRef)/DemDtcValue3Byte)) )
            )
          ) or
          ( (node:exists(as:modconf('Dem')[1]/DemGeneral/DemObdVariant)) and
            (as:modconf('Dem')[1]/DemGeneral/DemObdVariant = 'DEM_OBD_VARIANT_OBD_CLASSIC') and
            (node:refvalid(DemDTCClassRef)) and
            (node:exists(as:ref(./DemDTCClassRef)/DemObdDTC))
          ) or
          ( (node:exists(as:modconf('Dem')[1]/DemGeneral/DemObdVariant)) and
            (as:modconf('Dem')[1]/DemGeneral/DemObdVariant = 'DEM_OBD_VARIANT_OBDONUDS') and
            (node:refvalid(DemDTCClassRef)) and
            ( ( ($ObdUdsDtcSeparationSupport = 'true') and (node:exists(as:ref(./DemDTCClassRef)/DemDtcValue3Byte)) ) or
              ( ($ObdUdsDtcSeparationSupport = 'false') and (node:exists(as:ref(./DemDTCClassRef)/DemObdDTC)) )
            )
          )
        )"!]
    [!IF "($OBDonUDSFreezeFrameSize > $NumOfBytesInOBDFF)"!]
      [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $OBDonUDSFreezeFrameSize)"!]
    [!ELSE!]
      [!VAR "EventCaptureBufferSize" = "num:integer($EventCaptureBufferSize + $NumOfBytesInOBDFF)"!]
    [!ENDIF!]
  [!ENDIF!]
  [!IF "$MaxEventCaptureBufferSize < $EventCaptureBufferSize"!]
    [!VAR "MaxEventCaptureBufferSize" = "$EventCaptureBufferSize"!]
  [!ENDIF!]
[!/* Calculate Entry Size */!][!//
  [!VAR "EntrySize" = "num:integer($IntValSize + $EDSize + $NumFFRecords * $FFSize + $J1939FFSize)"!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_PRIMARY_MEMORY'"!]
    [!VAR "ListPrm" = "concat($ListPrm, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_SECONDARY_MEMORY'"!]
    [!VAR "ListSec" = "concat($ListSec, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!IF "DemEventClass/DemEventDestination = 'DEM_DTC_ORIGIN_MIRROR_MEMORY'"!]
    [!VAR "ListMir" = "concat($ListMir, ' ', $EntrySize)"!]
  [!ENDIF!]
  [!INDENT "0"!]
    /* [!"DemEventClass/DemEventDestination"!] - Event [!"as:name(.)"!][!//
    [!IF "node:existsAndTrue(DemEvtCmbCommonParamMaster)"!]
      [!WS!]- Combined DTC Master Configuration Event[!//
    [!ENDIF!]
    :
    [!WS "3"!][!//
    [!IF "$AgingSupport = 'true'"!]
      aging counter value [!//
    [!ELSE!]
      no internal values [!//
    [!ENDIF!]
    + [!//
    [!IF "node:refexists(DemExtendedDataClassRef)"!]
      [!"as:name(as:ref(DemExtendedDataClassRef))"!] [!//
    [!ELSE!]
      no extended data [!//
    [!ENDIF!]
    + [!//
    [!IF "node:refexists(DemFreezeFrameClassRef)"!]
      [!"num:integer($NumFFRecords)"!]
      [!WS "2"!] * ([!"as:name(as:ref(DemFreezeFrameClassRef))"!] + [!"$CommonFFName"!]) [!//
    [!ELSE!]
      no freeze frames [!//
    [!ENDIF!]
    = [!"$EntrySize"!] */
  [!ENDINDENT!]
[!ENDLOOP!]
/* entry data sizes (IntVal + ED + Num * FF) of prm memory:
[!WS "2"!][!"$ListPrm"!] */
/* entry data sizes (IntVal + ED + Num * FF) of sec memory:
[!WS "2"!][!"$ListSec"!] */
/* entry data sizes (IntVal + ED + Num * FF) of mir memory:
[!WS "2"!][!"$ListMir"!] */

#if (defined DEM_SIZE_GATE_ENTRY_DATA_PRIMARY)
#error DEM_SIZE_GATE_ENTRY_DATA_PRIMARY already defined
#endif
/** \brief Gate entry size for primary memory
 **
 ** If immediate storage is enabled for any of the events in primary memory
 ** then this size is maximum of the highest primary event memory size
 ** considering IntVal, extended data freeze frames, and J1939 Freeze frame.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListPrm))"!]
  [!VAR "CurEntrySize" = "text:split($ListPrm)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_PRIMARY   [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_SECONDARY)
#error DEM_SIZE_GATE_ENTRY_DATA_SECONDARY already defined
#endif
/** \brief Gate entry size for secondary memory
 **
 ** If immediate storage is enabled for any of the events in secondary memory
 ** then this size is maximum of the highest secondary event memory size
 ** considering IntVal, extended data and freeze frames.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListSec))"!]
  [!VAR "CurEntrySize" = "text:split($ListSec)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_SECONDARY [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_MIRROR)
#error DEM_SIZE_GATE_ENTRY_DATA_MIRROR already defined
#endif
/** \brief Gate entry size for mirror memory
 **
 ** If immediate storage is enabled for any of the events in mirror memory
 ** then this size is maximum of the highest mirror event memory size
 ** considering IntVal, extended data and freeze frames.
 ** If maximum calculated size is 0, then default 1 is used.
 */
[!VAR "MaxEntrySize" = "1"!]
[!FOR "j" = "1" TO "count(text:split($ListMir))"!]
  [!VAR "CurEntrySize" = "text:split($ListMir)[position() = $j]"!]
  [!IF "$MaxEntrySize < $CurEntrySize"!]
    [!VAR "MaxEntrySize" = "$CurEntrySize"!]
  [!ENDIF!]
[!ENDFOR!]
#define DEM_SIZE_GATE_ENTRY_DATA_MIRROR    [!"num:integer($MaxEntrySize)"!]U

#if (defined DEM_SIZE_GATE_ENTRY_DATA_PERMANENT)
#error DEM_SIZE_GATE_ENTRY_DATA_PERMANENT already defined
#endif
/** \brief Gate entry size for permanent memory
 **
 ** As this event memory type is not supported this shall be default 1.
 */
#define DEM_SIZE_GATE_ENTRY_DATA_PERMANENT 1U

#if (defined DEM_SIZE_EXTERNAL_ENTRY_DATA)
#error DEM_SIZE_EXTERNAL_ENTRY_DATA already defined
#endif
/** \brief Macro to determine the maximum combined size for
 ** event related data considering EDSize, FFSize (including
 ** CommonFFName), DevFFASize (including CommonDevFFASize)
 ** and DevFFBSize, J1939-FF, OBD-FF.
 ** In the computation of these mentioned variables the
 ** DemCalibrationSupport variant is taken into consideration.
 */
#define DEM_SIZE_EXTERNAL_ENTRY_DATA   [!"num:integer($MaxEventCaptureBufferSize)"!]U

#if (defined DEM_USE_IMMEDIATE_NV_STORAGE)
#error DEM_USE_IMMEDIATE_NV_STORAGE already defined
#endif
/** \brief Switch, indicating if Immediate storage of event memory entries in
 ** NvM is activated for Dem
 **
 ** This can be the case if any DTC is configured to be stored immediately, or
 ** if ClearDTC behavior is configured to non-volatile triggered or finished.
 */
#define DEM_USE_IMMEDIATE_NV_STORAGE  [!//
[!IF "(node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refexists(DemDTCClassRef) and node:existsAndTrue(as:ref(DemDTCClassRef)/DemImmediateNvStorage)])) or
      (node:existsAndTrue(DemGeneral/DemImmediateStorageInternalEvents)) or (contains(node:value(DemGeneral/DemClearDTCBehavior), 'NONVOLATILE'))"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES)
#error DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES already defined
#endif
/* !LINKSTO Dem.NvStorageEmptyEvMemEntries.Config,1 */
/** \brief Switch, indicating if empty event memory entries will be
 ** initialized in NVRAM
 **
 ** If the restoration of an event memory entry from NvM was not successful,
 ** this switch controls (esp. for ::DEM_USE_IMMEDIATE_NV_STORAGE = ON) if
 ** this entry is initialized with default values during next shutdown.
 */
#define DEM_NV_STORAGE_EMPTY_EVMEM_ENTRIES  [!//
[!IF "not(node:exists(DemGeneral/DemNvStorageEmptyEventMemoryEntries)) or (node:existsAndTrue(DemGeneral/DemNvStorageEmptyEventMemoryEntries))"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

#if (defined DEM_INTERMEDIATE_STORAGE_DTC_STATUS)
#error DEM_INTERMEDIATE_STORAGE_DTC_STATUS already defined
#endif
/* !LINKSTO dsn.Dem.IntermediateNvStorageOfDTCStatus.Support,1 */
/** \brief Switch to indicate intermediate DTC status storage is enabled
 **
 ** The intermediate storage of DTC status is enabled if at least one
 ** DTC has DemImmediateNvStorage set to true or
 ** DemImmediateStorageInternalEvents is true with at least one internal
 ** event.
 **/
[!CALL "GET_INTERMEDIATE_DTC_SIZE"!][!//
#define DEM_INTERMEDIATE_STORAGE_DTC_STATUS    [!//
[!IF "$IntermediateNvStorage = 'true'"!]
  STD_ON
[!ELSE!][!//
  STD_OFF
[!ENDIF!]

[!IF "$IntermediateNvStorage = 'true'"!]
  [!WS "0"!]/* !LINKSTO dsn.Dem.IntermediateNvStorageOfDTCStatus.SizeStorageOrderIdAndDTCStatusMacro,1 */
  [!WS "0"!]#if (defined DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_PRIMARY)
  [!WS "0"!]#error DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_PRIMARY already defined
  [!WS "0"!]#endif
  [!WS "0"!]/** \brief Size of StorageOrderIdAndDTCStatus array in primary memory
  [!WS "1"!] **
  [!WS "1"!] ** This macro defines the size in bytes of the StorageOrderIdAndDTCStatus[]
  [!WS "1"!] ** array in primary event destination.
  [!WS "1"!] ** 0, if no DTC/event is configured with immediate storage for the respective
  [!WS "1"!] ** destination.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + 1, if only non-combined DTCs or internal
  [!WS "1"!] ** events are configured with immediate storage.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + n, where n is the number of events in the
  [!WS "1"!] ** largest combined DTC for which the immediate storage is enabled.
  [!WS "1"!] */
  [!WS "0"!]#define DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_PRIMARY   \
  [!IF "$IntermediateDTCsMaxPriSize > 0"!]
    [!WS "2"!](DEM_SIZE_STORAGE_ORDER_ID + [!"num:integer($IntermediateDTCsMaxPriSize)"!]U)
  [!ELSE!][!//
    [!WS "2"!][!"num:integer($IntermediateDTCsMaxPriSize)"!]U
  [!ENDIF!]

  [!WS "0"!]#if (defined DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_SECONDARY)
  [!WS "0"!]#error DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_SECONDARY already defined
  [!WS "0"!]#endif
  [!WS "0"!]/** \brief Size of StorageOrderIdAndDTCStatus array in secondary memory
  [!WS "1"!] **
  [!WS "1"!] ** This macro defines the size in bytes of the StorageOrderIdAndDTCStatus[]
  [!WS "1"!] ** in secondary event destination
  [!WS "1"!] ** 0, if no DTC/event is configured with immediate storage for the respective
  [!WS "1"!] ** destination.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + 1, if only non-combined DTCs or internal
  [!WS "1"!] ** events are configured with immediate storage.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + n, where n is the number of events in the
  [!WS "1"!] ** largest combined DTC for which the immediate storage is enabled.
  [!WS "1"!] */
  [!WS "0"!]#define DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_SECONDARY   \
    [!IF "$IntermediateDTCsMaxSecSize > 0"!]
  [!WS "2"!](DEM_SIZE_STORAGE_ORDER_ID + [!"num:integer($IntermediateDTCsMaxSecSize)"!]U)
  [!ELSE!][!//
    [!WS "2"!][!"num:integer($IntermediateDTCsMaxSecSize)"!]U
  [!ENDIF!]

  [!WS "0"!]#if (defined DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_MIRROR)
  [!WS "0"!]#error DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_MIRROR already defined
  [!WS "0"!]#endif
  [!WS "0"!]/** \brief Size of StorageOrderIdAndDTCStatus array in mirror memory
  [!WS "1"!] **
  [!WS "1"!] ** This macro defines the size in bytes of the StorageOrderIdAndDTCStatus[]
  [!WS "1"!] ** in mirror event destination
  [!WS "1"!] ** 0, if no DTC/event is configured with immediate storage for the respective
  [!WS "1"!] ** destination.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + 1, if only non-combined DTCs or internal
  [!WS "1"!] ** events are configured with immediate storage.
  [!WS "1"!] ** DEM_SIZE_STORAGE_ORDER_ID + n, where n is the number of events in the
  [!WS "1"!] ** largest combined DTC for which the immediate storage is enabled.
  [!WS "1"!] */
  [!WS "0"!]#define DEM_SIZE_STORAGE_ORDER_ID_AND_DTC_STATUS_MIRROR   \
  [!IF "$IntermediateDTCsMaxMirSize > 0"!]
    [!WS "2"!](DEM_SIZE_STORAGE_ORDER_ID + [!"num:integer($IntermediateDTCsMaxMirSize)"!]U)
  [!ELSE!][!//
    [!WS "2"!][!"num:integer($IntermediateDTCsMaxMirSize)"!]U
  [!ENDIF!]
[!ENDIF!][!//

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)

#if (defined DEM_IMMEDIATE_CLEARED)
#error DEM_IMMEDIATE_CLEARED already defined
#endif
/** \brief Immediate storage configuration value: store CLEARED entries */
#define DEM_IMMEDIATE_CLEARED 0U

#if (defined DEM_IMMEDIATE_CHANGED)
#error DEM_IMMEDIATE_CHANGED already defined
#endif
/** \brief Immediate storage configuration value: store ALL entries */
#define DEM_IMMEDIATE_CHANGED 1U

#if (defined DEM_IMMEDIATE_NV_STORAGE_TYPE)
#error DEM_IMMEDIATE_NV_STORAGE_TYPE already defined
#endif
/** \brief Immediate storage configuration */
#define DEM_IMMEDIATE_NV_STORAGE_TYPE  [!//
[!IF "(node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refexists(DemDTCClassRef) and node:existsAndTrue(as:ref(DemDTCClassRef)/DemImmediateNvStorage)]) or
       (node:existsAndTrue(DemGeneral/DemImmediateStorageInternalEvents))) and
      (count(DemGeneral/DemNvRamBlockId/eb-list::*) > 0)"!]
  DEM_IMMEDIATE_CHANGED
[!ELSE!][!//
  DEM_IMMEDIATE_CLEARED
[!ENDIF!]

#endif /* (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON) */

#if (defined DEM_IMMEDIATE_NV_STORAGE_LIMIT)
#error DEM_IMMEDIATE_NV_STORAGE_LIMIT already defined
#endif
/** \brief Immediate NvM storage limit
 **
 ** Defines the maximum number of occurrences, a specific event memory entry
 ** is allowed, to be stored in NVRAM immediately.
 ** Its value is set to 0 when the immediate storage limit feature is
 ** disabled by the user. In that case, there is no limit for the storage to
 ** NVRAM and whenever the entry gets updated, it can be stored immediately
 ** to NVRAM if immediate storage is enabled for it.
 **/
#define DEM_IMMEDIATE_NV_STORAGE_LIMIT   [!//
[!IF "node:exists(DemGeneral/DemImmediateNvStorageLimit)"!]
  [!"num:integer(DemGeneral/DemImmediateNvStorageLimit)"!]U
[!ELSE!][!//
  0U
[!ENDIF!]

#if (defined DEM_ZERO_END)
#error DEM_ZERO_END already defined
#endif
/** \brief Zero value to be added to each size, whose involved patterns could
 ** be none */
#define DEM_ZERO_END                  0U

#if (defined DEM_SIZE_ENTRY_DATA_PRIMARY)
#error DEM_SIZE_ENTRY_DATA_PRIMARY already defined
#endif
/** \brief Size of dynamic primary entry data
 **
 ** The N (primary memory entry number) maximal sizes are added.
 **
 ** \note The DEM_ZERO_END is not necessary here, because primary event memory
 **       is always > 0.
 **/
#define DEM_SIZE_ENTRY_DATA_PRIMARY   \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntryPrimary"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListPrm))"!]
      [!VAR "CurEntrySize" = "text:split($ListPrm)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!INDENT "0"!]
      [!"num:integer($MaxEntrySize)"!]U[!//
      [!IF "number($i) < DemGeneral/DemMaxNumberEventEntryPrimary"!]
        [!WS!]+ [!//
      [!ENDIF!]
    [!ENDINDENT!]
    [!VAR "ListPrm" = "text:replace($ListPrm, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  )
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_PRIMARY > 0xFFFFU
#error The total size of the dynamic primary entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_SECONDARY)
#error DEM_SIZE_ENTRY_DATA_SECONDARY already defined
#endif
/** \brief Size of dynamic secondary entry data
 **
 ** The N (secondary memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_SECONDARY \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntrySecondary"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListSec))"!]
      [!VAR "CurEntrySize" = "text:split($ListSec)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!WS "0"!][!"num:integer($MaxEntrySize)"!]U + [!//
    [!VAR "ListSec" = "text:replace($ListSec, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  DEM_ZERO_END)
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_SECONDARY > 0xFFFFU
#error The total size of the dynamic secondary entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_MIRROR)
#error DEM_SIZE_ENTRY_DATA_MIRROR already defined
#endif
/** \brief Size of dynamic mirror entry data
 **
 ** The N (mirror memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_MIRROR    \
  ([!//
  [!FOR "i" = "1" TO "DemGeneral/DemMaxNumberEventEntryMirror"!]
    [!VAR "MaxEntrySize" = "0"!]
    [!FOR "j" = "1" TO "count(text:split($ListMir))"!]
      [!VAR "CurEntrySize" = "text:split($ListMir)[position() = $j]"!]
      [!IF "$MaxEntrySize < $CurEntrySize"!]
        [!VAR "MaxEntrySize" = "$CurEntrySize"!]
      [!ENDIF!]
    [!ENDFOR!]
    [!WS "0"!][!"num:integer($MaxEntrySize)"!]U + [!//
    [!VAR "ListMir" = "text:replace($ListMir, $MaxEntrySize, '')"!]
  [!ENDFOR!]
  DEM_ZERO_END)
/* !LINKSTO dsn.Dem.Dem_EntryData.MaxSize,1 */
#if DEM_SIZE_ENTRY_DATA_MIRROR > 0xFFFFU
#error The total size of the dynamic mirror entry data exceed 65535 byte. \
  Please reduce size or remove Extended Data Recordes, Freeze Frame Classes, or \
  number of Freeze Frame Records to reduce the needed space.
#endif

#if (defined DEM_SIZE_ENTRY_DATA_PERMANENT)
#error DEM_SIZE_ENTRY_DATA_PERMANENT already defined
#endif
/** \brief Size of dynamic permanent entry data
 **
 ** The N (permanent memory entry number) maximal sizes are added.
 **/
#define DEM_SIZE_ENTRY_DATA_PERMANENT DEM_ZERO_END

/*---------------------[Common Freeze Frame]--------------------------------*/

#if (defined DEM_COMMON_FREEZEFRAMES_USED)
#error DEM_COMMON_FREEZEFRAMES_USED already defined
#endif
/** \brief Defines if any common freeze frame class is configured */
[!IF "(node:refexists(DemGeneral/DemCommonFFDataClassRef)) or
      ( (node:existsAndTrue(DemGeneral/DemDevFreezeFrameSupport)) and
        (node:refexists(DemGeneral/DemCommonFFDataDevAClassRef)) )"!]
  [!WS "0"!]#define DEM_COMMON_FREEZEFRAMES_USED   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_COMMON_FREEZEFRAMES_USED   STD_OFF
[!ENDIF!]

/*------------------[Development Freeze Frame]------------------------------*/

/* !LINKSTO dsn.Dem.DevFF.Encapsulation,1 */
#if (defined DEM_DEV_FREEZE_FRAME_USED)
#error DEM_DEV_FREEZE_FRAME_USED already defined
#endif
/** \brief Switch, indicating if Development Freeze Frames are enabled */
[!IF "node:existsAndTrue(DemGeneral/DemDevFreezeFrameSupport)"!]
  [!WS "0"!]#define DEM_DEV_FREEZE_FRAME_USED   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_DEV_FREEZE_FRAME_USED   STD_OFF
[!ENDIF!]

#if (defined DEM_MAX_NUMBER_DEVFFA_ENTRY)
#error DEM_MAX_NUMBER_DEVFFA_ENTRY already defined
#endif
[!/* node does not exist if DemDevFreezeFrameSupport is disabled */!][!//
[!IF "(node:exists(DemGeneral/DemMaxNumberDevFreezeFrameAEntry))"!]
/** \brief Maximum number of development Freeze Frames A type entries
 **/
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFA_ENTRY [!"num:integer(DemGeneral/DemMaxNumberDevFreezeFrameAEntry)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFA_ENTRY 0U
[!ENDIF!]

#if (defined DEM_DEV_FFA_MAX_CLASS_SIZE)
#error DEM_DEV_FFA_MAX_CLASS_SIZE already defined
#endif
/** \brief Size of largest configured Development Freeze Frames A class
 ** including the Common Development Freeze Frame A part
 **/
/* !LINKSTO dsn.Dem.DevFF.DemMaxNumberDevFreezeFrameAEntry, 1 */
#define DEM_DEV_FFA_MAX_CLASS_SIZE [!"num:integer($FFASizeLargest)"!]U

#if (defined DEM_MAX_NUMBER_DEVFFB_ENTRY)
#error DEM_MAX_NUMBER_DEVFFB_ENTRY already defined
#endif
[!/* node does not exist if DemDevFreezeFrameSupport is disabled */!][!//
[!IF "(node:exists(DemGeneral/DemMaxNumberDevFreezeFrameBEntry))"!]
/** \brief Maximum number of development Freeze Frames B type entries
 **/
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFB_ENTRY [!"num:integer(DemGeneral/DemMaxNumberDevFreezeFrameBEntry)"!]U
[!ELSE!][!//
  [!WS "0"!]#define DEM_MAX_NUMBER_DEVFFB_ENTRY 0U
[!ENDIF!]

#if (defined DEM_DEV_FFB_MAX_CLASS_SIZE)
#error DEM_DEV_FFB_MAX_CLASS_SIZE already defined
#endif
/** \brief Size of largest configured Development Freeze Frames B class
 **/
#define DEM_DEV_FFB_MAX_CLASS_SIZE [!"num:integer($FFBSizeLargest)"!]U

/*------------------[Error Queue configuration]----------------------------*/
#if (defined DEM_ERROR_QUEUE_EXTENDED)
#error DEM_ERROR_QUEUE_EXTENDED already defined
#endif
/** \brief Switch, indicating if extended error queue is enabled
 ** NumberOfErrorQueueStatusBits contains:
 **   2 bits for status, 1 bit for TFTOC flag, 1 bit for DTC PDTC flag
 ** In case OBDonUDS FF is configured it contains additionally:
 **   1 bit for DTC TF flag, 1 bit for DTC TFTOC flag
 **/
[!CALL "GET_WIDTH", "PNumber" = "num:integer($NumberOfConfiguredDemEvents) + 1", "context" = "'DemEventParameter'"!][!//
[!VAR "EventCountBitWidth" = "num:integer($NumberOfBits)"!][!//
[!IF "($OBDonUDSFreezeFrameSize > 0)"!][!//
  [!VAR "NumberOfErrorQueueStatusBits" = "6"!][!//
[!ELSE!][!//
  [!VAR "NumberOfErrorQueueStatusBits" = "4"!][!//
[!ENDIF!]
[!//
[!IF "($EventCountBitWidth + $NumberOfErrorQueueStatusBits) > 16"!][!//
#define DEM_ERROR_QUEUE_EXTENDED STD_ON
[!ELSE!][!//
#define DEM_ERROR_QUEUE_EXTENDED STD_OFF
[!ENDIF!]

/*------------------[Freeze frame configuration]----------------------------*/

/* Symbolic names of configured freeze frame data IDs */
[!LOOP "DemGeneral/DemDidClass/eb-list::*"!]
  [!INDENT "0"!]

    #if (defined DEM_FFS_DID_[!"as:name(.)"!])
    #error DEM_FFS_DID_[!"as:name(.)"!] already defined
    #endif
    [!IF "node:exists(DemDidIdentifier)"!]
      /** \brief Symbolic name of data ID [!"as:name(.)"!] */
      #define DEM_FFS_DID_[!"as:name(.)"!] [!"num:integer(DemDidIdentifier)"!]U
    [!ENDIF!]
  [!ENDINDENT!]
[!ENDLOOP!]

#if (defined DEM_FF_RECNUM_CALCULATED)
#error DEM_FF_RECNUM_CALCULATED already defined
#endif
/** \brief Freeze frame records will be numbered consecutive starting by 1 in
 ** their chronological order */
#define DEM_FF_RECNUM_CALCULATED     0x00U

#if (defined DEM_FF_RECNUM_CONFIGURED)
#error DEM_FF_RECNUM_CONFIGURED already defined
#endif
/** \brief Freeze frame records will be numbered based on the given
 ** configuration in their chronological order */
#define DEM_FF_RECNUM_CONFIGURED     0x01U

#if (defined DEM_FREEZE_FRAME_REC_NUMERATION_TYPE)
#error DEM_FREEZE_FRAME_REC_NUMERATION_TYPE already defined
#endif
/** \brief Type of assignment of freeze frame record numbers
 **
 ** This switch defines the type for assigning freeze frame record numbers for
 ** event-specific freeze frame records.
 **/
#define DEM_FREEZE_FRAME_REC_NUMERATION_TYPE  [!//
[!"DemGeneral/DemTypeOfFreezeFrameRecordNumeration"!]

#if (defined DEM_MAX_NUMBER_PRESTORED_FF)
#error DEM_MAX_NUMBER_PRESTORED_FF already defined
#endif
/** \brief Maximum number of available prestored freeze frames
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_PRESTORED_FF [!"$MaxNumPrestoredFF"!]U

#if (defined DEM_TRIGGER_EVENT_MEMORY_STORAGE)
#error DEM_TRIGGER_EVENT_MEMORY_STORAGE already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** event is stored in the event memory */
#define DEM_TRIGGER_EVENT_MEMORY_STORAGE  0x00U

#if (defined DEM_TRIGGER_TESTFAILED)
#error DEM_TRIGGER_TESTFAILED already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** UDS DTC status bit 0 (TestedFailed) changes from 0 to 1 */
#define DEM_TRIGGER_TESTFAILED            0x01U

#if (defined DEM_TRIGGER_ON_FDC_THRESHOLD)
#error DEM_TRIGGER_ON_FDC_THRESHOLD already defined
#endif
/** \brief Triggers the collection of freeze frame / extended data if the
 ** unconfirmedDTC threshold is reached */
#define DEM_TRIGGER_ON_FDC_THRESHOLD      0x02U

#if (defined DEM_FREEZE_FRAME_CAPTURE)
#error DEM_FREEZE_FRAME_CAPTURE already defined
#endif
/** \brief Type of freeze frame capture trigger
 **
 ** This parameter defines the point in time, when the freeze frame data
 ** collection is done for the initial event memory entry.
 **/
#define DEM_FREEZE_FRAME_CAPTURE          [!"DemGeneral/DemFreezeFrameCapture"!]

/*------------------[Client configuration]----------------------------------*/
/** \brief Provides symbolic names of configured Clients
 **
 ** Configured clients are prefixed with symbolic name DemConf_DemClient_
 **/
[!INDENT "0"!]
  [!LOOP "util:distinct(node:order(DemGeneral/DemClient/eb-list::*, './DemClientId'))"!]
#if (defined DemConf_DemClient_[!"as:name(.)"!])
#error DemConf_DemClient_[!"as:name(.)"!] is already defined
#endif
#define DemConf_DemClient_[!"as:name(.)"!][!//
    [!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer(DemClientId)"!]U
  [!ENDLOOP!]
[!ENDINDENT!]
/*------------------[Multi-event triggering configuration]------------------*/
#if (defined DEM_MULTIEVENTTRIGGERING_SETEVENTAVAILABLE_SUPPORT)
#error DEM_MULTIEVENTTRIGGERING_SETEVENTAVAILABLE_SUPPORT already defined
#endif
/** \brief Switch, indicating if calls to Dem_SetEventAvailability() shall
 *         be applied to all events of the MultiEventTriggering */
[!IF "node:existsAndTrue(DemGeneral/Dem_MultiEventTriggeringSetEventAvailable)"!]
  [!WS "0"!]#define DEM_MULTIEVENTTRIGGERING_SETEVENTAVAILABLE_SUPPORT  STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_MULTIEVENTTRIGGERING_SETEVENTAVAILABLE_SUPPORT  STD_OFF
[!ENDIF!]

#if (defined DEM_MULTIEVENTTRIGGERING_ALT_NONE)
#error DEM_MULTIEVENTTRIGGERING_ALT_NONE already defined
#endif
/** \brief Type of multi-event triggering default behavior */
#define DEM_MULTIEVENTTRIGGERING_ALT_NONE  0x00U

#if (defined DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE)
#error DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE already defined
#endif
/** \brief Type of multi-event triggering exlusive replacement behavior */
#define DEM_MULTIEVENTTRIGGERING_ALT_EXCLUSIVE_REPLACE  0x01U

/*------------------[Events configuration]----------------------------------*/

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_PRI)
#error DEM_MAX_NUMBER_EVENT_ENTRY_PRI already defined
#endif
/** \brief Maximum number of events which can be stored in the primary memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_PRI [!"num:integer(DemGeneral/DemMaxNumberEventEntryPrimary)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_SEC)
#error DEM_MAX_NUMBER_EVENT_ENTRY_SEC already defined
#endif
/** \brief Maximum number of events which can be stored in the secondary
 ** memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_SEC [!"num:integer(DemGeneral/DemMaxNumberEventEntrySecondary)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_MIR)
#error DEM_MAX_NUMBER_EVENT_ENTRY_MIR already defined
#endif
/** \brief Maximum number of events which can be stored in the mirror memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_MAX_NUMBER_EVENT_ENTRY_MIR [!"num:integer(DemGeneral/DemMaxNumberEventEntryMirror)"!]U

#if (defined DEM_MAX_NUMBER_EVENT_ENTRY_PER)
#error DEM_MAX_NUMBER_EVENT_ENTRY_PER already defined
#endif
/** \brief Maximum number of events which can be stored in the permanent memory
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
/* !LINKSTO Dem_OBD_0005,1 */
[!IF "node:exists(DemGeneral/DemMaxNumberEventEntryPermanent)"!]
#define DEM_MAX_NUMBER_EVENT_ENTRY_PER [!"num:integer(DemGeneral/DemMaxNumberEventEntryPermanent)"!]U
[!ELSE!]
#define DEM_MAX_NUMBER_EVENT_ENTRY_PER 0U
[!ENDIF!]

#if (defined DEM_NUMBER_OF_EVENT_CLASSES)
#error DEM_NUMBER_OF_EVENT_CLASSES already defined
#endif
/** \brief Number of individual event classes which are present in the system
 **
 ** If calibration is enabled the Dem combine set of this parameter to one entry in Dem_EventClass[]
 **/
[!CALL "CREATE_EVENT_CLASS_LIST"!]
#define DEM_NUMBER_OF_EVENT_CLASSES [!"num:i($MaxNumberEventClasses)"!]U

#if (defined DEM_NUMBER_OF_EVENTS)
#error DEM_NUMBER_OF_EVENTS already defined
#endif
/** \brief Number of events which are present in the system
 **
 ** Calculated by number of event IDs listed in Dem_IntErrId.h and
 ** Dem_IntEvtId.h including ::DEM_EVENT_ID_INVALID.
 **
 ** \note Macro name is still existing for compatibility reasons with AR2.1.
 **/
#define DEM_NUMBER_OF_EVENTS  [!"num:integer(($NumberOfConfiguredDemEvents) + 1)"!]U

#if (defined DEM_NUM_SWC_EVENTS)
#error DEM_NUM_SWC_EVENTS already defined
#endif
/** \brief Number of SW-C events present in the system
 **/
#define DEM_NUM_SWC_EVENTS [!"num:integer(count(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[DemEventKind = 'DEM_EVENT_KIND_SWC']))"!]U

#if (defined DEM_NUM_BSW_EVENTS)
#error DEM_NUM_BSW_EVENTS already defined
#endif
/** \brief Number of BSW events present in the system
 **/
#define DEM_NUM_BSW_EVENTS (DEM_NUMBER_OF_EVENTS - DEM_NUM_SWC_EVENTS - 1U)

#if (defined DEM_NUM_OF_PIDS_IN_OBDFF)
#error DEM_NUM_OF_PIDS_IN_OBDFF already defined
#endif
/** \brief Number of PIDs to be stored in OBD freeze frame **/
[!IF "node:exists(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemPidClass/eb-list::*)"!]
/* !LINKSTO dsn.Dem.OBD.DEM_NUM_OF_PIDS_IN_OBDFF,1 */
#define DEM_NUM_OF_PIDS_IN_OBDFF [!"$NumOfPidInOBDFF"!]U
[!ELSE!][!//
#define DEM_NUM_OF_PIDS_IN_OBDFF 0U
[!ENDIF!]

#if (defined DEM_OBDFF_SINGLE)
#error DEM_OBDFF_SINGLE already defined
#endif
/** \brief Single OBD freeze frame support */
#define DEM_OBDFF_SINGLE            0x01U

#if (defined DEM_OBDFF_MULTIPLE)
#error DEM_OBDFF_MULTIPLE already defined
#endif
/** \brief Multiple OBD freeze frame support */
#define DEM_OBDFF_MULTIPLE            0x02U

#if (defined DEM_OBDFF_SUPPORT_KIND)
#error DEM_OBDFF_SUPPORT_KIND already defined
#endif
/** \brief Type of OBD freeze frame support
 **
 ** This macro controls support of the multiple and single OBD Freeze Frame
 **/
/* !LINKSTO dsn.Dem.OBD.OBDFreezeFrame.HandlingVariants,1 */
[!IF "($NumOfPidInOBDFF > 0) or ($OBDonUDSFreezeFrameSize > 0)"!]
[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemFreezeFrameCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD')"!]
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_SUPPORT_KIND.DEM_OBDFF_SINGLE,2 */
#define DEM_OBDFF_SUPPORT_KIND            DEM_OBDFF_SINGLE
[!ELSE!]
/* !LINKSTO dsn.Dem.OBD.DEM_OBDFF_SUPPORT_KIND.DEM_OBDFF_MULTIPLE,2 */
#define DEM_OBDFF_SUPPORT_KIND            DEM_OBDFF_MULTIPLE
[!ENDIF!]
[!ELSE!]
#define DEM_OBDFF_SUPPORT_KIND            STD_OFF
[!ENDIF!]

[!IF "(node:existsAndTrue(DemGeneral/DemOBDSupport)) and
      (DemGeneral/DemReadinessGroupCalibrationConfigKind = 'DEM_NUMBER_OF_SLOTS_COMMON_CONFIG')"!][!//
#if (defined DEM_MAX_EVENTS_PER_READINESS_GROUP)
#error DEM_MAX_EVENTS_PER_READINESS_GROUP already defined
#endif
/** \brief Maximum number of events per readiness groups
 *
 *  If calibration is enabled and an equal number of event slots are allocated for
 *  the OBD readiness groups, this value defines the maximum number of events
 *  which can be assigned to an OBD readiness group.
 */
[!/* !LINKSTO Dem.Dsn.DemMaxNumEventsPerReadinessGroup,1 */!][!//
[!IF "node:exists(DemGeneral/DemMaxNumEventsPerReadinessGroup)"!]
#define DEM_MAX_EVENTS_PER_READINESS_GROUP [!"num:integer(DemGeneral/DemMaxNumEventsPerReadinessGroup)"!]U
[!ELSE!][!//
#define DEM_MAX_EVENTS_PER_READINESS_GROUP 0U
[!ENDIF!]
[!ENDIF!]

#if (defined DEM_REPORT_BSW_EVENTS_VIA_SET_EVENT_STATUS)
#error DEM_REPORT_BSW_EVENTS_VIA_SET_EVENT_STATUS already defined
#endif
/** \brief Configuration switch to define if the BSW events shall be reported
 *         via the Dem_SetEventStatus API or not.
 */
[!IF "(node:exists(DemGeneral/DemReportBSWEventsViaSetEventStatus)) and
      (node:value(DemGeneral/DemReportBSWEventsViaSetEventStatus) = 'true')"!][!//
  [!WS "0"!]#define DEM_REPORT_BSW_EVENTS_VIA_SET_EVENT_STATUS   STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_REPORT_BSW_EVENTS_VIA_SET_EVENT_STATUS   STD_OFF
[!ENDIF!]


/*------------------[DTC groups configuration]------------------------------*/

/* Symbolic names of configured DTC groups */
[!INDENT "0"!]
  [!LOOP "util:distinct(node:order(DemGeneral/DemGroupOfDTC/eb-list::*, './DemGroupDTCs'))"!]
    [!VAR "PredefinedGroup" = "'true'"!]
    [!/* create group name only for commentation */!][!//
    [!VAR "CommentGroupName" = "as:name(.)"!]
    [!IF "$CommentGroupName = 'DEM_DTC_GROUP_EMISSION_REL_DTCS'"!]
      [!VAR "CommentGroupName" = "'OBD-relevant'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_POWERTRAIN_DTCS'"!]
      [!VAR "CommentGroupName" = "'powertrain'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_CHASSIS_DTCS'"!]
      [!VAR "CommentGroupName" = "'chassis'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_BODY_DTCS'"!]
      [!VAR "CommentGroupName" = "'body'"!]
    [!ELSEIF "$CommentGroupName = 'DEM_DTC_GROUP_NETWORK_COM_DTCS'"!]
      [!VAR "CommentGroupName" = "'network communication'"!]
    [!ELSE!]
      [!VAR "PredefinedGroup" = "'false'"!]
      [!VAR "CommentGroupName" = "substring($CommentGroupName, 15)"!]
    [!ENDIF!]

    #if (defined DemConf_DemGroupOfDTC_[!"as:name(.)"!])
    #error DemConf_DemGroupOfDTC_[!"as:name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value of DTC group
     **[!"$CommentGroupName"!]
     **/
    #define DemConf_DemGroupOfDTC_[!"as:name(.)"!][!//
    [!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U

    [!/* Predefined non-emission related DTC group */!]
    [!IF "$CommentGroupName != 'OBD-relevant'"!]
      [!IF "$PredefinedGroup = 'true'"!]
        #if (defined [!"as:name(.)"!])
        #error [!"as:name(.)"!] already defined
        #endif
        /** \brief Export PREDEFINED symbolic name value (without prefix)
         ** as per definition of ::Dem_DTCGroupType in SWS
         **/
        #define [!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U

      [!ENDIF!]
    [!ENDIF!]
    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)
    #if (defined Dem_[!"as:name(.)"!])
    #error Dem_[!"as:name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"translate(num:inttohex(DemGroupDTCs, 6), 'abcdef', 'ABCDEF')"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDLOOP!]
[!ENDINDENT!]

#if (defined DEM_EMISSION_REL_DTCS_GROUP_EXIST)
#error DEM_EMISSION_REL_DTCS_GROUP_EXIST already defined
#endif
 /** \brief Switch, indicating if emision related DTC group is enabled */
[!IF "node:exists(as:modconf('Dem')[1]/DemGeneral/DemGroupOfDTC/eb-list::*[as:name(.) = 'DEM_DTC_GROUP_EMISSION_REL_DTCS'])"!]
   [!WS "0"!]#define DEM_EMISSION_REL_DTCS_GROUP_EXIST   STD_ON
[!ELSE!][!//
   [!WS "0"!]#define DEM_EMISSION_REL_DTCS_GROUP_EXIST   STD_OFF
[!ENDIF!]

/*------------------[Warning indicators configuration]----------------------*/

/* Symbolic names of configured warning indicator IDs */
[!LOOP "DemGeneral/DemIndicator/eb-list::*"!]
  [!INDENT "0"!]

    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if (DemConf_DemIndicator_[!"as:name(.)"!] != [!"num:integer(DemIndicatorID)"!]U)
      #error Definition of macro DemConf_DemIndicator_[!"as:name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined DemConf_DemIndicator_[!"as:name(.)"!])
      #error DemConf_DemIndicator_[!"as:name(.)"!] already defined
      #endif
      /** \brief Export symbolic name value */
      #define DemConf_DemIndicator_[!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer(DemIndicatorID)"!]U
    [!ENDIF!]

    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)

    #if (defined Dem_[!"as:name(.)"!])
    #error Dem_[!"as:name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer(DemIndicatorID)"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDINDENT!]
[!ENDLOOP!]


#if (defined DEM_NUMBER_OF_INDICATORS)
#error DEM_NUMBER_OF_INDICATORS already defined
#endif
/** \brief Number of warning indicators which are present in the system
 **
 ** \note Macro name is conform to the vague definition in chapter 10 of SWS.
 **/
#define DEM_NUMBER_OF_INDICATORS                [!"$NumIndicator"!]U


#if (defined DEM_NUM_INDICATOR_LINKS)
#error DEM_NUM_INDICATOR_LINKS already defined
#endif
/** \brief Number of warning indicator links
 **        In case of calibration-support a link represents an indicator class */
#define DEM_NUM_INDICATOR_LINKS                 [!"num:i($NumIndicatorLinks)"!]U


#if (defined DEM_INDICATOR_MULTIPLICITY)
#error DEM_INDICATOR_MULTIPLICITY already defined
#endif
/** \brief Number of different warning indicator which could be assigned to an
 **        event. Without calibration support the assigned indicator can not be
 **        changed.
 **/
[!IF "$CalibrationSupport = 'true'"!]
  #define DEM_INDICATOR_MULTIPLICITY              DEM_NUMBER_OF_INDICATORS
[!ELSE!][!//
  #define DEM_INDICATOR_MULTIPLICITY              1U
[!ENDIF!]


#if (defined DEM_NUM_INDICATOR_COUNTER)
#error DEM_NUM_INDICATOR_COUNTER already defined
#endif
/** \brief Number of used indicator counter in ::Dem_NvData */
[!IF "$CalibrationSupport = 'true'"!]
  #define DEM_NUM_INDICATOR_COUNTER               DEM_NUMBER_OF_EVENTS
[!ELSE!][!//
  #define DEM_NUM_INDICATOR_COUNTER               DEM_NUM_INDICATOR_LINKS
[!ENDIF!]


#if (defined DEM_NUM_INDICATOR_COUNTER_BIT)
#error DEM_NUM_INDICATOR_COUNTER_BIT already defined
#endif
/** \brief Number of bytes to hold one bit for each indicator counter
 **        in ::Dem_NvData for IndicatorCycleCounterRole and
 **        IndicatorCycleCounterWIRStatus */
#define DEM_NUM_INDICATOR_COUNTER_BIT           ((DEM_NUM_INDICATOR_COUNTER + 7U) / 8U)


[!VAR "NumBSWEventIndicatorConfigured" = "0"!]
[!LOOP "DemConfigSet/eb-list::*/DemEventParameter/eb-list::*"!]
  [!IF "( ./DemEventKind = 'DEM_EVENT_KIND_BSW') and ($CalibrationWithoutEvCombSupport = 'true') and (DemGeneral/DemMaxNumberIndicatorClasses > 0 or $NumIndicatorLinks > 0)"!]
    [!VAR "NumBSWEventIndicatorConfigured" = "$NumBSWEventIndicatorConfigured + 1"!]
  [!ELSE!]
    [!IF "node:exists(DemEventClass/DemIndicatorAttribute/eb-list::*) and ./DemEventKind = 'DEM_EVENT_KIND_BSW'"!]
      [!VAR "NumBSWEventIndicatorConfigured" = "$NumBSWEventIndicatorConfigured + 1"!]
    [!ENDIF!]
  [!ENDIF!]
[!ENDLOOP!]

#if (defined DEM_NUM_BSWEVENT_INDICATOR_USED)
#error DEM_NUM_BSWEVENT_INDICATOR_USED already defined
#endif
/** \brief Number of BSW events which are configured for warning indicator */
#define DEM_NUM_BSWEVENT_INDICATOR_USED         [!"num:integer($NumBSWEventIndicatorConfigured)"!]U

[!IF "$CalibrationSupport = 'true'"!]
  [!CALL "GET_NUMBER_OF_INDICATOR_CLASSES_WITH_DEMMAXNUMBERINDICATORCLASSES"!]
#if (defined DEM_NUM_INDICATOR_GROUPS)
#error DEM_NUM_INDICATOR_GROUPS already defined
#endif
/** \brief Number of warning indicator groups */
#define DEM_NUM_INDICATOR_GROUPS                [!"num:i($NumberOfIndicatorClasses + 1)"!]U

[!ENDIF!]
/*------------------[Enable conditions configuration]-----------------------*/
#if (defined DEM_NUM_ENCONDGROUPS)
#error DEM_NUM_ENCONDGROUPS already defined
#endif
/** \brief Number of enable condition groups, used for further calculation */
#define DEM_NUM_ENCONDGROUPS   [!"num:integer($DemNumEnCondGroups)"!]U

/* Symbolic names of configured enable conditions */
[!LOOP "DemGeneral/DemEnableCondition/eb-list::*"!]
  [!INDENT "0"!]
    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if (DemConf_DemEnableCondition_[!"as:name(.)"!] != [!"num:integer(DemEnableConditionId)"!])
      #error Definition of macro DemConf_DemEnableCondition_[!"as:name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined DemConf_DemEnableCondition_[!"as:name(.)"!])
      #error DemConf_DemEnableCondition_[!"as:name(.)"!] already defined
      #endif
      /** \brief Export symbolic name value */
      #define DemConf_DemEnableCondition_[!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer(DemEnableConditionId)"!]U
    [!ENDIF!]

    #if (defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES)
    #if (defined Dem_[!"as:name(.)"!])
    #error Dem_[!"as:name(.)"!] already defined
    #endif
    /** \brief Export symbolic name value with module abbreviation as prefix
     ** only (AUTOSAR version <= AUTOSAR 4.0 rev2)
     **/
    #define Dem_[!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer(DemEnableConditionId)"!]U
    #endif /* defined DEM_PROVIDE_LEGACY_SYMBOLIC_NAMES */
  [!ENDINDENT!]
[!ENDLOOP!]

#if (defined DEM_NUM_ENABLECONDITIONS)
#error DEM_NUM_ENABLECONDITIONS already defined
#endif
/** \brief Number of enable conditions */
#define DEM_NUM_ENABLECONDITIONS [!"num:integer(count(DemGeneral/DemEnableCondition/eb-list::*))"!]U

#if (defined DEM_ENCONDITIONGROUP_UNUSED)
#error DEM_ENCONDITIONGROUP_UNUSED already defined
#endif
/** \brief Used in Dem_EventDesc and Dem_EventClassDesc if a dedicated event
 ** does not refer to any enable condition group */
#define DEM_ENCONDITIONGROUP_UNUSED         DEM_NUM_ENCONDGROUPS

/*------------------[Multi event triggering configuration]------------------*/

[!CALL "GET_MULTI_EVENT_TRIGGERING_CLASS_COUNT"!]
#if (defined DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT already defined
#endif
/** \brief Number of multi event triggering classes */
#define DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT [!"num:integer($NumMultiEventTriggeringClasses)"!]U

#if (defined DEM_MULTI_EVENT_TRIGGERING_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_COUNT already defined
#endif
/** \brief Number of multi event triggering configurations */
#define DEM_MULTI_EVENT_TRIGGERING_COUNT [!"num:integer($NumMultiEventTriggering)"!]U

#if (defined DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH)
#error DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH already defined
#endif
/** \brief Maximum bit-width of multi event triggering configurations */
[!IF "num:integer($NumMultiEventTriggering) > 255"!]
#define DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH 16U
[!ELSE!][!//
#define DEM_MULTI_EVENT_TRIGGERING_COUNT_MAX_WIDTH 8U
[!ENDIF!]

[!CALL "GET_MULTI_EVENT_TRIGGERING_SLAVE_COUNT"!]
#if (defined DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT already defined
#endif
/** \brief Number of configured slave events based on multi event triggering classes */
#define DEM_MULTI_EVENT_TRIGGERING_SLAVE_COUNT [!"num:integer($NumMultiEventTriggeringSlaves)"!]U

[!CALL "GET_WIDTH", "PNumber" = "num:integer($NumMultiEventTriggering) + 1", "context" = "'MultiEventTriggering'"!][!//
[!VAR "MultiEventTriggeringIdxWidth" = "num:integer($NumberOfBits)"!][!//
[!//
#if (defined DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT)
#error DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT already defined
#endif
/** \brief Bit-width needed to store DEM_MULTI_EVENT_TRIGGERING_COUNT */
#define DEM_MULTI_EVENT_TRIGGERING_BIT_COUNT [!"$MultiEventTriggeringIdxWidth"!]U

#if (defined DEM_ROOT_ERROR_BUFFER_SIZE)
#error DEM_ROOT_ERROR_BUFFER_SIZE already defined
#endif
/** \brief Number of multi event root error queue element groups */
#define DEM_ROOT_ERROR_BUFFER_SIZE [!"num:integer(($MultiEventTriggeringIdxWidth * num:integer(DemGeneral/DemBswErrorBufferSize) + 7) div 8)"!]U

#if (defined DEM_ROOT_ERROR_ENTRY_MASK)
#error DEM_ROOT_ERROR_ENTRY_MASK already defined
#endif
/** \brief Mask used to extract multi event indeces from root error queue */
[!IF "$MultiEventTriggeringIdxWidth > 8"!]
#define DEM_ROOT_ERROR_ENTRY_MASK [!"num:inttohex(bit:shl(1, $MultiEventTriggeringIdxWidth) - 1, 4)"!]U
[!ELSE!][!//
#define DEM_ROOT_ERROR_ENTRY_MASK [!"num:inttohex(bit:shl(1, $MultiEventTriggeringIdxWidth) - 1, 2)"!]U
[!ENDIF!]

#if (defined DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED)
#error DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED already defined
#endif
/** \brief Used in Dem_GetMultiEventTriggeringMasterIdx if a dedicated event
 ** does not have any entry in Dem_MultiEventTriggeringMasterEventId[] */
#define DEM_MULTIEVENTTRIGGERINGMASTERIDX_UNUSED   DEM_MULTI_EVENT_TRIGGERING_COUNT

#if (defined DEM_MULTIEVENTTRIGGERINGIDX_UNUSED)
#error DEM_MULTIEVENTTRIGGERINGIDX_UNUSED already defined
#endif
/** \brief Used in Dem_EventDesc and Dem_EventClassDesc if a dedicated event
 ** does not refer to any multi event triggering class configuration */
#define DEM_MULTIEVENTTRIGGERINGIDX_UNUSED   DEM_MULTI_EVENT_TRIGGERING_CLASS_COUNT

/*------------------[Operation and aging cycles configuration]--------------*/

#ifndef DEM_PROCESS_OPCYC_STATE
/** \brief Operation cycle processing is triggered by START/END */
#define DEM_PROCESS_OPCYC_STATE        0x00U
#endif

#ifndef DEM_PROCESS_OPCYC_COUNTER
/** \brief Operation cycle processing is triggered by collecting an external
 ** counter value */
#define DEM_PROCESS_OPCYC_COUNTER      0x01U
#endif

#ifndef DEM_PROCESS_OPCYC_RESTART
/** \brief Operation cycle processing is triggered by Dem_RestartOperationCycle() API */
#define DEM_PROCESS_OPCYC_RESTART      0x02U
#endif

#if (defined DEM_OPERATION_CYCLE_PROCESSING)
#error DEM_OPERATION_CYCLE_PROCESSING already defined
#endif
/** \brief Operation cycle processing mode
 **
 ** This processing mode defines whether the operation cycles are triggered by
 ** START/END reports via Dem_SetOperationCycleState(), or collecting an
 ** external counter value via Dem_SetOperationCycleCntValue().
 **
 ** \note Macro name is NOT present in SWS. This is as per bugzilla ticket
 ** #47189.
 **/
[!IF "(not(node:exists(DemGeneral/DemOperationCycleProcessing)))"!]#
  #define DEM_OPERATION_CYCLE_PROCESSING DEM_PROCESS_OPCYC_RESTART
[!ELSE!]
  #define DEM_OPERATION_CYCLE_PROCESSING [!"DemGeneral/DemOperationCycleProcessing"!]
[!ENDIF!]

#ifndef DEM_PROCESS_AGINGCTR_INTERN
/** \brief Aging counter processing is triggered internally */
#define DEM_PROCESS_AGINGCTR_INTERN      0x00U
#endif

#ifndef DEM_PROCESS_AGINGCTR_EXTERN
/** \brief Aging counter processing is triggered by collecting an external
 ** counter value */
#define DEM_PROCESS_AGINGCTR_EXTERN      0x01U
#endif

#if (defined DEM_AGINGCYCLE_COUNTER_PROCESSING)
#error DEM_AGINGCYCLE_COUNTER_PROCESSING already defined
#endif
/** \brief Aging counter processing mode
 **
 ** This processing mode defines whether aging is triggered via
 ** Dem_SetOperationCycleState() and Dem_SetAgingCycleState(), or via an
 ** external counter value reported by Dem_SetAgingCycleCounterValue().
 **/
#define DEM_AGINGCYCLE_COUNTER_PROCESSING [!"DemGeneral/DemAgingCycleCounterProcessing"!]

#if (defined DEM_PROCESS_OCCCTR_CDTC)
#error DEM_PROCESS_OCCCTR_CDTC already defined
#endif
/** \brief Occurrence counter processing is triggered
 ** after the fault confirmation was successfull
 **/
#define DEM_PROCESS_OCCCTR_CDTC    0x00U

#if (defined DEM_PROCESS_OCCCTR_TF)
#error DEM_PROCESS_OCCCTR_TF already defined
#endif
/** \brief Occurrence counter processing is triggered
 **  by the TestFailed bit only
 **/
#define DEM_PROCESS_OCCCTR_TF      0x01U

#if (defined DEM_OCCURRENCE_COUNTER_PROCESSING)
#error DEM_OCCURRENCE_COUNTER_PROCESSING already defined
#endif
/** \brief Occurrence counter processing mode
 **
 ** This switch defines the consideration of the fault confirmation
 ** process for the occurrence counter.
 **/
#define DEM_OCCURRENCE_COUNTER_PROCESSING  [!//
[!"DemGeneral/DemOccurrenceCounterProcessing"!]

/* Symbolic names of configured operation cycle types */
[!VAR "OpCycleTypeNr" = "0"!]
[!VAR "isAutoEndEnabled" = "0"!]
[!VAR "isWarmupDefined" = "0"!]
[!LOOP "DemGeneral/DemOperationCycle/eb-list::*"!]
  [!IF "DemOperationCycleType = 'DEM_OPCYC_IGNITION'"!]
    [!VAR "OpCycleTypeNr" = "0"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_OBD_DCY'"!]
    [!VAR "OpCycleTypeNr" = "1"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_POWER'"!]
    [!VAR "OpCycleTypeNr" = "2"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_WARMUP'"!]
    [!VAR "OpCycleTypeNr" = "3"!]
  [!ELSEIF "DemOperationCycleType = 'DEM_OPCYC_TIME'"!]
    [!VAR "OpCycleTypeNr" = "4"!]
  [!ELSE!]
    [!VAR "OpCycleTypeNr" = "5"!]
  [!ENDIF!]
  [!INDENT "0"!]

    #if (defined [!"as:name(.)"!]_TYPE)
    #error [!"as:name(.)"!]_TYPE already defined
    #endif
    /** \brief Symbolic name of configured operation cycle type
     ** [!"DemOperationCycleType"!] for [!"as:name(.)"!].
    [!WS!]** Not used in the current implementation
    **/
    #define [!"as:name(.)"!]_TYPE [!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!][!"num:integer($OpCycleTypeNr)"!]U
  [!ENDINDENT!]
  [!IF "node:existsAndTrue(DemOperationCycleAutomaticEnd)"!]
    [!VAR "isAutoEndEnabled" = "1"!]
  [!ENDIF!]
[!ENDLOOP!]

[!VAR "CycCtr" = "0"!]
[!VAR "isDYCFound" = "0"!]
[!VAR "ObdDcyId" = "0"!]
[!VAR "isIgnitionFound" = "0"!]
[!VAR "ObdIgnitionId" = "0"!]
[!VAR "isWarmupFound" = "0"!]
[!VAR "ObdWarmupId" = "0"!]
[!//
/* Symbolic names of configured operation cycles and failure cycles */
[!LOOP "DemGeneral/DemOperationCycle/eb-list::*"!]
  [!INDENT "0"!]
    [!IF "$DemRteUsage = 'true'"!]
      /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
       * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
      #if ([!"as:name(.)"!] != [!"num:integer($CycCtr)"!])
      #error Definition of macro [!"as:name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
      #endif
    [!ELSE!]
      #if (defined [!"as:name(.)"!])
      #error [!"as:name(.)"!] already defined
      #endif
      /** \brief Symbolic name of operation cycle
       ** [!"as:name(.)"!]
       **/
      #define [!"as:name(.)"!][!//
      [!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer($CycCtr)"!]U
    [!ENDIF!]
  [!ENDINDENT!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_OBD_DCY')"!]
    [!VAR "isDYCFound" = "1"!]
    [!VAR "ObdDcyId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_IGNITION')"!]
    [!VAR "isIgnitionFound" = "1"!]
    [!VAR "ObdIgnitionId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!IF "(./DemOperationCycleType = 'DEM_OPCYC_WARMUP')"!]
    [!VAR "isWarmupFound" = "1"!]
    [!VAR "ObdWarmupId" = "num:integer($CycCtr)"!]
  [!ENDIF!]
  [!VAR "CycCtr" = "$CycCtr + 1"!]
[!//
[!ENDLOOP!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.WARMUP.Id,1 */
[!IF "$isWarmupFound = 1"!]
#if (defined DEM_OPCYC_WARMUP_ID)
#error DEM_OPCYC_WARMUP_ID already defined
#endif
/** \brief ID the operation cycle from type 'DEM_OPCYC_WARMUP' */
#define DEM_OPCYC_WARMUP_ID [!"num:integer($ObdWarmupId)"!]U
[!ENDIF!]

#if (defined DEM_NUM_OPCYCLES)
#error DEM_NUM_OPCYCLES already defined
#endif
/** \brief Number of operation cycles */
#define DEM_NUM_OPCYCLES [!"num:integer($CycCtr)"!]U

[!IF "$isAutoEndEnabled = 1"!]
#if (defined DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH)
#error DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH already defined
#endif
/* Number of operation cycles, masked by one automatic end enabled mask */
#define DEM_OPCYC_AUTO_END_MASK_GROUP_LENGTH 8U

#if (defined DEM_OPCYC_AUTO_END_ENABLED)
#error DEM_OPCYC_AUTO_END_ENABLED already defined
#endif
/** \brief automatic end of opcycle configured for at least 1 opcycle */
#define DEM_OPCYC_AUTO_END_ENABLED STD_ON
[!//
[!/* calculate size of array, that holds auto end masks */!]
[!VAR "numOfOpCycles" = "count(DemGeneral/DemOperationCycle/eb-list::*)"!]
[!IF "$numOfOpCycles <= 8"!]
  [!VAR "MasksArraySize" = "1"!]
[!ELSEIF "$numOfOpCycles mod 8 = 0"!]
  [!VAR "MasksArraySize" = "count(DemGeneral/DemOperationCycle/eb-list::*) div 8"!]
[!ELSE!]
  [!VAR "MasksArraySize" = "count(DemGeneral/DemOperationCycle/eb-list::*) div 8 + 1"!]
[!ENDIF!]
[!//
#if (defined DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS)
#error DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS already defined
#endif
/** \brief automatic end of opcycle configured for at least 1 opcycle */
#define DEM_OPCYC_NUM_OF_AUTO_END_ENABLED_MASKS [!"num:integer($MasksArraySize)"!]U
[!ELSE!]
#if (defined DEM_OPCYC_AUTO_END_ENABLED)
#error DEM_OPCYC_AUTO_END_ENABLED already defined
#endif
/** \brief automatic end of opcycle not configured for at least 1 opcycle */
#define DEM_OPCYC_AUTO_END_ENABLED STD_OFF
[!ENDIF!]

/* compile switch for OBD DCY */
/* !LINKSTO dsn.Dem.OBD.OPCYC.DCY.CompileSwitch,1 */
#if (defined DEM_OPCYC_OBD_DCY_USED)
#error DEM_OPCYC_OBD_DCY_USED already defined
#endif
[!IF "$isDYCFound = 1"!]
/** \brief OBD DCY not used */
#define DEM_OPCYC_OBD_DCY_USED STD_ON
[!ELSE!]
/** \brief OBD DCY not used */
#define DEM_OPCYC_OBD_DCY_USED STD_OFF
[!ENDIF!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.DCY.0001,1 */
[!IF "$isDYCFound = 1"!]
#if (defined DEM_OPCYC_OBD_DCY_ID)
#error DEM_OPCYC_OBD_DCY_ID already defined
#endif
/** \brief ID of the operation cycle from type 'DEM_OPCYC_OBD_DCY' */
#define DEM_OPCYC_OBD_DCY_ID [!"num:integer($ObdDcyId)"!]U
[!ENDIF!]

/* !LINKSTO dsn.Dem.OBD.OPCYC.IGNITION.0001,1 */
[!IF "$isIgnitionFound = 1"!]
#if (defined DEM_OPCYC_IGNITION_ID)
#error DEM_OPCYC_IGNITION_ID already defined
#endif
/** \brief ID the operation cycle from type 'DEM_OPCYC_IGNITION' */
#define DEM_OPCYC_IGNITION_ID [!"num:integer($ObdIgnitionId)"!]U
[!ENDIF!]

/* Symbolic names of configured aging cycles */
[!VAR "AgeCycCtr" = "0"!]
[!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:existsAndTrue(DemEventClass/DemAgingAllowed)])"!]
  [!LOOP "DemGeneral/DemAgingCycle/eb-list::*"!]
    [!INDENT "0"!]
      [!IF "$DemRteUsage = 'true'"!]
        /* Following macro is generated by the RTE to identify if it is in synch with the current DEM configuration.
         * Notwithstanding, the macro is not intended for the usage via an RTE interface but only via a c API. */
        #if ([!"as:name(.)"!] != [!"num:integer($AgeCycCtr)"!])
        #error Definition of macro [!"as:name(.)"!] does not match to the DEM configuration due to RTE and DEM are out of synch. Please update the RTE based on the newest DEM BSWMD file!
        #endif
      [!ELSE!]
        #if (defined [!"as:name(.)"!])
        #error [!"as:name(.)"!] already defined
        #endif
        /** \brief Symbolic name of aging cycle [!"as:name(.)"!] */
        #define [!"as:name(.)"!][!CALL "Indent", "Length" = "31 - string-length(as:name(.))"!] [!"num:integer($AgeCycCtr)"!]U
      [!ENDIF!]
    [!ENDINDENT!]
    [!VAR "AgeCycCtr" = "$AgeCycCtr + 1"!]
  [!ENDLOOP!]
[!ENDIF!]

#if (defined DEM_NUM_AGINGCYCLES)
#error DEM_NUM_AGINGCYCLES already defined
#endif
/** \brief Number of aging cycles
 **
 ** For these cycles, aging will not be performed based on the operation cycle
 ** of the respective event.
 **
 ** The value is always 0, if ::DEM_USE_AGING is switched off. */
#define DEM_NUM_AGINGCYCLES [!"num:integer($AgeCycCtr)"!]U

/*------------------[OCC5 Configuration]------------------------------------*/
/* !LINKSTO dsn.Dem.OBD.OCC5.VccOcc5Used,1 */
#if (defined DEM_VCC_OCC5_USED)
#error DEM_VCC_OCC5_USED already defined
#endif
[!CALL "GET_VCC_OCC5_USED"!][!//
/* !LINKSTO dsn.Dem.OBD.OCC5.Encapsulation,1 */
[!IF "$VccOcc5Used = 1"!]
  [!WS "0"!]#define DEM_VCC_OCC5_USED          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_VCC_OCC5_USED          STD_OFF
[!ENDIF!]

/*------------------[Operation Cycle Counters Configuration]----------------*/

#if (defined DEM_OPCYCLE_CTR_CSLF_SUPPORT)
#error DEM_OPCYCLE_CTR_CSLF_SUPPORT already defined
#endif
/** \brief Macro for availability of feature cycles since last failed */
[!CALL "IS_INT_DATA_REFERENCED", "InternalDataElement" = "'DEM_CYCLES_SINCE_LAST_FAILED'"!]
[!IF "$IsIntDataReferenced"!]
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSLF_SUPPORT          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSLF_SUPPORT          STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLE_CTR_CSFF_SUPPORT)
#error DEM_OPCYCLE_CTR_CSFF_SUPPORT already defined
#endif
/** \brief Macro for availability of feature cycles since first failed */
[!CALL "IS_INT_DATA_REFERENCED", "InternalDataElement" = "'DEM_CYCLES_SINCE_FIRST_FAILED'"!]
[!IF "$IsIntDataReferenced"!]
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSFF_SUPPORT          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLE_CTR_CSFF_SUPPORT          STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLE_CTR_FAILEDCYCLES_SUPPORT)
#error DEM_OPCYCLE_CTR_FAILEDCYCLES_SUPPORT already defined
#endif
/** \brief Macro for availability of feature cycles since first failed */
[!CALL "IS_INT_DATA_REFERENCED", "InternalDataElement" = "'DEM_FAILED_CYCLES'"!]
[!IF "$IsIntDataReferenced"!]
  [!WS "0"!]#define DEM_OPCYCLE_CTR_FAILEDCYCLES_SUPPORT          STD_ON
[!ELSE!][!//
  [!WS "0"!]#define DEM_OPCYCLE_CTR_FAILEDCYCLES_SUPPORT          STD_OFF
[!ENDIF!]

#if (defined DEM_OPCYCLE_CTRS_SUPPORT)
#error DEM_OPCYCLE_CTRS_SUPPORT already defined
#endif
/** \brief Macro for availability of any of the cycle counters as specified by AUTOSAR */
#if ( (DEM_OPCYCLE_CTR_CSLF_SUPPORT == STD_ON) || (DEM_OPCYCLE_CTR_CSFF_SUPPORT == STD_ON) || (DEM_OPCYCLE_CTR_FAILEDCYCLES_SUPPORT == STD_ON))
#define DEM_OPCYCLE_CTRS_SUPPORT          STD_ON
#else
#define DEM_OPCYCLE_CTRS_SUPPORT          STD_OFF
#endif

/*------------------[Dem BSW Distribution macro]--------------------------------------*/

[!INDENT "0"!][!//
  [!VAR "DemBSWDistributionOfEventReports" = "'false'"!][!//
  [!IF "node:existsAndTrue(DemGeneral/DemBSWDistribution/DemDistributedBSWEventReporting)"!][!//
    [!VAR "DemBSWDistributionOfEventReports" = "'true'"!][!//
  [!ENDIF!][!//
[!ENDINDENT!]
#if (defined DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING)
#error DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING already defined
#endif
/** \brief Macro for verifying if the Dem Multi-Core functionality is enabled */
#define DEM_BSW_DISTRIBUTION_FOR_BSW_EVENT_REPORTING [!IF "$DemBSWDistributionOfEventReports"!][!WS!]STD_ON[!ELSE!][!WS!]STD_OFF[!ENDIF!]

/*------------------[ResetEventStatus Suppression]--------------------------*/

#if (defined DEM_IGNORE_RESET_EVENT_STATUS_FOR_ENTRY)
#error DEM_IGNORE_RESET_EVENT_STATUS_FOR_ENTRY already defined
#endif
/** \brief Macro for Enabling/Disabling the support for ignoring the ResetEventStatus */
/* !LINKSTO dsn.Dem.IgnoreResetEventStatusForEntry.Support.Macro,1 */
/* !LINKSTO dsn.Dem.IgnoreResetEventStatusForEntry.Support,1 */
[!IF "DemGeneral/DemIgnoreResetEventStatusForEventRelatedDataCapturing = 'true'"!]
  [!WS "0"!]#define DEM_IGNORE_RESET_EVENT_STATUS_FOR_ENTRY    STD_ON

  [!WS "0"!]#if (defined DEM_RESISTANT_TF_ARRAY_SIZE)
  [!WS "0"!]#error DEM_RESISTANT_TF_ARRAY_SIZE already defined
  [!WS "0"!]#endif
/** \brief Number of bytes to hold one bit for each event in ::Dem_NvData
 **        for Dem_ResetStatusResistantTFStatus  */
  [!WS "0"!]#define DEM_RESISTANT_TF_ARRAY_SIZE     ((DEM_NUMBER_OF_EVENTS + 7U) / 8U)
[!ELSE!][!//
  [!WS "0"!]#define DEM_IGNORE_RESET_EVENT_STATUS_FOR_ENTRY    STD_OFF
[!ENDIF!]

/*------------------[DemEventConfirmationThresholdCounterAdaptable]---------*/

#if (defined DEM_EVENT_CONFIRMATION_THRESHOLD_COUNTER_ADAPTABLE)
#error  DEM_EVENT_CONFIRMATION_THRESHOLD_COUNTER_ADAPTABLE already defined
#endif
/** \brief Switch for support of API Dem_SetEventConfirmationThresholdCounter */
[!IF "num:integer(count(as:modconf('Dem')[1]/DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:existsAndTrue(DemEventClass/DemEventConfirmationThresholdCounterAdaptable)]))>0"!]
#define DEM_EVENT_CONFIRMATION_THRESHOLD_COUNTER_ADAPTABLE STD_ON
[!ELSE!]
#define DEM_EVENT_CONFIRMATION_THRESHOLD_COUNTER_ADAPTABLE STD_OFF
[!ENDIF!]

/*==================[type definitions]======================================*/

/*------------------[Dem_ConfigType]----------------------------------------*/

/** \brief This type of the external data structure shall contain the post
 **  build initialization data for the Dem.
 **
 ** \note Type is unused, as only pre-compile time support is implemented. */
typedef uint8 Dem_ConfigType;

/*------------------[Dem_FFSegIdxType]--------------------------------------*/

/** \brief Index of freeze frame segment type
 **
 ** Index concerning ::Dem_FFSegments[].
 **
 ** Note: The range (maximum of 65500) of this type is limited by the
 ** configuration (multiplicity of parameter DemDidClass).
 */
typedef uint16 Dem_FFSegIdxType;

[!IF "DemGeneral/DemEventCombinationSupport = 'DEM_EVCOMB_TYPE1'"!]
/*------------------[Dem_DTCConfIdxType]------------------------------------*/
/** \brief Type of DTC configuration index
 **
 ** Note: Type is available only if Event Combination Support is Type 1
 */
[!IF "$CalDtcConfigIdxWidth <= 8"!]
typedef uint8 Dem_DTCConfIdxType;
[!ELSE!][!//
typedef uint16 Dem_DTCConfIdxType;
[!ENDIF!]
[!ENDIF!]

/*==================[external function declarations]========================*/
[!IF "node:exists(DemConfigSet/eb-list::*/DemEventParameter/eb-list::*[node:refexists(DemDTCClassRef) and node:existsAndTrue(as:ref(DemDTCClassRef)/DemImmediateNvStorage)]) or
      (node:existsAndTrue(DemGeneral/DemImmediateStorageInternalEvents)) or (DemGeneral/DemClearDTCBehavior != 'DEM_CLRRESP_VOLATILE')"!]

#define DEM_START_SEC[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCallbackMemStackMainFuncTrigger))"!]_CODE
#include <Dem_MemMap.h>

/** \brief Integration code for Memory stack main function triggering, allowing the Dem module
 ** to indirectly trigger the Memory stack by calling this callout function
 **
 ** Please refer to configuration parameter DemCallbackMemStackMainFuncTrigger for information.
 **
 ** \param[in]  BlockId Id of the NvM block
 **
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_APPL_CODE) [!"DemGeneral/DemCallbackMemStackMainFuncTrigger"!](
  NvM_BlockIdType BlockId);

#define DEM_STOP_SEC[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCallbackMemStackMainFuncTrigger))"!]_CODE
#include <Dem_MemMap.h>

[!ENDIF!]

[!IF "node:exists(DemGeneral/DemCalloutDynamicDTCFnc)"!]

#define DEM_START_SEC[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutDynamicDTCFnc))"!]_CODE
#include <Dem_MemMap.h>

/** \brief Get the variant specific DTC value of an event
 **
 ** The function calculates or looks up a variant specific DTC, based on the EventId
 ** and/or the original DTC value. It is called every time the Dem needs to access an UDS DTC.
 **
 ** \param[in]  EventId  Identification of an event by assigned event ID.
 **                      The event ID is configured in the Dem.
 ** \param[in]  DTC      Original/configured UDS DTC value of the selected event.
 **
 ** \return     Calculated or looked-up variant specific UDS DTC value for the selected event
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint32, DEM_APPL_CODE) [!"DemGeneral/DemCalloutDynamicDTCFnc"!](
  uint16 EventId, uint32 DTC);

#define DEM_STOP_SEC[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutDynamicDTCFnc))"!]_CODE
#include <Dem_MemMap.h>

[!ENDIF!]

[!IF "node:exists(DemGeneral/DemCalloutObdVariantFnc)"!]

#define DEM_START_SEC_CALLOUT_CODE[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutObdVariantFnc))"!]
#include <Dem_MemMap.h>

/** \brief Get the selected active OBD variant
 **
 ** The function selects active OBD variant that Dem shall use during the
 ** initialization phase. It is called every time the Dem is initialized after
 ** the pre-initialization.
 **
 ** \return uint8 value, representing the selected active OBD variant
 ** \retval DEM_OBD_VARIANT_OBD_CLASSIC   selected active OBD variant is OBD Classic
 ** \retval DEM_OBD_VARIANT_OBDONUDS      selected active OBD variant is OBDonUDS
 **
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(uint8, DEM_APPL_CODE) [!"DemGeneral/DemCalloutObdVariantFnc"!](void);

#define DEM_STOP_SEC_CALLOUT_CODE[!"concat('_', text:toupper(as:modconf('Dem')[1]/DemGeneral/DemCalloutObdVariantFnc))"!]
#include <Dem_MemMap.h>

[!ENDIF!]
/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

[!IF "(as:modconf('Dem')[1]/DemGeneral/DemExtendedDataCapture = 'DEM_TRIGGER_ON_FDC_THRESHOLD') and
      (as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementStrategy = 'DEM_DISPLACEMENT_FULL') and
      (node:existsAndTrue(as:modconf('Dem')[1]/DemGeneral/DemEventDisplacementSupport))"!]
#define DEM_START_SEC_CONST_16
#include <Dem_MemMap.h>

  [!VAR "NumLines" = "0"!]
  [!LOOP "DemConfigSet/eb-list::*/DemAdvDisplacementPassiveTableLine/eb-list::*"!]
    [!WS "0"!]/** \brief event IDs of passive events, referenced by [!"as:name(.)"!] */
    [!WS "0"!]extern CONST(Dem_EventIdType, DEM_CONST)
      [!WS "2"!]Dem_AdvDisplPassiveEventIdsLine[!"num:integer($NumLines)"!][DEM_NUM_OF_PASSIVE_EVENT_REFS_LINE[!"num:integer($NumLines)"!]];

      [!VAR "NumLines" = "$NumLines + 1"!]
  [!ENDLOOP!]

#define DEM_STOP_SEC_CONST_16
#include <Dem_MemMap.h>
[!ENDIF!]

#define DEM_START_SEC_CONST_8
#include <Dem_MemMap.h>

/** \brief Configuration structure */
extern CONST(Dem_ConfigType, DEM_CONST) [!"as:name(DemConfigSet/eb-list::*[1])"!];

#define DEM_STOP_SEC_CONST_8
#include <Dem_MemMap.h>

/* !LINKSTO Dem.Dem_FFSegId.External,1 */
[!IF "$CalibrationWithoutEvCombSupport = 'true'"!]
#define DEM_START_SEC_CALIB_16
#include <Dem_MemMap.h>

  [!LOOP "DemGeneral/DemFreezeFrameClass/eb-list::*"!]
    [!VAR "NumFFSegs" = "count(DemDidClassRef/eb-list::*)"!]
    [!WS "0"!]/* Deviation MISRAC2012-1 */
    [!WS "0"!]extern CONST(Dem_FFSegIdxType, DEM_CONST_CALIBRATION)
      Dem_FFSegIdx[!"as:name(.)"!][[!"num:integer($NumFFSegs)"!]];
  [!ENDLOOP!]

#define DEM_STOP_SEC_CALIB_16
#include <Dem_MemMap.h>
[!ENDIF!]

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* ifndef DEM_CFG_H */
/*==================[end of file]===========================================*/
