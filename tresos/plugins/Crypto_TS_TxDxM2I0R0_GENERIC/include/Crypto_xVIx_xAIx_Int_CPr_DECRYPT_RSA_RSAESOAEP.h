/**
 * \file
 *
 * \brief AUTOSAR Crypto
 *
 * This file contains the implementation of the AUTOSAR
 * module Crypto.
 *
 * \version 2.0.39
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2024 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

/* !LINKSTO Crypto.Dsn.Api/Files/Crypto_xVIx_xAIx_Int_CPr_DECRYPT_RSA_RSAESOAEP.h/0001,1 */

#ifndef CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_H
#define CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_H

/*==================[deviations]==================================================================*/

/*==================[includes]====================================================================*/

#include <Crypto_xVIx_xAIx_Int_CPr_DECRYPT_RSA_RSAESOAEP_Cfg.h>  /* !LINKSTO Crypto.Dsn.Api/Files/Crypto_xVIx_xAIx_Int_CPr_DECRYPT_RSA_RSAESOAEP.h/0002,1 */
#include <Crypto_xVIx_xAIx_Int_Lib_LN.h>

/*==================[macros]======================================================================*/

#if (defined CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_MGF_CNTLEN)
  #error CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_MGF_CNTLEN is already defined
#endif
/** \brief Defines the length of the MGF count value */
#define CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_MGF_CNTLEN 4U

#if (defined CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE)
  #error CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE is already defined
#elif (8U > CRYPTO_XVIX_XAIX_DECRYPT_RSA_RSAESOAEP_MAX_RSA_KEY_SIZE)
  #error CRYPTO_XVIX_XAIX_DECRYPT_RSA_RSAESOAEP_MAX_RSA_KEY_SIZE is too small
#endif
/** \brief The maximum length in bytes of the RSA key (modulus + exponent)
 *         The size of two Tags(a 1Byte), two lengths (a 2Byte) and at least 1 Byte
 *         modulo or exponent can be subtracted.
 */
#define CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE \
(CRYPTO_XVIX_XAIX_DECRYPT_RSA_RSAESOAEP_MAX_RSA_KEY_SIZE) - 7U

#if (defined CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_WORD)
  #error CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_WORD is already defined
#endif
/** \brief The maximum length in words of the RSA key. */
#define CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_WORD \
((CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE) / (CRYPTO_XVIX_XAIX_LN_WORD_LEN_BYTES)) + 1U

#if (defined CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSAESOAEP_MAX_DB_LEN)
#error CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSAESOAEP_MAX_DB_LEN is already defined
#endif
/** \brief The maximum length to allocate of DB buffer. Not the actual size of DB. */
#define CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSAESOAEP_MAX_DB_LEN CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE

/*==================[type definitions]============================================================*/

/** \brief The context for a MGF1 calculation.
  *
 * \var Cnt
 * \brief The integer counter of the current hash round.
 *
 * \var Itr
 * \brief The number of hash iterations which are needed to generate the output.
 *
 * \var MaskHashResultLength
 * \brief The number of bytes which shall be generated by the next hash iteration.
 *
 * \var MaskInputLength
 * \brief The length of the MGF1 input array.
 *
 * \var MaskOutputLength
 * \brief The number of bytes which shall be generated during the MGF1 generation.
 *
 * \var MaskInputPtr
 * \brief The pointer to the input array for the MGF1 generation.
 *
 * \var MaskOutputPtr
 * \brief The pointer where the generated MGF1 output is saved to.
 *
 * \var MaskCntStr
 * \brief The bytestring representation of the current hash round integer counter-
*/
typedef struct
{
        uint32                                        Cnt;
        uint32                                        Itr;
        uint32                                        MaskHashResultLength;
        uint32                                        MaskInputLength;
        uint32                                        MaskOutputLength;
  P2VAR(uint8, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) MaskInputPtr;
  P2VAR(uint8, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) MaskOutputPtr;
        uint8                                         MaskCntStr[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_MGF_CNTLEN];
}
Crypto_xVIx_xAIx_DECRYPT_RSA_RSAESOAEP_Mgf1CtxType;

/** \brief  Workspace of primitive DECRYPT_RSA_RSAESOAEP.
 **
 ** ---common---------------------------------------------------------------------
 **
 ** \var    paObjectId
 ** \brief  Value of the Crypto Driver Object Id the primitive was started with.
 **
 ** \var    paPrimitive
 ** \brief  Pointer to crypto driver objects primitive description.
 **
  ** \var    smStateIndx
 ** \brief  The index of the last found entry in the state transition table.
 **
 ** \var    smState
 ** \brief  The current state of the primitive state machine.
 **
 ** \var    smResult
 ** \brief  The result returned to a calling instance.
 **
 ** \var    smOperationDone
 ** \brief  Value holding the flags of executed operation modes.
 **
 ** \var    notifyType
 ** \brief  The value of the callback type received from a secondary primitive via
 **         Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Callback().
 **
 ** \var    notifyResult
 ** \brief  The value of the callback result received from a secondary primitive via
 **         Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Callback().
 **
 ** \var    lockMain
 ** \brief  Flag to lock multiple parallel executions of Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Main().
 **
 ** ---specific-------------------------------------------------------------------
 **
 ** \var    AdditionalInput
 ** \brief  Array where the RSA additional input is stored if used.
 **
 ** \var    AdditionalInputLength
 ** \brief  The length of the RSA additional input.
 **
 ** \var    DbLength
 ** \brief  The length of the DB.
 **
 ** \var    PsLength
 ** \brief  The length of the PS.
 **
 ** \var    NLength
 ** \brief  The length of the Modulus.
 **
 ** \var    HashLength
 ** \brief  The length of the hash algorithm.
 **
 ** \var    HashResultLength
 ** \brief  The length of the hash value of the data.
 **
 ** \var    EMLength
 ** \brief  The length of the EM.
 **
 ** \var    HashResult
 ** \brief  Array where the hash value of the data will be buffered during the computation.
 **
dnl
 ** \var    MgfSeedMask
 ** \brief  Array where the MgfSeedMask is stored.
 **
ifelse(DECRYPT_RSA_RSAESOAEP, ENCRYPT_RSA_RSAESOAEP,dnl
 ** \var    Db
 ** \brief  Array where the dB is stored during the computation.
 **
,) ** \var    DbMask
 ** \brief  Array where the dBMask is stored during the computation.
 **
 ** \var    Ps
 ** \brief  Array where the Ps is stored during the computation.
 **
 ** \var    EM
 ** \brief  Array where the EM is stored during the computation.
 **
 ** \var    Tmp1Value
 ** \brief  An array which is used as a buffer during the computation.
 **
 ** \var    Tmp2Value
 ** \brief  An array which is used as a buffer during the computation.
 **
 ** \var    lnCtx
 ** \brief  The context which has to be used for long number arithmetic.
 **
 ** \var    Mgf1Ctx
 ** \brief  The context for the MGF1 masking function.
 **
 ** \var    secondaryJob_primitiveInfo
 ** \brief  The primitiveInfo structure of the secondary job.
 **
 ** \var    secondaryJob_jobPrimitiveInfo
 ** \brief  The jobPrimitiveInfo structure of the secondary job.
 **
 ** \var    secondaryJob_jobInfo
 ** \brief  The jobInfo structure of the secondary job.
 **
 ** \var    secondaryJob
 ** \brief  The job structure of the secondary job.
 **
 **/

/* !LINKSTO Crypto.Dsn.Api/Types/Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_WorkspaceType/0001,1 */

#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
typedef struct
{
  /* ---common--------------------------------------------------------------------- */
  uint32 paObjectId;

  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) paPrimitive;
  uint8                                         smStateIndx;
  boolean                                       lockMain;

  Crypto_xVIx_xAIx_PrimitiveStateIdentifierType smState;
  Std_ReturnType                                smResult;
  Crypto_OperationModeType                      smOperationDone;
  Crypto_xVIx_xAIx_CallbackType                 notifyType;
  Std_ReturnType                                notifyResult;
  /* ---specific------------------------------------------------------------------- */
          uint8  AdditionalInput[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE];
          uint32 AdditionalInputLength;
          uint32 DbLength;
          uint32 PsLength;
          uint32 NLength;
          uint32 HashLength;
          uint32 HashResultLength;
          uint32 EMLength;
          uint8  HashResult[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_HASHRESULTSIZE];
          uint8  MgfSeedMask[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_HASHRESULTSIZE];
          uint8  DbMask[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSAESOAEP_MAX_DB_LEN];
          uint8  Ps[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_BYTE];
          uint8  EM[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSAESOAEP_MAX_DB_LEN + CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_HASHRESULTSIZE + 1U];

          Crypto_xVIx_xAIx_DECRYPT_RSA_RSAESOAEP_Mgf1CtxType                                     Mgf1Ctx;
          Crypto_xVIx_xAIx_LNCtxType                                          lnCtx;

          Crypto_xVIx_xAIx_LNWordType                                         Tmp1Value[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_WORD];
          Crypto_xVIx_xAIx_LNWordType                                         Tmp2Value[CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_RSA_PUBLIC_MAX_KEY_SIZE_WORD];
/*
    P2VAR(Crypto_xVIx_xAIx_LNWordType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) heapTmp1;
    P2VAR(Crypto_xVIx_xAIx_LNWordType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) heapTmp2;
*/
    P2VAR(Crypto_xVIx_xAIx_LNWordType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) modulus;
          Crypto_xVIx_xAIx_LNWordType                                         modulusLen;
          Crypto_xVIx_xAIx_LNWordType                                         pubExpLen;
  P2CONST(Crypto_xVIx_xAIx_LNWordType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) priExp;
          Crypto_xVIx_xAIx_LNWordType                                         priExpLen;
          Crypto_xVIx_xAIx_NonConstPrimitiveInfoType                          secondaryJob_primitiveInfo;
          Crypto_JobPrimitiveInfoType                                         secondaryJob_jobPrimitiveInfo;

          Crypto_JobInfoType                                                  secondaryJob_jobInfo;
          Crypto_JobType                                                      secondaryJob;
}
Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_WorkspaceType;
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/*==================[external constants]==========================================================*/

/*==================[external data]===============================================================*/

/*==================[external function declarations]==============================================*/

#define CRYPTO_xVIx_xAIx_START_SEC_CODE
#include <Crypto_xVIx_xAIx_MemMap.h>

/** \brief  Triggers the asynchronous or performs the synchronous processing of the primitive.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK                   Request successful.
 ** \retval  E_NOT_OK               Request failed.
 ** \retval  CRYPTO_E_JOB_CANCELED  Request failed, because job using this primitive was cancelled.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Process
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/** \brief  Triggers the processing of the primitives state machine.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK      Request successful.
 ** \retval  E_NOT_OK  Request failed.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Main
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/** \brief  Requests the cancelation of the processing of the primitive.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK      Request successful.
 ** \retval  E_NOT_OK  Request failed.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Cancel
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/** \brief  Requests the hard reset of the processing of the primitive.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK      Request successful.
 ** \retval  E_NOT_OK  Request failed.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Reset
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/** \brief  Requests the hard restart of the processing of the primitive.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK      Request successful.
 ** \retval  E_NOT_OK  Request failed.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Restart
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

/** \brief  Notifies the primitive about the completion of the request of a secondary primitive.
 **
 ** \param[in]      objectId   Holds the identifier of the Crypto Driver Object.
 ** \param[in,out]  job        Pointer to the configuration of the job this primitive shall be
 **                            processed for. This contains structures with job and primitive
 **                            relevant information but also pointers to result buffers.
 ** \param[in]      primitive  Pointer to the data structure describes the current primitive.
 ** \param[in]      cbkType    The type (none, start, update, finish, cancel) of the callback.
 ** \param[in]      cbkResult  The result of the callback.
 **
 ** \returns  Error value.
 **
 ** \retval  E_OK      Request successful.
 ** \retval  E_NOT_OK  Request failed.
 **
 ** \Synchronicity{Sync}
 ** \Reentrancy{Reentrant}
 **/
#if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON)
extern FUNC(Std_ReturnType, CRYPTO_xVIx_xAIx_CODE) Crypto_xVIx_xAIx_CPr_DECRYPT_RSA_RSAESOAEP_Callback
(
          uint32                                                                    objectId,
    P2VAR(Crypto_JobType,                    AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) job,
  P2CONST(Crypto_xVIx_xAIx_CDOPrimitiveType, AUTOMATIC, CRYPTO_xVIx_xAIx_APPL_DATA) primitive,
          Crypto_xVIx_xAIx_CallbackType                                             cbkType,
          Std_ReturnType                                                            cbkResult
);
#endif /* #if (CRYPTO_XVIX_XAIX_API_ENABLED_CPR_DECRYPT_RSA_RSAESOAEP == STD_ON) */

#define CRYPTO_xVIx_xAIx_STOP_SEC_CODE
#include <Crypto_xVIx_xAIx_MemMap.h>

/*================================================================================================*/

#endif /* #ifndef CRYPTO_XVIX_XAIX_INT_CPR_DECRYPT_RSA_RSAESOAEP_H */

/*==================[end of file]=================================================================*/

